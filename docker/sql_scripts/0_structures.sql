--
-- PostgreSQL database dump
--

-- Dumped from database version 13.11
-- Dumped by pg_dump version 13.11

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: aaa_jdbc; Type: SCHEMA; Schema: -; Owner: engine
--

CREATE SCHEMA aaa_jdbc;


ALTER SCHEMA aaa_jdbc OWNER TO engine;

--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: all_cluster_usage_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.all_cluster_usage_rs AS (
	quota_cluster_id uuid,
	quota_id uuid,
	cluster_id uuid,
	cluster_name character varying(40),
	virtual_cpu integer,
	virtual_cpu_usage integer,
	mem_size_mb bigint,
	mem_size_mb_usage bigint
);


ALTER TYPE public.all_cluster_usage_rs OWNER TO engine;

--
-- Name: all_storage_usage_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.all_storage_usage_rs AS (
	quota_storage_id uuid,
	quota_id uuid,
	storage_id uuid,
	storage_name character varying(250),
	storage_size_gb bigint,
	storage_size_gb_usage double precision
);


ALTER TYPE public.all_storage_usage_rs OWNER TO engine;

--
-- Name: async_tasks_info_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.async_tasks_info_rs AS (
	dc_id uuid,
	dc_name character varying,
	spm_host_id uuid,
	spm_host_name character varying,
	task_count integer
);


ALTER TYPE public.async_tasks_info_rs OWNER TO engine;

--
-- Name: authzentryinfotype; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.authzentryinfotype AS (
	name text,
	namespace character varying(2048),
	authz character varying(255)
);


ALTER TYPE public.authzentryinfotype OWNER TO engine;

--
-- Name: booleanresulttype; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.booleanresulttype AS (
	result boolean
);


ALTER TYPE public.booleanresulttype OWNER TO engine;

--
-- Name: cluster_usage_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.cluster_usage_rs AS (
	virtual_cpu_usage integer,
	mem_size_mb_usage bigint
);


ALTER TYPE public.cluster_usage_rs OWNER TO engine;

--
-- Name: disks_basic_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.disks_basic_rs AS (
	disk_id uuid,
	disk_alias character varying(255),
	size bigint
);


ALTER TYPE public.disks_basic_rs OWNER TO engine;

--
-- Name: entity_name_map_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.entity_name_map_rs AS (
	entity_id uuid,
	entity_name text
);


ALTER TYPE public.entity_name_map_rs OWNER TO engine;

--
-- Name: get_all_commands_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.get_all_commands_rs AS (
	command_id uuid,
	command_type character varying(256)
);


ALTER TYPE public.get_all_commands_rs OWNER TO engine;

--
-- Name: getallfromsnapshotsbyvmid_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getallfromsnapshotsbyvmid_rs AS (
	snapshot_id uuid,
	vm_id uuid,
	snapshot_type character varying(32),
	status character varying(32),
	description character varying(4000),
	creation_date timestamp with time zone,
	app_list text,
	memory_dump_disk_id uuid,
	memory_metadata_disk_id uuid,
	vm_configuration text,
	vm_configuration_available boolean,
	vm_configuration_broken boolean,
	changed_fields text
);


ALTER TYPE public.getallfromsnapshotsbyvmid_rs OWNER TO engine;

--
-- Name: getallfromvm_pools_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getallfromvm_pools_rs AS (
	vm_pool_id uuid,
	assigned_vm_count integer,
	vm_running_count integer,
	vm_pool_description character varying(4000),
	vm_pool_comment text,
	vm_pool_name character varying(255),
	vm_pool_type integer,
	stateful boolean,
	parameters character varying(200),
	prestarted_vms integer,
	cluster_id uuid,
	cluster_name character varying(40),
	max_assigned_vms_per_user smallint,
	spice_proxy character varying(255),
	is_being_destroyed boolean,
	is_auto_storage_select boolean
);


ALTER TYPE public.getallfromvm_pools_rs OWNER TO engine;

--
-- Name: getallhashesfromvmdynamic_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getallhashesfromvmdynamic_rs AS (
	vm_guid uuid,
	hash character varying
);


ALTER TYPE public.getallhashesfromvmdynamic_rs OWNER TO engine;

--
-- Name: getorderedvmguidsforrunmultipleactions_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getorderedvmguidsforrunmultipleactions_rs AS (
	vm_guid uuid
);


ALTER TYPE public.getorderedvmguidsforrunmultipleactions_rs OWNER TO engine;

--
-- Name: getstoragedomainidsbystoragepoolidandstatus_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getstoragedomainidsbystoragepoolidandstatus_rs AS (
	storage_id uuid
);


ALTER TYPE public.getstoragedomainidsbystoragepoolidandstatus_rs OWNER TO engine;

--
-- Name: getsystem_statistics_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.getsystem_statistics_rs AS (
	val integer
);


ALTER TYPE public.getsystem_statistics_rs OWNER TO engine;

--
-- Name: host_networks_by_cluster_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.host_networks_by_cluster_rs AS (
	vds_id uuid,
	network_name character varying
);


ALTER TYPE public.host_networks_by_cluster_rs OWNER TO engine;

--
-- Name: host_vm_cluster_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.host_vm_cluster_rs AS (
	cluster_id uuid,
	hosts bigint,
	vms bigint,
	hosts_with_update_available bigint
);


ALTER TYPE public.host_vm_cluster_rs OWNER TO engine;

--
-- Name: idtexttype; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.idtexttype AS (
	id text
);


ALTER TYPE public.idtexttype OWNER TO engine;

--
-- Name: iduuidtype; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.iduuidtype AS (
	id uuid
);


ALTER TYPE public.iduuidtype OWNER TO engine;

--
-- Name: network_attachments_qos_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.network_attachments_qos_rs AS (
	id uuid,
	network_id uuid,
	nic_id uuid,
	boot_protocol character varying(20),
	address character varying(20),
	netmask character varying(20),
	gateway character varying(20),
	custom_properties text,
	_create_date timestamp with time zone,
	_update_date timestamp with time zone,
	ipv6_boot_protocol character varying(20),
	ipv6_address character varying(50),
	ipv6_prefix integer,
	ipv6_gateway character varying(50),
	dns_resolver_configuration_id uuid,
	qos_id uuid,
	qos_name character varying(50),
	qos_type smallint,
	out_average_linkshare integer,
	out_average_upperlimit integer,
	out_average_realtime integer
);


ALTER TYPE public.network_attachments_qos_rs OWNER TO engine;

--
-- Name: networkviewclustertype; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.networkviewclustertype AS (
	id uuid,
	name character varying(256),
	vdsm_name character varying(15),
	description character varying(4000),
	free_text_comment text,
	type integer,
	addr character varying(50),
	subnet character varying(20),
	gateway character varying(20),
	vlan_id integer,
	stp boolean,
	storage_pool_id uuid,
	mtu integer,
	vm_network boolean,
	label text,
	provider_network_provider_id uuid,
	provider_network_external_id text,
	provider_physical_network_id uuid,
	qos_id uuid,
	dns_resolver_configuration_id uuid,
	port_isolation boolean,
	network_id uuid,
	cluster_id uuid,
	status integer,
	is_display boolean,
	required boolean,
	migration boolean,
	management boolean,
	is_gluster boolean,
	default_route boolean
);


ALTER TYPE public.networkviewclustertype OWNER TO engine;

--
-- Name: user_permissions; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.user_permissions AS (
	permission_id uuid,
	role_id uuid,
	user_id uuid
);


ALTER TYPE public.user_permissions OWNER TO engine;

--
-- Name: vds_interface_view_qos_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.vds_interface_view_qos_rs AS (
	rx_rate numeric(24,4),
	tx_rate numeric(24,4),
	rx_drop numeric(20,0),
	tx_drop numeric(20,0),
	rx_total numeric(20,0),
	tx_total numeric(20,0),
	rx_offset numeric(20,0),
	tx_offset numeric(20,0),
	iface_status integer,
	sample_time double precision,
	type integer,
	gateway character varying(20),
	ipv4_default_route boolean,
	ipv6_gateway character varying(50),
	subnet character varying(20),
	ipv6_prefix integer,
	addr character varying(20),
	ipv6_address character varying(50),
	speed integer,
	base_interface character varying(50),
	vlan_id integer,
	bond_type integer,
	bond_name character varying(50),
	is_bond boolean,
	bond_opts character varying(4000),
	mac_addr character varying(59),
	network_name character varying(256),
	name character varying(50),
	vds_id uuid,
	vds_name character varying(255),
	id uuid,
	boot_protocol integer,
	ipv6_boot_protocol integer,
	mtu integer,
	bridged boolean,
	reported_switch_type character varying(6),
	is_vds integer,
	qos_overridden boolean,
	labels text,
	cluster_id uuid,
	ad_partner_mac character varying(59),
	ad_aggregator_id integer,
	bond_active_slave character varying(50),
	qos_id uuid,
	qos_name character varying(50),
	qos_type smallint,
	out_average_linkshare integer,
	out_average_upperlimit integer,
	out_average_realtime integer
);


ALTER TYPE public.vds_interface_view_qos_rs OWNER TO engine;

--
-- Name: vmexternaldata_rs; Type: TYPE; Schema: public; Owner: engine
--

CREATE TYPE public.vmexternaldata_rs AS (
	data text,
	hash text
);


ALTER TYPE public.vmexternaldata_rs OWNER TO engine;

--
-- Name: checkdbconnection(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.checkdbconnection() RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN QUERY SELECT 1;
END; $$;


ALTER FUNCTION aaa_jdbc.checkdbconnection() OWNER TO engine;

--
-- Name: convert_password(character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.convert_password(old_password character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  _items TEXT[];
BEGIN
  _items := regexp_split_to_array(old_password, E'\\|+');
  RETURN
    encode(
      convert_to(
        '{"artifact":"EnvelopePBE","salt":"' || _items[3] ||
        '","secret":"' || _items[5] ||
        '","version":"' || _items[1] ||
        '","iterations":"' || _items[4] ||
        '","algorithm":"' || _items[2] ||
        '"}',
        current_setting('server_encoding')
      ),
      'base64'
    );
END;
$$;


ALTER FUNCTION aaa_jdbc.convert_password(old_password character varying) OWNER TO engine;

--
-- Name: fn_db_add_column(character varying, character varying, text); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_add_column(v_table character varying, v_column character varying, v_column_def text) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
v_sql text;

begin
	if (not exists (select 1 from information_schema.columns where table_schema = 'aaa_jdbc' and table_name ilike v_table and column_name ilike v_column)) then
	    begin
		v_sql := 'ALTER TABLE ' || v_table || ' ADD COLUMN ' || v_column || ' ' || v_column_def;
		EXECUTE v_sql;
            end;
	end if;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_add_column(v_table character varying, v_column character varying, v_column_def text) OWNER TO engine;

--
-- Name: fn_db_add_config_value_for_versions_up_to(character varying, character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_add_config_value_for_versions_up_to(v_option_name character varying, v_val character varying, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
    i   int;
    arr varchar[] := array['3.0', '3.1', '3.2', '3.3', '3.4', '3.5', '3.6'];
begin
    FOR i IN array_lower(arr, 1) .. array_upper(arr, 1)
    LOOP
        PERFORM fn_db_add_config_value(v_option_name, v_val, arr[i]);
        EXIT WHEN  arr[i] = v_version;
    END LOOP;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_add_config_value_for_versions_up_to(v_option_name character varying, v_val character varying, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_change_column_type(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_change_column_type(v_table character varying, v_column character varying, v_type character varying, v_new_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
v_sql text;

begin
	if (exists (select 1 from information_schema.columns where table_schema = 'aaa_jdbc' and table_name ilike v_table and column_name ilike v_column and (udt_name ilike v_type or data_type ilike v_type))) then
	    begin
		v_sql := 'ALTER TABLE ' || v_table || ' ALTER COLUMN ' || v_column || ' TYPE ' || v_new_type;
		EXECUTE v_sql;
            end;
            --- ignore operation if requested type is already there
        elsif (not exists (select 1 from information_schema.columns where table_schema = 'aaa_jdbc' and table_name ilike v_table and column_name ilike v_column and
                (udt_name ilike v_new_type or data_type ilike v_new_type))) then
            RAISE EXCEPTION 'Table % or Column % does not exist.', v_table, v_column;
	end if;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_change_column_type(v_table character varying, v_column character varying, v_type character varying, v_new_type character varying) OWNER TO engine;

--
-- Name: fn_db_create_constraint(character varying, character varying, text); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_create_constraint(v_table character varying, v_constraint character varying, v_constraint_sql text) RETURNS void
    LANGUAGE plpgsql
    AS $$
begin
    if  NOT EXISTS (SELECT 1 from pg_constraint where conname ilike v_constraint) then
        execute 'ALTER TABLE ' || v_table ||  ' ADD CONSTRAINT ' || v_constraint || ' ' || v_constraint_sql;
    end if;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_create_constraint(v_table character varying, v_constraint character varying, v_constraint_sql text) OWNER TO engine;

--
-- Name: fn_db_create_index(character varying, character varying, text, text); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_create_index(v_index_name character varying, v_table_name character varying, v_column_names text, v_where_predicate text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_sql TEXT;
BEGIN
    v_sql := 'DROP INDEX ' || ' IF EXISTS ' || v_index_name || '; CREATE INDEX ' || v_index_name || ' ON ' || v_table_name || '(' || v_column_names || ')';
    IF v_where_predicate = '' THEN
        v_sql := v_sql || ';';
    ELSE
        v_sql := v_sql || ' WHERE ' || v_where_predicate || ';';
    END IF;
    EXECUTE v_sql;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_create_index(v_index_name character varying, v_table_name character varying, v_column_names text, v_where_predicate text) OWNER TO engine;

--
-- Name: fn_db_drop_column(character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_drop_column(v_table character varying, v_column character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
v_sql text;
begin
        if (exists (select 1 from information_schema.columns where table_schema = 'aaa_jdbc' and table_name ilike v_table and column_name ilike v_column)) then
            begin
                v_sql := 'ALTER TABLE ' || v_table || ' DROP COLUMN ' || v_column;
                EXECUTE v_sql;
            end;
        else
            RAISE EXCEPTION 'Table % or Column % does not exist.', v_table, v_column;
        end if;
end;$$;


ALTER FUNCTION aaa_jdbc.fn_db_drop_column(v_table character varying, v_column character varying) OWNER TO engine;

--
-- Name: fn_db_drop_constraint(character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_drop_constraint(v_table character varying, v_constraint character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
begin
    if  EXISTS (SELECT 1 from pg_constraint where conname ilike v_constraint) then
        execute 'ALTER TABLE ' || v_table ||  ' DROP CONSTRAINT ' || v_constraint || ' CASCADE';
    end if;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_drop_constraint(v_table character varying, v_constraint character varying) OWNER TO engine;

--
-- Name: fn_db_is_table_exists(character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_is_table_exists(v_table character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
   declare
   retvalue  boolean;
BEGIN
   retvalue := EXISTS (
        SELECT * FROM information_schema.tables WHERE table_schema = 'aaa_jdbc' AND table_name ILIKE v_table
   );
   return retvalue;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_is_table_exists(v_table character varying) OWNER TO engine;

--
-- Name: fn_db_mask_object(regclass); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_mask_object(v_object regclass) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_sql TEXT;
    v_table record;
    v_table_name TEXT;
    temprec record;
BEGIN
    -- get full table/view name from v_object (i.e <namespace>.<name>)
    select c.relname, n.nspname INTO v_table
        FROM pg_class c join pg_namespace n on c.relnamespace = n.oid WHERE c.oid = v_object;
    -- try to get filtered query syntax from previous execution
    if exists (select 1 from object_column_white_list_sql where object_name = v_table.relname) then
	select sql into v_sql from object_column_white_list_sql where object_name = v_table.relname;
    else
        v_table_name := quote_ident( v_table.nspname ) || '.' || quote_ident( v_table.relname );
        -- compose sql statement while skipping values for columns not defined in object_column_white_list for this table.
        for temprec in select a.attname, t.typname
                       FROM pg_attribute a join pg_type t on a.atttypid = t.oid
                       WHERE a.attrelid = v_object AND a.attnum > 0 AND NOT a.attisdropped ORDER BY a.attnum
        loop
            v_sql := coalesce( v_sql || ', ', 'SELECT ' );
            if exists(select 1 from object_column_white_list
               where object_name = v_table.relname and column_name = temprec.attname) then
               v_sql := v_sql || quote_ident( temprec.attname );
            ELSE
               v_sql := v_sql || 'NULL::' || quote_ident( temprec.typname ) || ' as ' || quote_ident( temprec.attname );
            END IF;
        END LOOP;
        v_sql := v_sql || ' FROM ' || v_table_name;
        v_sql := 'SELECT x::' || v_table_name || ' as rec FROM (' || v_sql || ') as x';
        -- save generated query for further use
        insert into object_column_white_list_sql(object_name,sql) values (v_table.relname, v_sql);
    end if;
    RETURN QUERY EXECUTE v_sql;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_mask_object(v_object regclass) OWNER TO engine;

--
-- Name: fn_db_rename_column(character varying, character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_db_rename_column(v_table character varying, v_column character varying, v_new_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
v_sql text;

begin
	if (exists (select 1 from information_schema.columns where table_schema = 'aaa_jdbc' and table_name ilike v_table and column_name ilike v_column)) then
	    begin
		v_sql := 'ALTER TABLE ' || v_table || ' RENAME COLUMN ' || v_column || ' TO ' || v_new_name;
		EXECUTE v_sql;
            end;
        else
            RAISE EXCEPTION 'Table % or Column % does not exist.', v_table, v_column;
	end if;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_db_rename_column(v_table character varying, v_column character varying, v_new_name character varying) OWNER TO engine;

--
-- Name: fn_get_column_size(character varying, character varying); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.fn_get_column_size(v_table character varying, v_column character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
   declare
   retvalue  integer;
BEGIN
   retvalue := character_maximum_length from information_schema.columns
    where
    table_schema = 'aaa_jdbc' and
    table_name ilike v_table and column_name ilike v_column and
    table_schema = 'aaa_jdbc' and udt_name in ('char','varchar');
   return retvalue;
END; $$;


ALTER FUNCTION aaa_jdbc.fn_get_column_size(v_table character varying, v_column character varying) OWNER TO engine;

--
-- Name: generate_drop_all_functions_syntax(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.generate_drop_all_functions_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select 'drop function if exists ' || ns.nspname || '.' || proname || '(' || oidvectortypes(proargtypes) || ') cascade;' from pg_proc inner join pg_namespace ns on (pg_proc.pronamespace=ns.oid) where ns.nspname = 'aaa_jdbc' order by proname;
END; $$;


ALTER FUNCTION aaa_jdbc.generate_drop_all_functions_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_seq_syntax(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.generate_drop_all_seq_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select 'DROP SEQUENCE if exists ' || sequence_schema || '.' || sequence_name || ' CASCADE;' from information_schema.sequences  where sequence_schema = 'aaa_jdbc' order by sequence_name;
END; $$;


ALTER FUNCTION aaa_jdbc.generate_drop_all_seq_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_tables_syntax(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.generate_drop_all_tables_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select 'DROP TABLE if exists ' || table_schema || '.' || table_name || ' CASCADE;' from information_schema.tables where table_schema = 'aaa_jdbc' and table_type = 'BASE TABLE' order by table_name;
END; $$;


ALTER FUNCTION aaa_jdbc.generate_drop_all_tables_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_user_types_syntax(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.generate_drop_all_user_types_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT 'DROP TYPE if exists ' || c.relname::information_schema.sql_identifier || ' CASCADE;'
   FROM pg_namespace n, pg_class c, pg_type t
   WHERE n.oid = c.relnamespace and t.typrelid = c.oid and c.relkind = 'c'::"char" and
   n.nspname = 'aaa_jdbc'
   ORDER BY  c.relname::information_schema.sql_identifier;
END; $$;


ALTER FUNCTION aaa_jdbc.generate_drop_all_user_types_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_views_syntax(); Type: FUNCTION; Schema: aaa_jdbc; Owner: engine
--

CREATE FUNCTION aaa_jdbc.generate_drop_all_views_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select 'DROP VIEW if exists ' || table_schema || '.' || table_name || ' CASCADE;' from information_schema.views where table_schema = 'aaa_jdbc' order by table_name;
END; $$;


ALTER FUNCTION aaa_jdbc.generate_drop_all_views_syntax() OWNER TO engine;

--
-- Name: __temp_getorcreateicon(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.__temp_getorcreateicon(icon_data character varying) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    icon_id UUID := (SELECT id FROM vm_icons WHERE data_url = icon_data);
BEGIN
    IF icon_id IS NULL THEN
        INSERT INTO vm_icons(id, data_url)
        VALUES (uuid_in(md5(random()::text)::cstring), icon_data)
        RETURNING id INTO icon_id;
    END IF;
    RETURN icon_id;
END;
$$;


ALTER FUNCTION public.__temp_getorcreateicon(icon_data character varying) OWNER TO engine;

--
-- Name: addconnectiontoiscsibond(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.addconnectiontoiscsibond(v_iscsi_bond_id uuid, v_connection_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO iscsi_bonds_storage_connections_map (
        iscsi_bond_id,
        connection_id
        )
    VALUES (
        v_iscsi_bond_id,
        v_connection_id
        );
END;$$;


ALTER FUNCTION public.addconnectiontoiscsibond(v_iscsi_bond_id uuid, v_connection_id character varying) OWNER TO engine;

--
-- Name: addglusterserverknownaddress(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.addglusterserverknownaddress(v_server_id uuid, v_known_address character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server
    SET known_addresses = coalesce(known_addresses || ',', '') || v_known_address
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.addglusterserverknownaddress(v_server_id uuid, v_known_address character varying) OWNER TO engine;

--
-- Name: addhosttolabels(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.addhosttolabels(v_host_id uuid, v_labels uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    o uuid;
BEGIN
    INSERT INTO labels_map (
        label_id,
        vds_id
    )
    SELECT unnest(v_labels), v_host_id;
END;$$;


ALTER FUNCTION public.addhosttolabels(v_host_id uuid, v_labels uuid[]) OWNER TO engine;

--
-- Name: addnetworktoiscsibond(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.addnetworktoiscsibond(v_iscsi_bond_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO iscsi_bonds_networks_map (
        iscsi_bond_id,
        network_id
        )
    VALUES (
        v_iscsi_bond_id,
        v_network_id
        );
END;$$;


ALTER FUNCTION public.addnetworktoiscsibond(v_iscsi_bond_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: addvmtolabels(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.addvmtolabels(v_vm_id uuid, v_labels uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    o uuid;
BEGIN
    INSERT INTO labels_map (
        label_id,
        vm_id
    )
    SELECT unnest(v_labels), v_vm_id;
END;$$;


ALTER FUNCTION public.addvmtolabels(v_vm_id uuid, v_labels uuid[]) OWNER TO engine;

--
-- Name: attach_group_to_role(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.attach_group_to_role(v_group_name character varying, v_role_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    DECLARE selected_group_id uuid;
    input_role_id uuid;
    BEGIN
       SELECT roles.id
       INTO input_role_id
       FROM roles
       WHERE roles.name = v_role_name;
       -- The external identifier is the user identifier converted to an array of
       -- bytes:
       INSERT INTO ad_groups (
           id,
           name,
           external_id
           )
       SELECT uuid_generate_v1(),
           v_group_name,
           uuid_generate_v1()
       WHERE NOT EXISTS (
               SELECT 1
               FROM ad_groups
               WHERE name = v_group_name
               );
       SELECT id
       FROM ad_groups
       WHERE name = v_group_name
       INTO selected_group_id;
       IF NOT EXISTS (
                   SELECT 1
                   FROM permissions
                   WHERE ad_element_id = selected_group_id
                     AND role_id = input_role_id
                   ) THEN
                         PERFORM InsertPermission(
                             selected_group_id,
                             uuid_generate_v1(),
                             input_role_id,
                             getGlobalIds('system'),
                             1);
       END IF;
    END;$$;


ALTER FUNCTION public.attach_group_to_role(v_group_name character varying, v_role_name character varying) OWNER TO engine;

--
-- Name: attach_user_to_role(character varying, character varying, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.attach_user_to_role(v_user_name character varying, v_domain character varying, v_namespace character varying, v_domain_entry_id text, v_role_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE selected_user_id uuid;

    input_role_id uuid;

    BEGIN
        SELECT roles.id
        INTO input_role_id
        FROM roles
        WHERE roles.name = v_role_name;

        -- The external identifier is the user identifier converted to an array of
        -- bytes:
        INSERT INTO users (
            user_id,
            external_id,
            namespace,
            name,
            domain,
            username,
            last_admin_check_status
            )
        SELECT uuid_generate_v1(),
            v_domain_entry_id,
            v_namespace,
            v_user_name,
            v_domain,
            v_user_name,
            true
        WHERE NOT EXISTS (
                SELECT 1
                FROM users
                WHERE domain = v_domain
                    AND external_id = v_domain_entry_id
                );

        SELECT user_id
        FROM users
        WHERE domain = v_domain
            AND external_id = v_domain_entry_id
        INTO selected_user_id;

        PERFORM InsertPermission(selected_user_id, uuid_generate_v1(), input_role_id, getGlobalIds('system'), 1);

    END;$$;


ALTER FUNCTION public.attach_user_to_role(v_user_name character varying, v_domain character varying, v_namespace character varying, v_domain_entry_id text, v_role_name character varying) OWNER TO engine;

--
-- Name: boundvmpoolprestartedvms(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.boundvmpoolprestartedvms(v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_pools
    SET prestarted_vms = LEAST (
        prestarted_vms, (
            SELECT COUNT (*)
            FROM vm_pool_map
            WHERE vm_pool_id = v_vm_pool_id
            )
        )
    WHERE vm_pool_id = v_vm_pool_id;
END;$$;


ALTER FUNCTION public.boundvmpoolprestartedvms(v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: calculateallclusterusage(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.calculateallclusterusage() RETURNS SETOF public.all_cluster_usage_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT
        quota_limitation.id AS quota_cluster_id,
        quota_limitation.quota_id AS quota_id,
        quota_limitation.cluster_id AS cluster_id,
        cluster.name AS cluster_name,
        quota_limitation.virtual_cpu,
        cast(COALESCE(sum(num_of_sockets * cpu_per_socket * cast(vm_dynamic.status NOT IN (
                            SELECT getNonCountableQutoaVmStatuses()
                            ) AS INT)), 0) AS INT) AS virtual_cpu_usage,
        quota_limitation.mem_size_mb,
        COALESCE(sum(vm_static.mem_size_mb), 0) AS mem_size_mb_usage
    FROM quota_limitation
    LEFT JOIN vm_static
        ON vm_static.quota_id = quota_limitation.quota_id
    LEFT JOIN vm_dynamic
        ON vm_dynamic.vm_guid = vm_static.vm_guid
    LEFT JOIN cluster
        ON cluster.cluster_id = vm_static.cluster_id
    WHERE quota_limitation.virtual_cpu IS NOT NULL
        AND quota_limitation.mem_size_mb IS NOT NULL
    GROUP BY quota_limitation.quota_id,
        quota_limitation.cluster_id,
        cluster_name,
        quota_limitation.virtual_cpu,
        quota_limitation.mem_size_mb,
        vm_static.quota_id,
        cluster.cluster_id,
        vm_static.cluster_id,
        quota_limitation.id;
END;$$;


ALTER FUNCTION public.calculateallclusterusage() OWNER TO engine;

--
-- Name: calculateallstorageusage(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.calculateallstorageusage() RETURNS SETOF public.all_storage_usage_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
-- Summarize size of all disks that are active.
    RETURN QUERY

    SELECT
        quota_limitation.id AS quota_storage_id,
        quota_limitation.quota_id AS quota_id,
        quota_limitation.storage_id AS storage_id,
        storage_domain_static.storage_name,
        quota_limitation.storage_size_gb,
        cast(COALESCE(sum(size * cast(active AS INT) + disk_image_dynamic.actual_size * cast((NOT active) AS INT)) / 1073741824, 0) AS FLOAT) AS storage_usage
        -- 1073741824 is 1024^3 (for GB)
    FROM quota_limitation
    LEFT JOIN image_storage_domain_map
        ON quota_limitation.quota_id = image_storage_domain_map.quota_id
    LEFT JOIN images
        ON images.image_guid = image_storage_domain_map.image_id
    LEFT JOIN disk_image_dynamic
        ON images.image_guid = disk_image_dynamic.image_id
    LEFT JOIN storage_domain_static
        ON image_storage_domain_map.storage_domain_id = storage_domain_static.id
    WHERE quota_limitation.storage_size_gb IS NOT NULL
    GROUP BY
        quota_limitation.quota_id,
        storage_id,
        quota_limitation.id,
        storage_domain_static.storage_name,
        quota_limitation.storage_size_gb;
END;$$;


ALTER FUNCTION public.calculateallstorageusage() OWNER TO engine;

--
-- Name: calculateclusterusage(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.calculateclusterusage(v_quota_id uuid, v_cluster_id uuid) RETURNS SETOF public.cluster_usage_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cast(COALESCE(sum(num_of_sockets * cpu_per_socket), 0) AS INT) AS virtual_cpu_usage,
           COALESCE(sum(mem_size_mb), 0) AS mem_size_mb_usage
    FROM vm_static,
         vm_dynamic
    WHERE quota_id = v_quota_id
        AND vm_dynamic.vm_guid = vm_static.vm_guid
        AND vm_dynamic.status NOT IN (
            SELECT getNonCountableQutoaVmStatuses()
        )
        AND (
            v_cluster_id = vm_static.cluster_id
            OR v_cluster_id IS NULL
        );
END;$$;


ALTER FUNCTION public.calculateclusterusage(v_quota_id uuid, v_cluster_id uuid) OWNER TO engine;

--
-- Name: calculatestorageusage(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.calculatestorageusage(v_quota_id uuid, v_storage_id uuid) RETURNS double precision
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_retVal double precision;
BEGIN
  SELECT COALESCE(sum(CASE active WHEN TRUE THEN size ELSE actual_size END) / (1024 * 1024 * 1024),0)
  INTO v_retVal
  FROM images_storage_domain_view
  WHERE quota_id = v_quota_id
    AND (v_storage_id IS NULL
        OR v_storage_id = storage_id);
  RETURN v_retVal;
END; $$;


ALTER FUNCTION public.calculatestorageusage(v_quota_id uuid, v_storage_id uuid) OWNER TO engine;

--
-- Name: checkdbconnection(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkdbconnection() RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT 1;
    END;$$;


ALTER FUNCTION public.checkdbconnection() OWNER TO engine;

--
-- Name: checkifexistshostthatmissesnetworkincluster(uuid, character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifexistshostthatmissesnetworkincluster(v_cluster_id uuid, v_network_name character varying, v_host_status integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM vds_static
            JOIN vds_dynamic ON vds_static.vds_id = vds_dynamic.vds_id
        WHERE vds_static.cluster_id = v_cluster_id
        AND vds_dynamic.status  = v_host_status
        AND NOT EXISTS(SELECT 1
                       FROM vds_interface
                       WHERE vds_static.vds_id = vds_interface.vds_id
                       AND vds_interface.network_name = v_network_name)
    );
END;$$;


ALTER FUNCTION public.checkifexistshostthatmissesnetworkincluster(v_cluster_id uuid, v_network_name character varying, v_host_status integer) OWNER TO engine;

--
-- Name: checkifexistshostwithstatusincluster(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifexistshostwithstatusincluster(v_cluster_id uuid, v_host_status integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM vds_static
        JOIN vds_dynamic ON vds_static.vds_id = vds_dynamic.vds_id
        WHERE vds_static.cluster_id = v_cluster_id
        AND vds_dynamic.status = v_host_status
    );
END;$$;


ALTER FUNCTION public.checkifexistshostwithstatusincluster(v_cluster_id uuid, v_host_status integer) OWNER TO engine;

--
-- Name: checkifjobhastasks(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifjobhastasks(v_job_id uuid) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT *
            FROM step
            WHERE job_id = v_job_id
                AND external_id IS NOT NULL
                AND external_system_type IN (
                    'VDSM',
                    'GLUSTER'
                    )
            );
END;$$;


ALTER FUNCTION public.checkifjobhastasks(v_job_id uuid) OWNER TO engine;

--
-- Name: checkifsnapshotexistsbyvmidandsnapshotid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifsnapshotexistsbyvmidandsnapshotid(v_vm_id uuid, v_snapshot_id uuid) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT *
            FROM snapshots
            WHERE vm_id = v_vm_id
                AND snapshot_id = v_snapshot_id
            );
END;$$;


ALTER FUNCTION public.checkifsnapshotexistsbyvmidandsnapshotid(v_vm_id uuid, v_snapshot_id uuid) OWNER TO engine;

--
-- Name: checkifsnapshotexistsbyvmidandstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifsnapshotexistsbyvmidandstatus(v_vm_id uuid, v_status character varying) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT *
            FROM snapshots
            WHERE vm_id = v_vm_id
                AND status = v_status
            );
END;$$;


ALTER FUNCTION public.checkifsnapshotexistsbyvmidandstatus(v_vm_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: checkifsnapshotexistsbyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkifsnapshotexistsbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT *
            FROM snapshots
            WHERE vm_id = v_vm_id
                AND snapshot_type = v_snapshot_type
            );
END;$$;


ALTER FUNCTION public.checkifsnapshotexistsbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) OWNER TO engine;

--
-- Name: checkvmhostdeviceavailability(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.checkvmhostdeviceavailability(v_vm_id uuid, v_host_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN NOT EXISTS (
            SELECT 1
            FROM vm_device
            WHERE vm_id = v_vm_id
                AND device IN (
                    SELECT device_name
                    FROM host_device
                    WHERE host_id = v_host_id
                        AND vm_id IS NOT NULL
                        AND vm_id <> v_vm_id
                    )
            );-- device free or already belonging to the vm
END;$$;


ALTER FUNCTION public.checkvmhostdeviceavailability(v_vm_id uuid, v_host_id uuid) OWNER TO engine;

--
-- Name: cleandownvms(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.cleandownvms() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE host_device
    SET vm_id = NULL
    FROM vm_dynamic
    WHERE host_device.vm_id = vm_dynamic.vm_guid
        AND vm_dynamic.status = 0;
END;$$;


ALTER FUNCTION public.cleandownvms() OWNER TO engine;

--
-- Name: clear_network_from_nics(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clear_network_from_nics(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_interface
    SET network_name = NULL
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.clear_network_from_nics(v_id uuid) OWNER TO engine;

--
-- Name: clear_osinfo(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clear_osinfo() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    TRUNCATE dwh_osinfo;
END;$$;


ALTER FUNCTION public.clear_osinfo() OWNER TO engine;

--
-- Name: clearallauditlogevents(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearallauditlogevents(v_severity integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

    UPDATE audit_log
    SET deleted = true
    FROM ( SELECT * FROM audit_log
           WHERE severity != v_severity
               AND NOT deleted
           FOR UPDATE) AS s
    WHERE audit_log.audit_log_id = s.audit_log_id;

END;$$;


ALTER FUNCTION public.clearallauditlogevents(v_severity integer) OWNER TO engine;

--
-- Name: clearallclusterupgraderunning(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearallclusterupgraderunning() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster
    SET upgrade_running = false,
        upgrade_percent_complete = 0
    WHERE upgrade_running = true;
END;$$;


ALTER FUNCTION public.clearallclusterupgraderunning() OWNER TO engine;

--
-- Name: clearalldeviceaddressesbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearalldeviceaddressesbyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE vm_device
    SET address = ''
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.clearalldeviceaddressesbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: clearclusterupgraderunning(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearclusterupgraderunning(v_cluster_id uuid, OUT v_updated boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster
    SET upgrade_running = false,
        upgrade_percent_complete = 0
    WHERE cluster_id = v_cluster_id;

    v_updated := FOUND;
END;$$;


ALTER FUNCTION public.clearclusterupgraderunning(v_cluster_id uuid, OUT v_updated boolean) OWNER TO engine;

--
-- Name: clearmigratingtovds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearmigratingtovds(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET migrating_to_vds = NULL
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.clearmigratingtovds(v_vm_guid uuid) OWNER TO engine;

--
-- Name: clearmigratingtovdsandsetdynamicpinning(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearmigratingtovdsandsetdynamicpinning(v_vm_guid uuid, v_current_cpu_pinning character varying, v_current_numa_pinning character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET migrating_to_vds = NULL,
        current_cpu_pinning = v_current_cpu_pinning,
        current_numa_pinning = v_current_numa_pinning
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.clearmigratingtovdsandsetdynamicpinning(v_vm_guid uuid, v_current_cpu_pinning character varying, v_current_numa_pinning character varying) OWNER TO engine;

--
-- Name: clearvmdeviceaddress(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.clearvmdeviceaddress(v_device_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE vm_device
    SET address = ''
    WHERE device_id = v_device_id;
END;$$;


ALTER FUNCTION public.clearvmdeviceaddress(v_device_id uuid) OWNER TO engine;

--
-- Name: copynvramdata(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.copynvramdata(v_source_vm_id uuid, v_target_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_nvram_data (
        vm_id,
        nvram_data,
        nvram_hash
    )
    SELECT v_target_vm_id, nvram_data, nvram_hash
    FROM vm_nvram_data
    WHERE vm_id = v_source_vm_id;
END;$$;


ALTER FUNCTION public.copynvramdata(v_source_vm_id uuid, v_target_vm_id uuid) OWNER TO engine;

--
-- Name: copytpmdata(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.copytpmdata(v_source_vm_id uuid, v_target_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_device_id UUID := (SELECT device_id
                         FROM vm_device
                         WHERE vm_id = v_target_vm_id AND type = 'tpm');
BEGIN
    IF v_device_id IS NOT NULL THEN
        INSERT INTO vm_external_data (
            device_id,
            vm_id,
            tpm_data,
            tpm_hash
        )
        SELECT v_device_id, v_target_vm_id, tpm_data, tpm_hash
        FROM vm_external_data
        WHERE vm_id = v_source_vm_id;
    END IF;
END;$$;


ALTER FUNCTION public.copytpmdata(v_source_vm_id uuid, v_target_vm_id uuid) OWNER TO engine;

--
-- Name: createlabel(uuid, character varying, boolean, boolean, uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.createlabel(v_label_id uuid, v_label_name character varying, v_readonly boolean, v_has_implicit_affinity_group boolean, v_vms uuid[], v_hosts uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
   o uuid;
BEGIN
    INSERT INTO labels (
        label_id,
        label_name,
        read_only,
        has_implicit_affinity_group
        )
    VALUES (
        v_label_id,
        v_label_name,
        v_readonly,
        v_has_implicit_affinity_group
        );

    -- Insert VM references
    FOREACH o IN ARRAY v_vms
    LOOP
        INSERT INTO labels_map (
            label_id,
            vm_id
            )
        VALUES (
            v_label_id,
            o
            );
    END LOOP;

    -- Insert host references
    FOREACH o IN ARRAY v_hosts
    LOOP
        INSERT INTO labels_map (
            label_id,
            vds_id
            )
        VALUES (
            v_label_id,
            o
            );
    END LOOP;
END;$$;


ALTER FUNCTION public.createlabel(v_label_id uuid, v_label_name character varying, v_readonly boolean, v_has_implicit_affinity_group boolean, v_vms uuid[], v_hosts uuid[]) OWNER TO engine;

--
-- Name: delete_entity_snapshot_by_command_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.delete_entity_snapshot_by_command_id(v_command_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM business_entity_snapshot
        WHERE command_id = v_command_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.delete_entity_snapshot_by_command_id(v_command_id uuid) OWNER TO engine;

--
-- Name: delete_roles_groups(integer, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.delete_roles_groups(v_action_group_id integer, v_role_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

    DELETE FROM roles_groups
    WHERE action_group_id = v_action_group_id
        AND role_id = v_role_id;

END; $$;


ALTER FUNCTION public.delete_roles_groups(v_action_group_id integer, v_role_id uuid) OWNER TO engine;

--
-- Name: deleteaffinitygroup(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteaffinitygroup(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM affinity_groups
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteaffinitygroup(v_id uuid) OWNER TO engine;

--
-- Name: deleteaffinityhost(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteaffinityhost(v_affinity_group_id uuid, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM affinity_group_members
    WHERE affinity_group_id = v_affinity_group_id
        AND vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.deleteaffinityhost(v_affinity_group_id uuid, v_vds_id uuid) OWNER TO engine;

--
-- Name: deleteaffinityhostlabel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteaffinityhostlabel(v_affinity_group_id uuid, v_host_label_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM affinity_group_members
    WHERE affinity_group_id = v_affinity_group_id
        AND host_label_id = v_host_label_id;
END;$$;


ALTER FUNCTION public.deleteaffinityhostlabel(v_affinity_group_id uuid, v_host_label_id uuid) OWNER TO engine;

--
-- Name: deleteaffinityvm(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteaffinityvm(v_affinity_group_id uuid, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM affinity_group_members
    WHERE affinity_group_id = v_affinity_group_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.deleteaffinityvm(v_affinity_group_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: deleteaffinityvmlabel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteaffinityvmlabel(v_affinity_group_id uuid, v_vm_label_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM affinity_group_members
    WHERE affinity_group_id = v_affinity_group_id
        AND vm_label_id = v_vm_label_id;
END;$$;


ALTER FUNCTION public.deleteaffinityvmlabel(v_affinity_group_id uuid, v_vm_label_id uuid) OWNER TO engine;

--
-- Name: deleteallcheckpointsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallcheckpointsbyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_checkpoints
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.deleteallcheckpointsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: deleteallfromenginesessions(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallfromenginesessions() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE deleted_rows INT;

BEGIN
    DELETE
    FROM engine_sessions;

    GET DIAGNOSTICS deleted_rows = ROW_COUNT;

    RETURN deleted_rows;
END;$$;


ALTER FUNCTION public.deleteallfromenginesessions() OWNER TO engine;

--
-- Name: deleteallfromvmicondefaults(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallfromvmicondefaults() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_icon_defaults;
END;$$;


ALTER FUNCTION public.deleteallfromvmicondefaults() OWNER TO engine;

--
-- Name: deleteallglusterhooks(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallglusterhooks(v_cluster_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_hooks
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.deleteallglusterhooks(v_cluster_id uuid) OWNER TO engine;

--
-- Name: deletealltagsvdsmapforhost(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletealltagsvdsmapforhost(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_vds_map
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.deletealltagsvdsmapforhost(v_vds_id uuid) OWNER TO engine;

--
-- Name: deleteallunusedvmicons(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallunusedvmicons() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_icons
    WHERE NOT EXISTS (
            SELECT 1
            FROM vm_icon_defaults
            WHERE vm_icon_defaults.small_icon_id = vm_icons.id
                OR vm_icon_defaults.large_icon_id = vm_icons.id
            )
        AND NOT EXISTS (
            SELECT 1
            FROM vm_static
            WHERE vm_static.small_icon_id = vm_icons.id
                OR vm_static.large_icon_id = vm_icons.id
            );
END;$$;


ALTER FUNCTION public.deleteallunusedvmicons() OWNER TO engine;

--
-- Name: deleteallvfsconfiglabels(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallvfsconfiglabels(v_vfs_config_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vfs_config_labels
    WHERE vfs_config_id = v_vfs_config_id;
END;$$;


ALTER FUNCTION public.deleteallvfsconfiglabels(v_vfs_config_id uuid) OWNER TO engine;

--
-- Name: deleteallvfsconfignetworks(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteallvfsconfignetworks(v_vfs_config_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vfs_config_networks
    WHERE vfs_config_id = v_vfs_config_id;
END;$$;


ALTER FUNCTION public.deleteallvfsconfignetworks(v_vfs_config_id uuid) OWNER TO engine;

--
-- Name: deleteasync_tasks(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteasync_tasks(v_task_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE deleted_rows INT;

BEGIN
    DELETE
    FROM async_tasks
    WHERE task_id = v_task_id;

    GET DIAGNOSTICS deleted_rows = ROW_COUNT;

    RETURN deleted_rows;
END;$$;


ALTER FUNCTION public.deleteasync_tasks(v_task_id uuid) OWNER TO engine;

--
-- Name: deleteasynctasksbyvdsmtaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteasynctasksbyvdsmtaskid(v_vdsm_task_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE deleted_rows INT;

BEGIN
    DELETE
    FROM async_tasks
    WHERE vdsm_task_id = v_vdsm_task_id;

    GET DIAGNOSTICS deleted_rows = ROW_COUNT;

    RETURN deleted_rows;
END;$$;


ALTER FUNCTION public.deleteasynctasksbyvdsmtaskid(v_vdsm_task_id uuid) OWNER TO engine;

--
-- Name: deleteauditalertlogbyvdsidandtype(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteauditalertlogbyvdsidandtype(v_vds_id uuid, v_log_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE audit_log
    SET deleted = true
    WHERE vds_id = v_vds_id
        AND log_type = v_log_type;
END;$$;


ALTER FUNCTION public.deleteauditalertlogbyvdsidandtype(v_vds_id uuid, v_log_type integer) OWNER TO engine;

--
-- Name: deleteauditalertlogbyvolumeidandtype(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteauditalertlogbyvolumeidandtype(v_gluster_volume_id uuid, v_log_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE audit_log
    SET deleted = true
    WHERE gluster_volume_id = v_gluster_volume_id
        AND log_type = v_log_type;
END;$$;


ALTER FUNCTION public.deleteauditalertlogbyvolumeidandtype(v_gluster_volume_id uuid, v_log_type integer) OWNER TO engine;

--
-- Name: deleteauditlog(bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteauditlog(v_audit_log_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE audit_log
    SET deleted = true
    WHERE audit_log_id = v_audit_log_id;
END;$$;


ALTER FUNCTION public.deleteauditlog(v_audit_log_id bigint) OWNER TO engine;

--
-- Name: deleteauditlogalertsbyvdsid(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteauditlogalertsbyvdsid(v_vds_id uuid, v_delete_config_alerts boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_min_alert_severity INT;

v_no_config_alret_type INT;

v_no_max_alret_type INT;

BEGIN
    v_min_alert_severity := 10;

    v_no_config_alret_type := 9000;

    v_no_max_alret_type := 9005;

    IF (v_delete_config_alerts = true) THEN
        UPDATE audit_log
        SET deleted = true
        WHERE vds_id = v_vds_id
            AND severity >= v_min_alert_severity
            AND log_type BETWEEN v_no_config_alret_type
                AND v_no_max_alret_type;
    ELSE
        UPDATE audit_log
        SET deleted = true
        WHERE vds_id = v_vds_id
            AND severity >= v_min_alert_severity
            AND log_type BETWEEN v_no_config_alret_type + 1
                AND v_no_max_alret_type;
END

IF ;END;$$;


ALTER FUNCTION public.deleteauditlogalertsbyvdsid(v_vds_id uuid, v_delete_config_alerts boolean) OWNER TO engine;

--
-- Name: deleteauditlogolderthendate(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteauditlogolderthendate(v_date timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_id BIGINT;

SWV_RowCount INT;

BEGIN
    -- get first the id from which to remove in order to use index
    SELECT audit_log_id
    INTO v_id
    FROM audit_log
    WHERE LOG_TIME < v_date
    ORDER BY audit_log_id DESC LIMIT 1;

    -- check if there are candidates to remove
    GET DIAGNOSTICS SWV_RowCount = ROW_COUNT;

    IF (SWV_RowCount > 0) THEN
        DELETE
        FROM audit_log
        WHERE audit_log_id <= v_id;
    END IF;
END;$$;


ALTER FUNCTION public.deleteauditlogolderthendate(v_date timestamp with time zone) OWNER TO engine;

--
-- Name: deletebackuprelatedalerts(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletebackuprelatedalerts() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE audit_log
    SET deleted = true
    WHERE origin = 'oVirt'
        AND log_type IN (
            9022,
            9023,
            9026
            );-- (ENGINE_NO_FULL_BACKUP, ENGINE_NO_WARM_BACKUP, ENGINE_BACKUP_FAILED)
END;$$;


ALTER FUNCTION public.deletebackuprelatedalerts() OWNER TO engine;

--
-- Name: deletebasedisk(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletebasedisk(v_disk_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM base_disks
    WHERE disk_id = v_disk_id;

    -- Delete the disk's permissions
    PERFORM DeletePermissionsByEntityId(v_disk_id);
END;$$;


ALTER FUNCTION public.deletebasedisk(v_disk_id uuid) OWNER TO engine;

--
-- Name: deletebookmark(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletebookmark(v_bookmark_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM bookmarks
    WHERE bookmark_Id = v_bookmark_id;
END;$$;


ALTER FUNCTION public.deletebookmark(v_bookmark_id uuid) OWNER TO engine;

--
-- Name: deletebypoolvds_spm_id_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletebypoolvds_spm_id_map(v_vds_id uuid, v_storage_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vds_spm_id_map
    WHERE vds_id = v_vds_id
        AND storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.deletebypoolvds_spm_id_map(v_vds_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: deletecinderstorage(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecinderstorage(v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM cinder_storage
    WHERE storage_domain_id = v_storage_domain_id
    FOR UPDATE;

    DELETE
    FROM cinder_storage
    WHERE id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.deletecinderstorage(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: deletecluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecluster(v_cluster_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT cluster_id
    INTO v_val
    FROM cluster
    WHERE cluster_id = v_cluster_id
    FOR UPDATE;

    DELETE
    FROM cluster
    WHERE cluster_id = v_cluster_id;

    -- delete VDS group permissions --
    PERFORM DeletePermissionsByEntityId(v_cluster_id);
END;$$;


ALTER FUNCTION public.deletecluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: deleteclusterpolicy(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteclusterpolicy(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM cluster_policies
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteclusterpolicy(v_id uuid) OWNER TO engine;

--
-- Name: deleteclusterpolicyunitsbyclusterpolicyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteclusterpolicyunitsbyclusterpolicyid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM cluster_policy_units
    WHERE cluster_policy_id = v_id;
END;$$;


ALTER FUNCTION public.deleteclusterpolicyunitsbyclusterpolicyid(v_id uuid) OWNER TO engine;

--
-- Name: deletecommandentitiesolderthandate(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecommandentitiesolderthandate(v_date timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE v_id INT;

SWV_RowCount INT;

BEGIN
    DELETE
    FROM command_entities
    WHERE CREATED_AT < v_date
        AND command_id NOT IN (
            SELECT command_id
            FROM async_tasks
            );
END;$$;


ALTER FUNCTION public.deletecommandentitiesolderthandate(v_date timestamp with time zone) OWNER TO engine;

--
-- Name: deletecommandentity(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecommandentity(v_command_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    BEGIN
        DELETE
        FROM command_entities
        WHERE command_id = v_command_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletecommandentity(v_command_id uuid) OWNER TO engine;

--
-- Name: deletecompletedbackupsolderthandate(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecompletedbackupsolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_backups
    WHERE (
            (
                _update_date < v_succeeded_end_time
                AND phase = 'Succeeded'
                )
            OR (
                _update_date < v_failed_end_time
                AND phase = 'Failed'
                )
            );
END;$$;


ALTER FUNCTION public.deletecompletedbackupsolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: deletecompletedimagetransfersolderthandate(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecompletedimagetransfersolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM image_transfers
    WHERE (
            (
                last_updated < v_succeeded_end_time
                AND phase = 9
                )
            OR (
                last_updated < v_failed_end_time
                AND phase = 10
                )
            );
END;$$;


ALTER FUNCTION public.deletecompletedimagetransfersolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: deletecompletedjobsolderthandate(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecompletedjobsolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM job
    WHERE (
            is_auto_cleared
            AND (
                (
                    end_time < v_succeeded_end_time
                    AND status = 'FINISHED'
                    )
                OR (
                    end_time < v_failed_end_time
                    AND status IN (
                        'FAILED',
                        'ABORTED',
                        'UNKNOWN'
                        )
                    )
                )
            );
END;$$;


ALTER FUNCTION public.deletecompletedjobsolderthandate(v_succeeded_end_time timestamp with time zone, v_failed_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: deletecpuprofile(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecpuprofile(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM cpu_profiles
    WHERE id = v_id;

    -- Delete the cpu profiles permissions
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletecpuprofile(v_id uuid) OWNER TO engine;

--
-- Name: deletecustom_actions(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletecustom_actions(v_action_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM custom_actions
    WHERE action_id = v_action_id;
END;$$;


ALTER FUNCTION public.deletecustom_actions(v_action_id integer) OWNER TO engine;

--
-- Name: deletedisk_image_dynamic(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletedisk_image_dynamic(v_image_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM disk_image_dynamic
    WHERE image_id = v_image_id;
END;$$;


ALTER FUNCTION public.deletedisk_image_dynamic(v_image_id uuid) OWNER TO engine;

--
-- Name: deletedisklunmap(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletedisklunmap(v_disk_id uuid, v_lun_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM disk_lun_map
    WHERE disk_id = v_disk_id
        AND lun_id = v_lun_id;
END;$$;


ALTER FUNCTION public.deletedisklunmap(v_disk_id uuid, v_lun_id character varying) OWNER TO engine;

--
-- Name: deletediskprofile(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletediskprofile(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM disk_profiles
    WHERE id = v_id;

    -- Delete the disk profiles permissions
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletediskprofile(v_id uuid) OWNER TO engine;

--
-- Name: deletediskvmelement(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletediskvmelement(v_disk_id uuid, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM disk_vm_element
    WHERE disk_id = v_disk_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.deletediskvmelement(v_disk_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: deletednsresolverconfiguration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletednsresolverconfiguration(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM dns_resolver_configuration
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletednsresolverconfiguration(v_id uuid) OWNER TO engine;

--
-- Name: deletednsresolverconfigurationbynetworkattachmentid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletednsresolverconfigurationbynetworkattachmentid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM dns_resolver_configuration
    WHERE id = (
      SELECT
        dns_resolver_configuration_id
      FROM
        network_attachments
      WHERE
        id = v_id);
END;$$;


ALTER FUNCTION public.deletednsresolverconfigurationbynetworkattachmentid(v_id uuid) OWNER TO engine;

--
-- Name: deletednsresolverconfigurationbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletednsresolverconfigurationbynetworkid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM dns_resolver_configuration
    WHERE id = (
      SELECT
        dns_resolver_configuration_id
      FROM
        network
      WHERE
        id = v_id);
END;$$;


ALTER FUNCTION public.deletednsresolverconfigurationbynetworkid(v_id uuid) OWNER TO engine;

--
-- Name: deletednsresolverconfigurationbyvdsdynamicid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletednsresolverconfigurationbyvdsdynamicid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM dns_resolver_configuration
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletednsresolverconfigurationbyvdsdynamicid(v_id uuid) OWNER TO engine;

--
-- Name: deleteenginesession(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteenginesession(v_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE deleted_rows INT;

BEGIN
    DELETE
    FROM engine_sessions
    WHERE id = v_id;

    GET DIAGNOSTICS deleted_rows = ROW_COUNT;

    RETURN deleted_rows;
END;$$;


ALTER FUNCTION public.deleteenginesession(v_id integer) OWNER TO engine;

--
-- Name: deleteevent_notification_hist(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteevent_notification_hist(v_sent_at timestamp without time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM event_notification_hist
    WHERE sent_at < v_sent_at;
END;$$;


ALTER FUNCTION public.deleteevent_notification_hist(v_sent_at timestamp without time zone) OWNER TO engine;

--
-- Name: deleteevent_subscriber(character varying, character varying, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteevent_subscriber(v_event_up_name character varying, v_notification_method character varying, v_subscriber_id uuid, v_tag_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (v_tag_name IS NULL) THEN
        DELETE
        FROM event_subscriber
        WHERE event_up_name = v_event_up_name
            AND notification_method = v_notification_method
            AND subscriber_id = v_subscriber_id;
    ELSE
        DELETE
        FROM event_subscriber
        WHERE event_up_name = v_event_up_name
            AND notification_method = v_notification_method
            AND subscriber_id = v_subscriber_id
            AND tag_name = v_tag_name;
    END IF;

END;$$;


ALTER FUNCTION public.deleteevent_subscriber(v_event_up_name character varying, v_notification_method character varying, v_subscriber_id uuid, v_tag_name character varying) OWNER TO engine;

--
-- Name: deleteexternallease(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteexternallease(v_lease_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    SELECT lease_id
    INTO v_val
    FROM external_leases
    WHERE lease_id = v_lease_id
    FOR UPDATE;

    DELETE
    FROM external_leases
    WHERE lease_id = v_lease_id;
END;$$;


ALTER FUNCTION public.deleteexternallease(v_lease_id uuid) OWNER TO engine;

--
-- Name: deleteexternalvariable(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteexternalvariable(v_var_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    DELETE
    FROM external_variable
    WHERE var_name = v_var_name;
END;$$;


ALTER FUNCTION public.deleteexternalvariable(v_var_name character varying) OWNER TO engine;

--
-- Name: deletefenceagent(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletefenceagent(v_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM fence_agents
    WHERE id = v_guid;
END;$$;


ALTER FUNCTION public.deletefenceagent(v_guid uuid) OWNER TO engine;

--
-- Name: deletefenceagentsbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletefenceagentsbyvdsid(v_vds_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM fence_agents
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.deletefenceagentsbyvdsid(v_vds_guid uuid) OWNER TO engine;

--
-- Name: deleteglustergeorepsession(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustergeorepsession(v_session_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_georep_session
    WHERE session_id = v_session_id;
END;$$;


ALTER FUNCTION public.deleteglustergeorepsession(v_session_id uuid) OWNER TO engine;

--
-- Name: deleteglusterhook(uuid, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterhook(v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_hooks
    WHERE cluster_id = v_cluster_id
        AND gluster_command = v_gluster_command
        AND stage = v_stage
        AND name = v_name;
END;$$;


ALTER FUNCTION public.deleteglusterhook(v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying) OWNER TO engine;

--
-- Name: deleteglusterhookbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterhookbyid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_hooks
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteglusterhookbyid(v_id uuid) OWNER TO engine;

--
-- Name: deleteglusterhooksbyids(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterhooksbyids(v_ids text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_hooks
    WHERE id IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );
END;$$;


ALTER FUNCTION public.deleteglusterhooksbyids(v_ids text) OWNER TO engine;

--
-- Name: deleteglusterjob(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterjob(v_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_scheduler_job_details
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.deleteglusterjob(v_job_id uuid) OWNER TO engine;

--
-- Name: deleteglusterjobparams(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterjobparams(v_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_scheduler_job_params
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.deleteglusterjobparams(v_job_id uuid) OWNER TO engine;

--
-- Name: deleteglusterserver(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserver(v_server_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.deleteglusterserver(v_server_id uuid) OWNER TO engine;

--
-- Name: deleteglusterserverbyglusterserveruuid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserverbyglusterserveruuid(v_gluster_server_uuid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server
    WHERE gluster_server_uuid = v_gluster_server_uuid;
END;$$;


ALTER FUNCTION public.deleteglusterserverbyglusterserveruuid(v_gluster_server_uuid uuid) OWNER TO engine;

--
-- Name: deleteglusterserverhook(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserverhook(v_hook_id uuid, v_server_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server_hooks
    WHERE hook_id = v_hook_id
        AND server_id = v_server_id;

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id = v_hook_id;
END;$$;


ALTER FUNCTION public.deleteglusterserverhook(v_hook_id uuid, v_server_id uuid) OWNER TO engine;

--
-- Name: deleteglusterserverhookbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserverhookbyid(v_hook_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server_hooks
    WHERE hook_id = v_hook_id;

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id = v_hook_id;
END;$$;


ALTER FUNCTION public.deleteglusterserverhookbyid(v_hook_id uuid) OWNER TO engine;

--
-- Name: deleteglusterserverhooksbyids(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserverhooksbyids(v_ids text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server_hooks
    WHERE hook_id IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );
END;$$;


ALTER FUNCTION public.deleteglusterserverhooksbyids(v_ids text) OWNER TO engine;

--
-- Name: deleteglusterserverservice(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglusterserverservice(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_server_services
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteglusterserverservice(v_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumeaccessprotocol(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumeaccessprotocol(v_volume_id uuid, v_access_protocol character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_access_protocols
    WHERE volume_id = v_volume_id
        AND access_protocol = v_access_protocol;
END;$$;


ALTER FUNCTION public.deleteglustervolumeaccessprotocol(v_volume_id uuid, v_access_protocol character varying) OWNER TO engine;

--
-- Name: deleteglustervolumebrick(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumebrick(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_bricks
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumebrick(v_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumebricks(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumebricks(v_ids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_bricks
    WHERE id IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );
END;$$;


ALTER FUNCTION public.deleteglustervolumebricks(v_ids character varying) OWNER TO engine;

--
-- Name: deleteglustervolumebyguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumebyguid(v_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volumes
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumebyguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumebyname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumebyname(v_cluster_id uuid, v_vol_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volumes
    WHERE cluster_id = v_cluster_id
        AND vol_name = v_vol_name;
END;$$;


ALTER FUNCTION public.deleteglustervolumebyname(v_cluster_id uuid, v_vol_name character varying) OWNER TO engine;

--
-- Name: deleteglustervolumeoption(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumeoption(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_options
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumeoption(v_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumeoptions(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumeoptions(v_ids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_options
    WHERE id IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );
END;$$;


ALTER FUNCTION public.deleteglustervolumeoptions(v_ids character varying) OWNER TO engine;

--
-- Name: deleteglustervolumesbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesbyclusterid(v_cluster_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volumes
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumesbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumesbyguids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesbyguids(v_volume_ids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volumes
    WHERE id IN (
            SELECT *
            FROM fnSplitterUuid(v_volume_ids)
            );
END;$$;


ALTER FUNCTION public.deleteglustervolumesbyguids(v_volume_ids character varying) OWNER TO engine;

--
-- Name: deleteglustervolumesnapshotbyguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesnapshotbyguid(v_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE ref_volume_id UUID;

BEGIN
    SELECT volume_id
    INTO ref_volume_id
    FROM gluster_volume_snapshots
    WHERE snapshot_id = v_snapshot_id;

    DELETE
    FROM gluster_volume_snapshots
    WHERE snapshot_id = v_snapshot_id;

    PERFORM UpdateSnapshotCountDec(ref_volume_id, 1);
END;$$;


ALTER FUNCTION public.deleteglustervolumesnapshotbyguid(v_snapshot_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumesnapshotbyname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesnapshotbyname(v_volume_id uuid, v_snapshot_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_snapshots
    WHERE volume_id = v_volume_id
        AND snapshot_name = v_snapshot_name;

    PERFORM UpdateSnapshotCountDec(v_volume_id, 1);
END;$$;


ALTER FUNCTION public.deleteglustervolumesnapshotbyname(v_volume_id uuid, v_snapshot_name character varying) OWNER TO engine;

--
-- Name: deleteglustervolumesnapshotsbyvolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesnapshotsbyvolumeid(v_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_snapshots
    WHERE volume_id = v_volume_id;

    UPDATE gluster_volumes
    SET snapshot_count = 0
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumesnapshotsbyvolumeid(v_volume_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumesnapshotschedulebyvolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_snapshot_schedules
    WHERE volume_id = v_volume_id;

    UPDATE gluster_volumes
    SET snapshot_scheduled = false
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.deleteglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid) OWNER TO engine;

--
-- Name: deleteglustervolumessnapshotbyids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumessnapshotbyids(v_snapshot_ids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_volume_id UUID;

v_snapshot_count INT;

v_cur CURSOR
FOR

SELECT volume_id,
    count(volume_id)
FROM gluster_volume_snapshots
WHERE snapshot_id IN (
        SELECT *
        FROM fnSplitterUuid(v_snapshot_ids)
        )
GROUP BY volume_id;

BEGIN
    OPEN v_cur;

    LOOP

    FETCH v_cur
    INTO v_volume_id,
        v_snapshot_count;

    EXIT WHEN NOT FOUND;

    PERFORM UpdateSnapshotCountDec(v_volume_id, v_snapshot_count);
END LOOP;

CLOSE v_cur;

DELETE
FROM gluster_volume_snapshots
WHERE snapshot_id IN (
        SELECT *
        FROM fnSplitterUuid(v_snapshot_ids)
        );
END;$$;


ALTER FUNCTION public.deleteglustervolumessnapshotbyids(v_snapshot_ids character varying) OWNER TO engine;

--
-- Name: deleteglustervolumetransporttype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteglustervolumetransporttype(v_volume_id uuid, v_transport_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM gluster_volume_transport_types
    WHERE volume_id = v_volume_id
        AND transport_type = v_transport_type;
END;$$;


ALTER FUNCTION public.deleteglustervolumetransporttype(v_volume_id uuid, v_transport_type character varying) OWNER TO engine;

--
-- Name: deletegroup(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletegroup(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_user_group_map
    WHERE group_id = v_id;

    DELETE
    FROM ad_groups
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletegroup(v_id uuid) OWNER TO engine;

--
-- Name: deletehostdevice(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletehostdevice(v_host_id uuid, v_device_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    SET CONSTRAINTS ALL DEFERRED;

    DELETE
    FROM host_device
    WHERE host_id = v_host_id
        AND device_name = v_device_name;
END;$$;


ALTER FUNCTION public.deletehostdevice(v_host_id uuid, v_device_name character varying) OWNER TO engine;

--
-- Name: deletehostnicvfsconfig(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletehostnicvfsconfig(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM host_nic_vfs_config
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletehostnicvfsconfig(v_id uuid) OWNER TO engine;

--
-- Name: deleteimage(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteimage(v_image_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM images
    WHERE image_guid = v_image_guid;
END;$$;


ALTER FUNCTION public.deleteimage(v_image_guid uuid) OWNER TO engine;

--
-- Name: deleteimage_storage_domain_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteimage_storage_domain_map(v_image_id uuid, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM image_storage_domain_map
    WHERE image_id = v_image_id
        AND storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.deleteimage_storage_domain_map(v_image_id uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: deleteimage_storage_domain_map_by_image_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteimage_storage_domain_map_by_image_id(v_image_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM image_storage_domain_map
    WHERE image_id = v_image_id;
END;$$;


ALTER FUNCTION public.deleteimage_storage_domain_map_by_image_id(v_image_id uuid) OWNER TO engine;

--
-- Name: deleteimageuploads(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteimageuploads(v_command_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM image_transfers
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.deleteimageuploads(v_command_id uuid) OWNER TO engine;

--
-- Name: deleteiscsibond(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteiscsibond(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM iscsi_bonds
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteiscsibond(v_id uuid) OWNER TO engine;

--
-- Name: deletejob(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletejob(v_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM job
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.deletejob(v_job_id uuid) OWNER TO engine;

--
-- Name: deletejobolderthandatewithstatus(timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletejobolderthandatewithstatus(v_end_time timestamp with time zone, v_status text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM job
    WHERE is_auto_cleared
        AND end_time < v_end_time
        AND status = ANY (string_to_array(v_status, ',')::VARCHAR []);
END;$$;


ALTER FUNCTION public.deletejobolderthandatewithstatus(v_end_time timestamp with time zone, v_status text) OWNER TO engine;

--
-- Name: deletelabel(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletelabel(v_label_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    DELETE
    FROM labels
    WHERE label_id = v_label_id;
END;$$;


ALTER FUNCTION public.deletelabel(v_label_id uuid) OWNER TO engine;

--
-- Name: deletelibvirtsecret(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletelibvirtsecret(v_secret_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM libvirt_secrets
    WHERE secret_id = v_secret_id;
END;$$;


ALTER FUNCTION public.deletelibvirtsecret(v_secret_id uuid) OWNER TO engine;

--
-- Name: deletelun(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletelun(v_lun_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM LUNs
    WHERE LUN_id = v_LUN_id;
END;$$;


ALTER FUNCTION public.deletelun(v_lun_id character varying) OWNER TO engine;

--
-- Name: deletelun_storage_server_connection_map(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletelun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM LUN_storage_server_connection_map
    WHERE LUN_id = v_LUN_id
        AND storage_server_connection = v_storage_server_connection;
END;$$;


ALTER FUNCTION public.deletelun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) OWNER TO engine;

--
-- Name: deletemacpool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletemacpool(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM mac_pools
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletemacpool(v_id uuid) OWNER TO engine;

--
-- Name: deletemacpoolrangesbymacpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletemacpoolrangesbymacpoolid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM mac_pool_ranges
    WHERE mac_pool_id = v_id;
END;$$;


ALTER FUNCTION public.deletemacpoolrangesbymacpoolid(v_id uuid) OWNER TO engine;

--
-- Name: deletenameserversbydnsresolverconfigurationid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenameserversbydnsresolverconfigurationid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM name_server
    WHERE dns_resolver_configuration_id = v_id;
END;$$;


ALTER FUNCTION public.deletenameserversbydnsresolverconfigurationid(v_id uuid) OWNER TO engine;

--
-- Name: deletenetwork(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenetwork(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM network
    WHERE id = v_id
    FOR UPDATE;

    DELETE
    FROM network
    WHERE id = v_id;

    -- Delete the network's permissions
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletenetwork(v_id uuid) OWNER TO engine;

--
-- Name: deletenetwork_cluster(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenetwork_cluster(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM network_cluster
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.deletenetwork_cluster(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: deletenetworkattachment(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenetworkattachment(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM network_attachments
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletenetworkattachment(v_id uuid) OWNER TO engine;

--
-- Name: deletenumanode(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenumanode(v_numa_node_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM numa_node
        WHERE numa_node_id = v_numa_node_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletenumanode(v_numa_node_id uuid) OWNER TO engine;

--
-- Name: deletenumanodebyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenumanodebyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM numa_node
        WHERE vm_id = v_vm_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletenumanodebyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: deletenumanodecpubynumanodeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenumanodecpubynumanodeid(v_numa_node_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM numa_node_cpu_map
        WHERE numa_node_id = v_numa_node_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletenumanodecpubynumanodeid(v_numa_node_id uuid) OWNER TO engine;

--
-- Name: deletenumanodemapbyvmnumanodeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenumanodemapbyvmnumanodeid(v_vm_numa_node_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM vm_vds_numa_node_map
        WHERE vm_numa_node_id = v_vm_numa_node_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletenumanodemapbyvmnumanodeid(v_vm_numa_node_id uuid) OWNER TO engine;

--
-- Name: deletenvramdata(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletenvramdata(v_vm_id uuid) RETURNS void
    LANGUAGE sql
    AS $$
    DELETE FROM vm_nvram_data
    WHERE vm_id = v_vm_id
$$;


ALTER FUNCTION public.deletenvramdata(v_vm_id uuid) OWNER TO engine;

--
-- Name: deleteovfgenerations(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteovfgenerations(v_vms_ids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_ovf_generations
    WHERE vm_guid IN (
            SELECT *
            FROM fnSplitterUuid(v_vms_ids)
            )
        -- needed here to ensure that vm with the same id hasn't been added by import vm/template command
        AND vm_guid NOT IN (
            SELECT vm_guid
            FROM vm_static
            );
END;$$;


ALTER FUNCTION public.deleteovfgenerations(v_vms_ids character varying) OWNER TO engine;

--
-- Name: deletepermission(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletepermission(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM permissions
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM permissions
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletepermission(v_id uuid) OWNER TO engine;

--
-- Name: deletepermissionsbyentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletepermissionsbyentityid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
   DELETE FROM permissions
   WHERE object_id = v_id;
END; $$;


ALTER FUNCTION public.deletepermissionsbyentityid(v_id uuid) OWNER TO engine;

--
-- Name: deletepermissionsbyentityids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletepermissionsbyentityids(v_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
   DELETE FROM permissions
   WHERE object_id = ANY(v_ids);
END; $$;


ALTER FUNCTION public.deletepermissionsbyentityids(v_ids uuid[]) OWNER TO engine;

--
-- Name: deletepolicyunit(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletepolicyunit(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM policy_units
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletepolicyunit(v_id uuid) OWNER TO engine;

--
-- Name: deleteprovider(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteprovider(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM providers
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteprovider(v_id uuid) OWNER TO engine;

--
-- Name: deleteqos(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteqos(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM qos
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleteqos(v_id uuid) OWNER TO engine;

--
-- Name: deletequotabyquotaguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletequotabyquotaguid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM quota
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletequotabyquotaguid(v_id uuid) OWNER TO engine;

--
-- Name: deletequotalimitationbyquotaguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletequotalimitationbyquotaguid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM quota_limitation
    WHERE quota_id = v_id;
END;$$;


ALTER FUNCTION public.deletequotalimitationbyquotaguid(v_id uuid) OWNER TO engine;

--
-- Name: deleterepo_domain_file_list(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleterepo_domain_file_list(v_storage_domain_id uuid, v_file_type integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM repo_file_meta_data
    WHERE repo_domain_id = v_storage_domain_id
        AND (
            v_file_type IS NULL
            OR file_type = v_file_type
            );

    RETURN;
END;$$;


ALTER FUNCTION public.deleterepo_domain_file_list(v_storage_domain_id uuid, v_file_type integer) OWNER TO engine;

--
-- Name: deleterole(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleterole(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM roles
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM roles
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deleterole(v_id uuid) OWNER TO engine;

--
-- Name: deleterunningjobsoftasklesscommands(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleterunningjobsoftasklesscommands() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM job
    WHERE (
            status = 'STARTED'
            AND action_type IN (
                'MigrateVm',
                'MigrateVmToServer',
                'RunVm',
                'RunVmOnce'
                )
            )
        AND job_id NOT IN (
            SELECT job_id
            FROM step
            WHERE step_id IN (
                    SELECT step_id
                    FROM async_tasks
                    )
            );

    DELETE
    FROM job
    WHERE job_id IN (
            SELECT job_id
            FROM step
            WHERE (
                    status = 'STARTED'
                    AND step_type = 'MIGRATE_VM'
                    )
            );
END;$$;


ALTER FUNCTION public.deleterunningjobsoftasklesscommands() OWNER TO engine;

--
-- Name: deletesnapshot(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletesnapshot(v_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM snapshots
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.deletesnapshot(v_snapshot_id uuid) OWNER TO engine;

--
-- Name: deletestep(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestep(v_step_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM step
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.deletestep(v_step_id uuid) OWNER TO engine;

--
-- Name: deletestepsubjectentity(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestepsubjectentity(v_step_id uuid, v_entity_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM step_subject_entity sse
    WHERE sse.step_id = v_step_id
    AND sse.entity_id = v_entity_id;
END;$$;


ALTER FUNCTION public.deletestepsubjectentity(v_step_id uuid, v_entity_id uuid) OWNER TO engine;

--
-- Name: deletestorage_domain_dynamic(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorage_domain_dynamic(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_domain_dynamic
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletestorage_domain_dynamic(v_id uuid) OWNER TO engine;

--
-- Name: deletestorage_domain_static(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorage_domain_static(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM storage_domain_static
    WHERE id = v_id
    FOR UPDATE;

    DELETE
    FROM storage_domain_static
    WHERE id = v_id;

    -- delete Storage permissions --
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletestorage_domain_static(v_id uuid) OWNER TO engine;

--
-- Name: deletestorage_pool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorage_pool(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    SELECT vm_guid
    INTO v_val
    FROM vm_static
    WHERE vm_guid IN (
            SELECT vm_guid
            FROM vms
            WHERE storage_pool_id = v_id
            )
    FOR

    UPDATE;

    DELETE
    FROM snapshots
    WHERE vm_id IN (
            SELECT vm_guid
            FROM vms
            WHERE storage_pool_id = v_id
            );

    DELETE
    FROM vm_static
    WHERE vm_guid IN (
            SELECT vm_guid
            FROM vms
            WHERE storage_pool_id = v_id
            );

    -- Delete vm pools as empty pools are not supported
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    SELECT vm_pool_id
    INTO v_val
    FROM vm_pools
    WHERE vm_pool_id IN (
            SELECT vm_pool_id
            FROM vm_pools_view
            WHERE storage_pool_id = v_id
            )
    FOR

    UPDATE;

    DELETE
    FROM vm_pools
    WHERE vm_pool_id IN (
            SELECT vm_pool_id
            FROM vm_pools_view
            WHERE storage_pool_id = v_id
            );

    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM storage_pool
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM storage_pool
    WHERE id = v_id;

    -- delete StoragePool permissions --
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletestorage_pool(v_id uuid) OWNER TO engine;

--
-- Name: deletestorage_pool_iso_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorage_pool_iso_map(v_storage_id uuid, v_storage_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_pool_iso_map
    WHERE storage_id = v_storage_id
        AND storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.deletestorage_pool_iso_map(v_storage_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: deletestorage_server_connections(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorage_server_connections(v_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val VARCHAR(50);

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM storage_server_connections
    WHERE id = v_id
    FOR UPDATE;

    DELETE
    FROM storage_server_connections
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletestorage_server_connections(v_id character varying) OWNER TO engine;

--
-- Name: deletestoragedevicebyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestoragedevicebyid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_device
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletestoragedevicebyid(v_id uuid) OWNER TO engine;

--
-- Name: deletestoragedomaindr(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_domain_dr
    WHERE storage_domain_id = v_storage_domain_id
    AND georep_session_id = v_georep_session_id;
END;$$;


ALTER FUNCTION public.deletestoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid) OWNER TO engine;

--
-- Name: deletestoragedomainovfinfo(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestoragedomainovfinfo(v_ovf_disk_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_domains_ovf_info
    WHERE ovf_disk_id = v_ovf_disk_id;
END;$$;


ALTER FUNCTION public.deletestoragedomainovfinfo(v_ovf_disk_id uuid) OWNER TO engine;

--
-- Name: deletestorageserverconnectionextension(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletestorageserverconnectionextension(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM storage_server_connection_extension
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletestorageserverconnectionextension(v_id uuid) OWNER TO engine;

--
-- Name: deletesupportedclusterfeature(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletesupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM supported_cluster_features
    WHERE cluster_id = v_cluster_id
        AND feature_id = v_feature_id;
END;$$;


ALTER FUNCTION public.deletesupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid) OWNER TO engine;

--
-- Name: deletetags(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags(v_tag_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT tag_id
    INTO v_val
    FROM tags
    WHERE tag_id = v_tag_id
    FOR

    UPDATE;

    DELETE
    FROM tags_user_group_map
    WHERE tag_id = v_tag_id;

    DELETE
    FROM tags_user_map
    WHERE tag_id = v_tag_id;

    DELETE
    FROM tags_vm_map
    WHERE tag_id = v_tag_id;

    DELETE
    FROM tags_vds_map
    WHERE tag_id = v_tag_id;

    DELETE
    FROM tags_vm_pool_map
    WHERE tag_id = v_tag_id;

    DELETE
    FROM tags
    WHERE tag_id = v_tag_id;
END;$$;


ALTER FUNCTION public.deletetags(v_tag_id uuid) OWNER TO engine;

--
-- Name: deletetags_user_group_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags_user_group_map(v_group_id uuid, v_tag_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_user_group_map
    WHERE group_id = v_group_id
        AND tag_id = v_tag_id;
END;$$;


ALTER FUNCTION public.deletetags_user_group_map(v_group_id uuid, v_tag_id uuid) OWNER TO engine;

--
-- Name: deletetags_user_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags_user_map(v_tag_id uuid, v_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_user_map
    WHERE tag_id = v_tag_id
        AND user_id = v_user_id;
END;$$;


ALTER FUNCTION public.deletetags_user_map(v_tag_id uuid, v_user_id uuid) OWNER TO engine;

--
-- Name: deletetags_vds_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags_vds_map(v_tag_id uuid, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_vds_map
    WHERE tag_id = v_tag_id
        AND vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.deletetags_vds_map(v_tag_id uuid, v_vds_id uuid) OWNER TO engine;

--
-- Name: deletetags_vm_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags_vm_map(v_tag_id uuid, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_vm_map
    WHERE tag_id = v_tag_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.deletetags_vm_map(v_tag_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: deletetags_vm_pool_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetags_vm_pool_map(v_tag_id uuid, v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_vm_pool_map
    WHERE tag_id = v_tag_id
        AND vm_pool_id = v_vm_pool_id;
END;$$;


ALTER FUNCTION public.deletetags_vm_pool_map(v_tag_id uuid, v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: deletetpmdata(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletetpmdata(v_vm_id uuid) RETURNS void
    LANGUAGE sql
    AS $$
    DELETE FROM vm_external_data
    WHERE vm_id = v_vm_id
$$;


ALTER FUNCTION public.deletetpmdata(v_vm_id uuid) OWNER TO engine;

--
-- Name: deleteuser(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteuser(v_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_val UUID;

    BEGIN
        -- Get (and keep) a shared lock with "right to upgrade to exclusive"
        -- in order to force locking parent before children
        SELECT user_id
        INTO v_val
        FROM users
        WHERE user_id = v_user_id
        FOR

        UPDATE;

        DELETE
        FROM tags_user_map
        WHERE user_id = v_user_id;

        DELETE
        FROM users
        WHERE user_id = v_user_id;
    END;$$;


ALTER FUNCTION public.deleteuser(v_user_id uuid) OWNER TO engine;

--
-- Name: deleteuserprofileproperty(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deleteuserprofileproperty(v_property_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM user_profiles
    WHERE property_id = v_property_id;
END;$$;


ALTER FUNCTION public.deleteuserprofileproperty(v_property_id uuid) OWNER TO engine;

--
-- Name: deletevdcoption(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevdcoption(v_option_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vdc_options
    WHERE option_id = v_option_id;
END;$$;


ALTER FUNCTION public.deletevdcoption(v_option_id integer) OWNER TO engine;

--
-- Name: deletevds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevds(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM tags_vds_map
        WHERE vds_id = v_vds_id;

        -- Delete all Vds Alerts from the database
        PERFORM DeleteAuditLogAlertsByVdsID(v_vds_id);

        DELETE
        FROM vds_statistics
        WHERE vds_id = v_vds_id;

        DELETE
        FROM vds_dynamic
        WHERE vds_id = v_vds_id;

        DELETE
        FROM vds_static
        WHERE vds_id = v_vds_id;

        PERFORM DeletePermissionsByEntityId(v_vds_id);
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletevds(v_vds_id uuid) OWNER TO engine;

--
-- Name: deletevds_interface(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevds_interface(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vds_interface
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevds_interface(v_id uuid) OWNER TO engine;

--
-- Name: deletevds_interface_statistics(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevds_interface_statistics(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM vds_interface_statistics
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM vds_interface_statistics
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevds_interface_statistics(v_id uuid) OWNER TO engine;

--
-- Name: deletevds_spm_id_map(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevds_spm_id_map(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vds_spm_id_map
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.deletevds_spm_id_map(v_vds_id uuid) OWNER TO engine;

--
-- Name: deletevdsdynamic(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevdsdynamic(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM vds_dynamic
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletevdsdynamic(v_vds_id uuid) OWNER TO engine;

--
-- Name: deletevdsstatic(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevdsstatic(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM tags_vds_map
        WHERE vds_id = v_vds_id;

        -- Delete all Vds Alerts from the database
        PERFORM DeleteAuditLogAlertsByVdsID(v_vds_id);

        DELETE
        FROM vds_static
        WHERE vds_id = v_vds_id;

        -- delete VDS permissions --
        PERFORM DeletePermissionsByEntityId(v_vds_id);
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletevdsstatic(v_vds_id uuid) OWNER TO engine;

--
-- Name: deletevdsstatistics(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevdsstatistics(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        DELETE
        FROM vds_statistics
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.deletevdsstatistics(v_vds_id uuid) OWNER TO engine;

--
-- Name: deletevfsconfiglabel(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevfsconfiglabel(v_vfs_config_id uuid, v_label text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vfs_config_labels
    WHERE vfs_config_id = v_vfs_config_id
        AND label = v_label;
END;$$;


ALTER FUNCTION public.deletevfsconfiglabel(v_vfs_config_id uuid, v_label text) OWNER TO engine;

--
-- Name: deletevfsconfignetwork(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevfsconfignetwork(v_vfs_config_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vfs_config_networks
    WHERE vfs_config_id = v_vfs_config_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.deletevfsconfignetwork(v_vfs_config_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: deletevm(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevm(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
   DECLARE
   v_vmt_guid  UUID;
BEGIN
      SELECT vm_static.vmt_guid INTO v_vmt_guid FROM vm_static WHERE vm_guid = v_vm_guid;
      UPDATE vm_static
      SET child_count =(SELECT COUNT(*) FROM vm_static WHERE vmt_guid = v_vmt_guid) -1
      WHERE vm_guid = v_vmt_guid;
      DELETE FROM tags_vm_map
      WHERE vm_id = v_vm_guid;
      DELETE
      FROM   snapshots
      WHERE  vm_id = v_vm_guid;
      DELETE FROM vm_statistics WHERE vm_guid = v_vm_guid;
      DELETE FROM vm_dynamic WHERE vm_guid = v_vm_guid;
      DELETE FROM vm_static WHERE vm_guid = v_vm_guid;
      PERFORM DeletePermissionsByEntityId(v_vm_guid);
END; $$;


ALTER FUNCTION public.deletevm(v_vm_guid uuid) OWNER TO engine;

--
-- Name: deletevm_interface_statistics(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevm_interface_statistics(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM vm_interface_statistics
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM vm_interface_statistics
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevm_interface_statistics(v_id uuid) OWNER TO engine;

--
-- Name: deletevm_pool_map(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevm_pool_map(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val VARCHAR(50);

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT vm_guid
    INTO v_val
    FROM vm_pool_map
    WHERE vm_guid = v_vm_guid
    FOR UPDATE;

    DELETE
    FROM vm_pool_map
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.deletevm_pool_map(v_vm_guid uuid) OWNER TO engine;

--
-- Name: deletevm_pools(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevm_pools(v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT vm_pool_id
    INTO v_val
    FROM vm_pools
    WHERE vm_pool_id = v_vm_pool_id
    FOR

    UPDATE;

    DELETE
    FROM vm_pools
    WHERE vm_pool_id = v_vm_pool_id;

    -- delete VmPool permissions --
    PERFORM DeletePermissionsByEntityId(v_vm_pool_id);
END;$$;


ALTER FUNCTION public.deletevm_pools(v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: deletevmbackup(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmbackup(v_backup_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_backups
    WHERE backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.deletevmbackup(v_backup_id uuid) OWNER TO engine;

--
-- Name: deletevmcheckpoint(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmcheckpoint(v_checkpoint_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_checkpoints
    WHERE checkpoint_id = v_checkpoint_id;
END;$$;


ALTER FUNCTION public.deletevmcheckpoint(v_checkpoint_id uuid) OWNER TO engine;

--
-- Name: deletevmdevice(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmdevice(v_device_id uuid, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_device
    WHERE device_id = v_device_id
        AND (
            v_vm_id IS NULL
            OR vm_id = v_vm_id
            );
END;$$;


ALTER FUNCTION public.deletevmdevice(v_device_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: deletevmdevicesbyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmdevicesbyvmidandtype(v_vm_id uuid, v_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_device
    WHERE vm_id = v_vm_id
        AND type = v_type;
END;$$;


ALTER FUNCTION public.deletevmdevicesbyvmidandtype(v_vm_id uuid, v_type character varying) OWNER TO engine;

--
-- Name: deletevmdynamic(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmdynamic(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_dynamic
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.deletevmdynamic(v_vm_guid uuid) OWNER TO engine;

--
-- Name: deletevmguestagentinterfacesbyvmids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmguestagentinterfacesbyvmids(v_vm_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_guest_agent_interfaces
    WHERE vm_id = ANY(v_vm_ids);
END;$$;


ALTER FUNCTION public.deletevmguestagentinterfacesbyvmids(v_vm_ids uuid[]) OWNER TO engine;

--
-- Name: deletevmicon(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmicon(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_icons
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevmicon(v_id uuid) OWNER TO engine;

--
-- Name: deletevmicondefault(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmicondefault(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_icon_defaults
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevmicondefault(v_id uuid) OWNER TO engine;

--
-- Name: deletevmiconifunused(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmiconifunused(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_icons
    WHERE id = v_id
        AND NOT EXISTS (
            SELECT 1
            FROM vm_icon_defaults
            WHERE vm_icon_defaults.small_icon_id = vm_icons.id
                OR vm_icon_defaults.large_icon_id = vm_icons.id
            )
        AND NOT EXISTS (
            SELECT 1
            FROM vm_static
            WHERE vm_static.small_icon_id = vm_icons.id
                OR vm_static.large_icon_id = vm_icons.id
            );
END;$$;


ALTER FUNCTION public.deletevmiconifunused(v_id uuid) OWNER TO engine;

--
-- Name: deletevminit(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevminit(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_init
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.deletevminit(v_vm_id uuid) OWNER TO engine;

--
-- Name: deletevminterface(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevminterface(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    -- Get (and keep) a shared lock with "right to upgrade to exclusive"
    -- in order to force locking parent before children
    SELECT id
    INTO v_val
    FROM vm_interface
    WHERE id = v_id
    FOR

    UPDATE;

    DELETE
    FROM vm_interface
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevminterface(v_id uuid) OWNER TO engine;

--
-- Name: deletevminterfacefilterparameter(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevminterfacefilterparameter(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM vm_interface_filter_parameters
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.deletevminterfacefilterparameter(v_id uuid) OWNER TO engine;

--
-- Name: deletevmjobs(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmjobs(v_vm_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_jobs
    WHERE vm_job_id = v_vm_job_id;
END;$$;


ALTER FUNCTION public.deletevmjobs(v_vm_job_id uuid) OWNER TO engine;

--
-- Name: deletevmstatic(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmstatic(v_vm_guid uuid, v_remove_permissions boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
   DECLARE
   v_val  UUID;
   v_vmt_guid  UUID;
BEGIN
      -- store vmt_guid for setting the child_count
      SELECT   vm_static.vmt_guid INTO v_vmt_guid FROM vm_static WHERE vm_guid = v_vm_guid;

			-- Get (and keep) a shared lock with "right to upgrade to exclusive"
            -- in order to force locking parent before children
      select   vm_guid INTO v_val FROM vm_static  WHERE vm_guid = v_vm_guid     FOR UPDATE;
      DELETE FROM vm_static
      WHERE vm_guid = v_vm_guid
      AND   entity_type = 'VM';

			-- delete VM permissions --
      if v_remove_permissions then
        PERFORM DeletePermissionsByEntityId(v_vm_guid);
      end if;

      -- set the child_count for the template
      UPDATE vm_static
          SET child_count = child_count - 1 WHERE vm_guid = v_vmt_guid;
END; $$;


ALTER FUNCTION public.deletevmstatic(v_vm_guid uuid, v_remove_permissions boolean) OWNER TO engine;

--
-- Name: deletevmstatistics(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmstatistics(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_statistics
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.deletevmstatistics(v_vm_guid uuid) OWNER TO engine;

--
-- Name: deletevmtemplates(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevmtemplates(v_vmt_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
   DECLARE
   v_val  UUID;
BEGIN
        -- Get (and keep) a shared lock with "right to upgrade to exclusive"
        -- in order to force locking parent before children
      SELECT vm_guid INTO v_val
      FROM vm_static
      WHERE vm_guid = v_vmt_guid
      FOR UPDATE;

      DELETE FROM vm_static
      WHERE vm_guid = v_vmt_guid;
      -- delete Template permissions --
      PERFORM DeletePermissionsByEntityId(v_vmt_guid);
END; $$;


ALTER FUNCTION public.deletevmtemplates(v_vmt_guid uuid) OWNER TO engine;

--
-- Name: deletevnicprofile(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.deletevnicprofile(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_val UUID;

BEGIN
    DELETE
    FROM vnic_profiles
    WHERE id = v_id;

    -- Delete the vnic profiles permissions
    PERFORM DeletePermissionsByEntityId(v_id);
END;$$;


ALTER FUNCTION public.deletevnicprofile(v_id uuid) OWNER TO engine;

--
-- Name: displayallauditlogevents(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.displayallauditlogevents(v_severity integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

    UPDATE audit_log
    SET deleted = false
    FROM ( SELECT * FROM audit_log
           WHERE severity != v_severity
               AND deleted
           FOR UPDATE) AS s
    WHERE audit_log.audit_log_id = s.audit_log_id;

END;$$;


ALTER FUNCTION public.displayallauditlogevents(v_severity integer) OWNER TO engine;

--
-- Name: existsvmdevicebyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.existsvmdevicebyvmidandtype(v_vm_id uuid, v_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN EXISTS (
            SELECT 1
            FROM vm_device
            WHERE vm_id = v_vm_id
                AND type = v_type
            );
END;$$;


ALTER FUNCTION public.existsvmdevicebyvmidandtype(v_vm_id uuid, v_type character varying) OWNER TO engine;

--
-- Name: fn_authz_entry_info(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_authz_entry_info(v_ad_element_id uuid) RETURNS public.authzentryinfotype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    result authzEntryInfoType;
BEGIN
    IF (v_ad_element_id = getGlobalIds('everyone')) THEN
        SELECT 'Everyone',
            '*',
            ''
        INTO result;
    ELSE
        SELECT (COALESCE(name, '') || ' ' || COALESCE(surname, '') || ' (' || COALESCE(username, '') || ')'),
            namespace,
            domain
        INTO result
        FROM users
        WHERE user_id = v_ad_element_id;

        IF (result IS NULL) THEN
            SELECT name,
                   namespace,
                   domain
            INTO result
            FROM ad_groups
            WHERE ID = v_ad_element_id;
        END IF ;
    END IF;
    RETURN result;
END;$$;


ALTER FUNCTION public.fn_authz_entry_info(v_ad_element_id uuid) OWNER TO engine;

--
-- Name: fn_db_add_action_group_to_role(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_add_action_group_to_role(v_role_id uuid, v_action_group_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$

    BEGIN
        INSERT INTO roles_groups (
            role_id,
            action_group_id
            )
        SELECT v_role_id,
            v_action_group_id
        WHERE NOT EXISTS (
                SELECT 1
                FROM roles_groups
                WHERE role_id = v_role_id
                    AND action_group_id = v_action_group_id
                );

        RETURN;
    END;$$;


ALTER FUNCTION public.fn_db_add_action_group_to_role(v_role_id uuid, v_action_group_id integer) OWNER TO engine;

--
-- Name: fn_db_add_column(character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_add_column(v_table character varying, v_column character varying, v_column_def text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
        v_sql := 'ALTER TABLE ' || v_table || ' ADD COLUMN IF NOT EXISTS ' || v_column || ' ' || v_column_def;
        EXECUTE v_sql;

END;$$;


ALTER FUNCTION public.fn_db_add_column(v_table character varying, v_column character varying, v_column_def text) OWNER TO engine;

--
-- Name: fn_db_add_column_to_object_white_list(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_add_column_to_object_white_list(v_object_name character varying, v_column_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            NOT EXISTS (
                SELECT 1
                FROM object_column_white_list
                WHERE object_name = v_object_name
                    AND column_name = v_column_name
                )
            ) THEN
    BEGIN
        -- verify that there is such object in db
        IF EXISTS (
                SELECT 1
                FROM information_schema.columns
                WHERE table_schema = 'public'
                    AND table_name = v_object_name
                    AND column_name = v_column_name
                ) THEN
            INSERT INTO object_column_white_list (
                object_name,
                column_name
                )
            VALUES (
                v_object_name,
                v_column_name
                );
        END IF;

    END;
    END IF;
END;$$;


ALTER FUNCTION public.fn_db_add_column_to_object_white_list(v_object_name character varying, v_column_name character varying) OWNER TO engine;

--
-- Name: fn_db_add_config_value(character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_add_config_value(v_option_name character varying, v_option_value text, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            NOT EXISTS (
                SELECT 1
                FROM vdc_options
                WHERE option_name ilike v_option_name
                    AND version = v_version
                )
            ) THEN
        BEGIN
            INSERT INTO vdc_options (
                option_name,
                option_value,
                version,
                default_value
                )
            VALUES (
                v_option_name,
                v_option_value,
                v_version,
                v_option_value
                );
        END;
    ELSE
        BEGIN
            -- We need to set default value to not have it empty after upgrade from previous versions
            UPDATE vdc_options SET
                default_value = v_option_value
            WHERE option_name ilike v_option_name
                AND version = v_version
                AND default_value IS NULL;
            END;
    END IF;

END;$$;


ALTER FUNCTION public.fn_db_add_config_value(v_option_name character varying, v_option_value text, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_add_config_value_for_versions_up_to(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_add_config_value_for_versions_up_to(v_option_name character varying, v_val character varying, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE i INT;

arr VARCHAR [] := fn_db_get_versions();

BEGIN
    FOR i IN array_lower(arr, 1)..array_upper(arr, 1) LOOP PERFORM fn_db_add_config_value(v_option_name, v_val, arr [i]);
        EXIT WHEN arr [i] = v_version;
    END LOOP;

END;$$;


ALTER FUNCTION public.fn_db_add_config_value_for_versions_up_to(v_option_name character varying, v_val character varying, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_change_column_null(character varying, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_change_column_null(v_table character varying, v_column character varying, v_allow_null boolean, v_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
    IF (v_allow_null) THEN
        v_sql := 'ALTER TABLE ' || v_table || ' ALTER COLUMN ' || v_column || ' DROP NOT NULL';
        EXECUTE v_sql;
    ELSE
        -- Get the column type
        IF v_type =  'bool' THEN
            v_sql := ' = false';
        ELSIF v_type = 'char' THEN
            v_sql := ' = '''' ';
        ELSIF v_type = 'varchar' THEN
            v_sql := ' = '''' ';
        ELSIF v_type = 'text' THEN
            v_sql :=  ' = '''' ';
        ELSIF v_type = 'int' THEN
            v_sql :=  ' = 0  ';
        ELSIF v_type = 'float' THEN
            v_sql :=  ' = 0.0 ';
        ELSIF v_type = 'numeric' THEN
            v_sql := ' = 0 ';
        ELSIF v_type = 'uuid' THEN
            v_sql := ' = ''00000000-0000-0000-0000-000000000000'' ';
        ELSE
            RAISE EXCEPTION  'fn_db_change_column_null(%,%,%,%) unrecognized type', v_table, v_column, v_allow_null, v_type;
        END IF;
        -- Insure that there are no NULL values in the table column before setting it to NOT NULL
        v_sql := 'update ' || v_table || ' set ' || v_column || v_sql || ' where '  || v_column || ' IS NULL';
        EXECUTE v_sql;
        v_sql := 'ALTER TABLE ' || v_table || ' ALTER COLUMN ' || v_column || ' SET NOT NULL';
        EXECUTE v_sql;

    END IF;

END;$$;


ALTER FUNCTION public.fn_db_change_column_null(v_table character varying, v_column character varying, v_allow_null boolean, v_type character varying) OWNER TO engine;

--
-- Name: fn_db_change_column_type(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_change_column_type(v_table character varying, v_column character varying, v_type character varying, v_new_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
    v_sql := 'ALTER TABLE ' || v_table || ' ALTER COLUMN ' || v_column || ' TYPE ' || v_new_type;
    EXECUTE v_sql;

END;$$;


ALTER FUNCTION public.fn_db_change_column_type(v_table character varying, v_column character varying, v_type character varying, v_new_type character varying) OWNER TO engine;

--
-- Name: fn_db_change_table_string_columns_to_empty_string(character varying, character varying[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_change_table_string_columns_to_empty_string(v_table character varying, v_column character varying[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_sql TEXT;
    v_num integer := array_length(v_column, 1);
    v_index integer := 1;

BEGIN
    WHILE v_index <= v_num
    LOOP
        IF (
            EXISTS (
                SELECT 1
                FROM information_schema.columns
                WHERE table_schema = 'public'
                    AND table_name ilike v_table
                    AND column_name ilike v_column[v_index]
               )
            ) THEN
            BEGIN
                v_sql := 'UPDATE ' || v_table || ' SET ' || v_column[v_index] || ' = '''' WHERE ' || v_column[v_index] || ' IS NULL' ;
                EXECUTE v_sql;
                v_sql := 'ALTER TABLE ' || v_table || ' ALTER COLUMN ' || v_column[v_index] || ' SET DEFAULT ''''';
                EXECUTE v_sql;
            END;
        ELSE
            RAISE EXCEPTION 'No column named % exists in table %', v_column[v_index] , v_table;
        END IF;
    v_index = v_index + 1;
    END LOOP;
END;$$;


ALTER FUNCTION public.fn_db_change_table_string_columns_to_empty_string(v_table character varying, v_column character varying[]) OWNER TO engine;

--
-- Name: fn_db_create_constraint(character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_create_constraint(v_table character varying, v_constraint character varying, v_constraint_sql text) RETURNS void
    LANGUAGE plpgsql
    AS $$

    BEGIN
        IF NOT EXISTS (
                SELECT 1
                FROM pg_constraint
                WHERE conname ilike v_constraint
                ) THEN
            EXECUTE 'ALTER TABLE ' || v_table || ' ADD CONSTRAINT ' || v_constraint || ' ' || v_constraint_sql;
        END IF;

    END;$$;


ALTER FUNCTION public.fn_db_create_constraint(v_table character varying, v_constraint character varying, v_constraint_sql text) OWNER TO engine;

--
-- Name: fn_db_create_index(character varying, character varying, text, text, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_create_index(v_index_name character varying, v_table_name character varying, v_column_names text, v_where_predicate text, v_unique boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_sql TEXT;
            unique_modifier varchar(6);

    BEGIN
        unique_modifier = CASE WHEN v_unique THEN 'UNIQUE'
        ELSE ''
        END;

        v_sql := 'DROP INDEX ' || ' IF EXISTS ' || v_index_name || '; CREATE ' || unique_modifier || ' INDEX ' || v_index_name || ' ON ' || v_table_name || '(' || v_column_names || ')';

        IF v_where_predicate = '' THEN v_sql := v_sql || ';';ELSE
            v_sql := v_sql || ' WHERE ' || v_where_predicate || ';';
        END IF;

    EXECUTE v_sql;
END;$$;


ALTER FUNCTION public.fn_db_create_index(v_index_name character varying, v_table_name character varying, v_column_names text, v_where_predicate text, v_unique boolean) OWNER TO engine;

--
-- Name: fn_db_delete_config_for_version(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_delete_config_for_version(v_version text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vdc_options
    WHERE version IN (
            SELECT ID
            FROM fnSplitter(v_version)
            );
END;$$;


ALTER FUNCTION public.fn_db_delete_config_for_version(v_version text) OWNER TO engine;

--
-- Name: fn_db_delete_config_value(character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_delete_config_value(v_option_name character varying, v_version text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            EXISTS (
                SELECT 1
                FROM vdc_options
                WHERE option_name ilike v_option_name
                    AND version IN (
                        SELECT ID
                        FROM fnSplitter(v_version)
                        )
                )
            ) THEN
        BEGIN
            DELETE
            FROM vdc_options
            WHERE option_name ilike v_option_name
                AND version IN (
                    SELECT ID
                    FROM fnSplitter(v_version)
                    );
        END;
    END IF;

END;$$;


ALTER FUNCTION public.fn_db_delete_config_value(v_option_name character varying, v_version text) OWNER TO engine;

--
-- Name: fn_db_delete_config_value_all_versions(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_delete_config_value_all_versions(v_option_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            EXISTS (
                SELECT 1
                FROM vdc_options
                WHERE option_name ilike v_option_name
                )
            ) THEN
        BEGIN
            DELETE
            FROM vdc_options
            WHERE option_name ilike v_option_name;
        END;
    END IF;

END;$$;


ALTER FUNCTION public.fn_db_delete_config_value_all_versions(v_option_name character varying) OWNER TO engine;

--
-- Name: fn_db_drop_column(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_drop_column(v_table character varying, v_column character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
        v_sql := 'ALTER TABLE ' || v_table || ' DROP COLUMN IF EXISTS ' || v_column;
        EXECUTE v_sql;

END;$$;


ALTER FUNCTION public.fn_db_drop_column(v_table character varying, v_column character varying) OWNER TO engine;

--
-- Name: fn_db_drop_constraint(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_drop_constraint(v_table character varying, v_constraint character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    BEGIN
            EXECUTE 'ALTER TABLE ' || v_table || ' DROP CONSTRAINT IF EXISTS ' || v_constraint || ' CASCADE';

    END;$$;


ALTER FUNCTION public.fn_db_drop_constraint(v_table character varying, v_constraint character varying) OWNER TO engine;

--
-- Name: fn_db_drop_index(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_drop_index(v_index_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_sql TEXT;

    BEGIN
        v_sql := 'DROP INDEX ' || ' IF EXISTS ' || v_index_name || ';' ;
        EXECUTE v_sql;
END;$$;


ALTER FUNCTION public.fn_db_drop_index(v_index_name character varying) OWNER TO engine;

--
-- Name: fn_db_get_async_tasks(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_get_async_tasks() RETURNS SETOF public.async_tasks_info_rs
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_record async_tasks_info_rs;

-- selects storage_pool_id uuid found in async_tasks
v_tasks_cursor CURSOR
FOR

SELECT DISTINCT storage_pool_id
FROM async_tasks;

BEGIN
    OPEN v_tasks_cursor;

    FETCH v_tasks_cursor
    INTO v_record.dc_id;

    WHILE FOUND
    LOOP
        -- get dc_name and SPM Host id
        v_record.dc_name := name FROM storage_pool WHERE id = v_record.dc_id;
        v_record.spm_host_id := spm_vds_id
        FROM storage_pool
        WHERE id = v_record.dc_id;

        -- get Host name if we have non NULL SPM Host
        IF (v_record.spm_host_id IS NOT NULL) THEN
            v_record.spm_host_name := vds_name
            FROM vds_static
            WHERE vds_id = v_record.spm_host_id;
        ELSE
            v_record.spm_host_name:= '';
        END IF;
        -- get tasks count for this DC
        v_record.task_count := count(*)
        FROM async_tasks
        WHERE position(cast(v_record.dc_id AS VARCHAR) IN action_parameters) > 0;

        -- return the record
        RETURN NEXT v_record;

        FETCH v_tasks_cursor
    INTO v_record.dc_id;

    END LOOP;

CLOSE v_tasks_cursor;

-- return full set of generated records
RETURN;
END;$$;


ALTER FUNCTION public.fn_db_get_async_tasks() OWNER TO engine;

--
-- Name: fn_db_get_versions(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_get_versions() RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$

BEGIN

RETURN
ARRAY ['4.2', '4.3', '4.4', '4.5', '4.6', '4.7'];

END;$$;


ALTER FUNCTION public.fn_db_get_versions() OWNER TO engine;

--
-- Name: fn_db_grant_action_group_to_all_roles_filter(integer, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_grant_action_group_to_all_roles_filter(v_action_group_id integer, uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $_$

DECLARE v_role_id_to_filter alias
FOR $2;

BEGIN
    INSERT INTO roles_groups (
        role_id,
        action_group_id
        )
    SELECT DISTINCT role_id,
        v_action_group_id
    FROM roles_groups rg
    WHERE NOT ARRAY [role_id] <@ v_role_id_to_filter
        AND NOT EXISTS (
            SELECT 1
            FROM roles_groups
            WHERE role_id = rg.role_id
                AND action_group_id = v_action_group_id
            );
END;$_$;


ALTER FUNCTION public.fn_db_grant_action_group_to_all_roles_filter(v_action_group_id integer, uuid[]) OWNER TO engine;

--
-- Name: fn_db_is_table_exists(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_is_table_exists(v_table character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

    DECLARE retvalue boolean;

    BEGIN
        retvalue := EXISTS (
                SELECT *
                FROM information_schema.tables
                WHERE table_schema = 'public'
                    AND table_name ILIKE v_table
                );

        RETURN retvalue;
    END;$$;


ALTER FUNCTION public.fn_db_is_table_exists(v_table character varying) OWNER TO engine;

--
-- Name: fn_db_mask_object(regclass); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_mask_object(v_object regclass) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE v_sql TEXT;

v_table record;

v_table_name TEXT;

temprec record;

BEGIN
    -- get full table/view name from v_object (i.e <namespace>.<name>)
    SELECT c.relname,
        n.nspname
    INTO v_table
    FROM pg_class c
    INNER JOIN pg_namespace n
        ON c.relnamespace = n.oid
    WHERE c.oid = v_object;

    -- try to get filtered query syntax from previous execution
    IF EXISTS (
            SELECT 1
            FROM object_column_white_list_sql
            WHERE object_name = v_table.relname
            ) THEN
        SELECT sql
        INTO v_sql
        FROM object_column_white_list_sql
        WHERE object_name = v_table.relname;
    ELSE
        v_table_name := quote_ident(v_table.nspname) || '.' || quote_ident(v_table.relname);
        -- compose sql statement while skipping values for columns not defined in object_column_white_list for this table.
    FOR temprec IN
    SELECT a.attname,
        t.typname
    FROM pg_attribute a
    INNER JOIN pg_type t
        ON a.atttypid = t.oid
    WHERE a.attrelid = v_object
        AND a.attnum > 0
        AND NOT a.attisdropped
    ORDER BY a.attnum LOOP v_sql := coalesce(v_sql || ', ', 'SELECT ');

        IF EXISTS (
            SELECT 1
            FROM object_column_white_list
            WHERE object_name = v_table.relname
                AND column_name = temprec.attname
            ) THEN v_sql := v_sql || quote_ident(temprec.attname);
        ELSE
            v_sql := v_sql || 'NULL::' || quote_ident(temprec.typname) || ' as ' || quote_ident(temprec.attname);
        END IF;

    END LOOP;

    v_sql := v_sql || ' FROM ' || v_table_name;

    v_sql := 'SELECT x::' || v_table_name || ' as rec FROM (' || v_sql || ') as x';

    -- save generated query for further use
    INSERT INTO object_column_white_list_sql (
        object_name,
        sql
        )
    VALUES (
        v_table.relname,
        v_sql
        );
    END IF;

    RETURN QUERY

    EXECUTE v_sql;
END;$$;


ALTER FUNCTION public.fn_db_mask_object(v_object regclass) OWNER TO engine;

--
-- Name: fn_db_remove_csv_config_value(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_remove_csv_config_value(v_option_name character varying, v_value character varying, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v VARCHAR [];

e VARCHAR;

v_result VARCHAR;

v_sep VARCHAR(1);

BEGIN
    v_result := '';

    v_sep := '';

    v := string_to_array(option_value, ',')
    FROM vdc_options
    WHERE option_name = v_option_name
        AND version = v_version;
    FOR

    e IN

    SELECT unnest(v) LOOP

    IF (e != v_value) THEN v_result := v_result || v_sep || e;
        v_sep := ',';
    END IF;

END
LOOP;

    UPDATE vdc_options
    SET option_value = v_result
    WHERE option_name = v_option_name
        AND version = v_version;
END;$$;


ALTER FUNCTION public.fn_db_remove_csv_config_value(v_option_name character varying, v_value character varying, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_remove_uuid_from_csv(text, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_remove_uuid_from_csv(v_csv_text text, v_uuid uuid) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v uuid [];

e uuid;

v_result TEXT;

v_sep VARCHAR(1);

BEGIN
    v_result := '';

    v_sep := '';

    v := string_to_array(v_csv_text, ',');
    FOR

    e IN

    SELECT unnest(v) LOOP

    IF (e != v_uuid) THEN v_result := v_result || v_sep || e;
        v_sep := ',';
    END IF;

    END LOOP;

    IF (v_result = '') THEN v_result := NULL;
    END IF;
    RETURN v_result;
END;$$;


ALTER FUNCTION public.fn_db_remove_uuid_from_csv(v_csv_text text, v_uuid uuid) OWNER TO engine;

--
-- Name: fn_db_rename_column(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_rename_column(v_table character varying, v_column character varying, v_new_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
    v_sql := 'ALTER TABLE ' || v_table || ' RENAME COLUMN ' || v_column || ' TO ' || v_new_name;
    EXECUTE v_sql;
END;$$;


ALTER FUNCTION public.fn_db_rename_column(v_table character varying, v_column character varying, v_new_name character varying) OWNER TO engine;

--
-- Name: fn_db_rename_config_key(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_rename_config_key(v_old_option_name character varying, v_new_option_name character varying, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_current_option_value TEXT;

    BEGIN
        IF (
                EXISTS (
                    SELECT 1
                    FROM vdc_options
                    WHERE option_name ilike v_old_option_name
                        AND version = v_version
                    )
                ) THEN
            v_current_option_value:= option_value
            FROM vdc_options
            WHERE option_name ilike v_old_option_name
                AND version = v_version;

            UPDATE vdc_options
            SET option_name = v_new_option_name,
                option_value = v_current_option_value
                WHERE option_name ilike v_old_option_name
                    AND version = v_version;
        END IF;

    END;$$;


ALTER FUNCTION public.fn_db_rename_config_key(v_old_option_name character varying, v_new_option_name character varying, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_rename_table(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_rename_table(v_table character varying, v_new_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_sql TEXT;

BEGIN
        v_sql := 'ALTER TABLE ' || v_table || ' RENAME TO ' || v_new_name;
        EXECUTE v_sql;
END;$$;


ALTER FUNCTION public.fn_db_rename_table(v_table character varying, v_new_name character varying) OWNER TO engine;

--
-- Name: fn_db_split_config_value(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_split_config_value(v_option_name character varying, v_old_option_value character varying, v_new_option_value character varying, v_update_from_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_old_value VARCHAR(4000);

    v_cur CURSOR
    FOR

    SELECT DISTINCT version
    FROM vdc_options
    WHERE version <> 'general'
    ORDER BY version;

    v_version VARCHAR(40);

    v_index INT;

    v_count INT;

    v_total_count INT;

    v_version_count INT;

    BEGIN
        v_total_count := count(version)
        FROM vdc_options
        WHERE option_name = v_option_name;

        v_old_value := option_value
        FROM vdc_options
        WHERE option_name = v_option_name
            AND version = 'general';

        v_version_count := count(DISTINCT version)
        FROM vdc_options
        WHERE version <> 'general';

        IF (v_total_count <= v_version_count) THEN
        BEGIN
            IF (v_old_value IS NULL) THEN
                v_old_value := v_old_option_value;
        END IF;
        v_count := count(DISTINCT version)
        FROM vdc_options
        WHERE version <> 'general';

        v_index := 1;

        OPEN v_cur;

        LOOP

            FETCH v_cur
            INTO v_version;

            EXIT when NOT found;

            -- We shouldn't update if already exists
            IF (
                    NOT EXISTS (
                        SELECT 1
                        FROM vdc_options
                        WHERE option_name = v_option_name
                            AND version = v_version
                        )
                    ) THEN
                -- Might not work well for versions such as 3.10, but we currently don't have any
                IF (v_version >= v_update_from_version) THEN
                    INSERT INTO vdc_options (
                        option_name,
                        option_value,
                        version,
                        default_value
                        )
                    VALUES (
                        v_option_name,
                        v_new_option_value,
                        v_version,
                        v_new_option_value
                        );
                ELSE
                    INSERT INTO vdc_options (
                        option_name,
                        option_value,
                        version,
                        default_value
                        )
                    VALUES (
                        v_option_name,
                        v_old_value,
                        v_version,
                        v_old_value
                        );
                END IF;

            END IF;
            v_index := v_index + 1;
        END LOOP;

    CLOSE v_cur;

    DELETE
    FROM vdc_options
    WHERE option_name = v_option_name
        AND version = 'general';
    END;
END IF;

END;$$;


ALTER FUNCTION public.fn_db_split_config_value(v_option_name character varying, v_old_option_value character varying, v_new_option_value character varying, v_update_from_version character varying) OWNER TO engine;

--
-- Name: fn_db_unlock_all(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_unlock_all() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE DOWN INT;

OK INT;

LOCKED INT;

TEMPLATE_OK INT;

TEMPLATE_LOCKED INT;

IMAGE_LOCKED INT;

SNAPSHOT_OK VARCHAR;

SNAPSHOT_LOCKED VARCHAR;

BEGIN
    DOWN:= 0;

    OK:= 1;

    LOCKED:= 2;

    TEMPLATE_OK:= 0;

    TEMPLATE_LOCKED:= 1;

    IMAGE_LOCKED:= 15;

    SNAPSHOT_OK:= 'OK';

    SNAPSHOT_LOCKED:= 'LOCKED';

    UPDATE vm_static
    SET template_status = TEMPLATE_OK
    WHERE template_status = TEMPLATE_LOCKED;

    UPDATE vm_dynamic
    SET status = DOWN
    WHERE status = IMAGE_LOCKED;

    UPDATE images
    SET imagestatus = OK
    WHERE imagestatus = LOCKED;

    UPDATE snapshots
    SET status = SNAPSHOT_OK
    WHERE status ilike SNAPSHOT_LOCKED;
END;$$;


ALTER FUNCTION public.fn_db_unlock_all() OWNER TO engine;

--
-- Name: fn_db_unlock_disk(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_unlock_disk(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE OK INT;

LOCKED INT;

BEGIN
    OK:= 1;

    LOCKED:= 2;

    UPDATE images
    SET imagestatus = OK
    WHERE imagestatus = LOCKED
        AND image_group_id = v_id;
END;$$;


ALTER FUNCTION public.fn_db_unlock_disk(v_id uuid) OWNER TO engine;

--
-- Name: fn_db_unlock_entity(character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_unlock_entity(v_object_type character varying, v_name character varying, v_recursive boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE DOWN INT;

OK INT;

LOCKED INT;

TEMPLATE_OK INT;

TEMPLATE_LOCKED INT;

IMAGE_LOCKED INT;

SNAPSHOT_OK VARCHAR;

SNAPSHOT_LOCKED VARCHAR;

v_id UUID;

BEGIN
    DOWN:= 0;

    OK:= 1;

    LOCKED:= 2;

    TEMPLATE_OK:= 0;

    TEMPLATE_LOCKED:= 1;

    IMAGE_LOCKED:= 15;

    SNAPSHOT_OK:= 'OK';

    SNAPSHOT_LOCKED:= 'LOCKED';

    v_id := vm_guid
    FROM vm_static
    WHERE vm_name = v_name
        AND entity_type ilike v_object_type;

    -- set VM status to DOWN
    IF (v_object_type = 'vm') THEN
        UPDATE vm_dynamic
        SET status = DOWN
        WHERE status = IMAGE_LOCKED
            AND vm_guid = v_id;
            -- set Template status to OK
    ELSE IF (v_object_type = 'template') THEN
        UPDATE vm_static
        SET template_status = TEMPLATE_OK
        WHERE template_status = TEMPLATE_LOCKED
            AND vm_guid = v_id;
    END IF;

END IF;
 --unlock images and snapshots  if recursive flag is set
IF (v_recursive) THEN
    UPDATE images
    SET imagestatus = OK
    WHERE imagestatus = LOCKED
        AND image_group_id IN (
            SELECT device_id
            FROM vm_device
            WHERE vm_id = v_id
                AND is_plugged
            );

    UPDATE snapshots
    SET status = SNAPSHOT_OK
    WHERE status ilike SNAPSHOT_LOCKED
        AND vm_id = v_id;
END IF;

END;$$;


ALTER FUNCTION public.fn_db_unlock_entity(v_object_type character varying, v_name character varying, v_recursive boolean) OWNER TO engine;

--
-- Name: fn_db_unlock_snapshot(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_unlock_snapshot(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE OK VARCHAR;

LOCKED VARCHAR;

BEGIN
    OK:= 'OK';

    LOCKED:= 'LOCKED';

    UPDATE snapshots
    SET status = OK
    WHERE status = LOCKED
        AND snapshot_id = v_id;
END;$$;


ALTER FUNCTION public.fn_db_unlock_snapshot(v_id uuid) OWNER TO engine;

--
-- Name: fn_db_update_column_to_jsonb_compatible_values(character varying, character varying, jsonb); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_update_column_to_jsonb_compatible_values(v_table character varying, v_column character varying, v_default_value jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    default_value_string VARCHAR;
BEGIN
    IF (
        EXISTS (
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = 'public'
                AND table_name = v_table
                AND column_name = v_column
                AND (data_type = 'character varying' OR data_type = 'text')
        )
    ) THEN
        BEGIN
            default_value_string := CASE
                WHEN v_default_value IS NULL THEN 'NULL'
                ELSE '''' || v_default_value::VARCHAR || ''''
            END;
            EXECUTE 'UPDATE ' || v_table || ' SET ' || v_column || ' = (SELECT fn_db_varchar_to_jsonb(' || v_column || ', ' || default_value_string || '))';
        END;
    END IF;
END;$$;


ALTER FUNCTION public.fn_db_update_column_to_jsonb_compatible_values(v_table character varying, v_column character varying, v_default_value jsonb) OWNER TO engine;

--
-- Name: fn_db_update_config_value(character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_update_config_value(v_option_name character varying, v_option_value text, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            EXISTS (
                SELECT 1
                FROM vdc_options
                WHERE option_name ilike v_option_name
                    AND version = v_version
                )
            ) THEN
        BEGIN
            UPDATE vdc_options
            SET option_value = v_option_value,
                default_value = v_option_value
            WHERE option_name ilike v_option_name
                AND version = v_version;
        END;
    END IF;

END;$$;


ALTER FUNCTION public.fn_db_update_config_value(v_option_name character varying, v_option_value text, v_version character varying) OWNER TO engine;

--
-- Name: fn_db_update_config_value_for_versions_from_up_to(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_update_config_value_for_versions_from_up_to(v_option_name character varying, v_val character varying, v_from_version character varying, v_to_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE i INT;

arr VARCHAR [] := fn_db_get_versions();

BEGIN
    found := false;
    FOR i IN array_lower(arr, 1)..array_upper(arr, 1) LOOP
	IF  arr [i] != v_from_version THEN
	    IF NOT found THEN
	        CONTINUE;
	    END IF;
        END IF;
	found := true;
	PERFORM fn_db_update_config_value(v_option_name, v_val, arr [i]);
        EXIT WHEN arr [i] = v_to_version;
    END LOOP;

END;$$;


ALTER FUNCTION public.fn_db_update_config_value_for_versions_from_up_to(v_option_name character varying, v_val character varying, v_from_version character varying, v_to_version character varying) OWNER TO engine;

--
-- Name: fn_db_update_default_config_value(character varying, text, text, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_update_default_config_value(v_option_name character varying, v_default_option_value text, v_option_value text, v_version character varying, v_ignore_default_value_case boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF (
            EXISTS (
                SELECT 1
                FROM vdc_options
                WHERE option_name ilike v_option_name
                    AND version = v_version
                )
            ) THEN
    BEGIN
        IF (v_ignore_default_value_case) THEN
            UPDATE vdc_options
            SET option_value = v_option_value
            WHERE option_name ilike v_option_name
                AND option_value ilike v_default_option_value
                AND version = v_version;
        ELSE
            UPDATE vdc_options
            SET option_value = v_option_value
            WHERE option_name ilike v_option_name
                AND option_value = v_default_option_value
                AND version = v_version;
        END IF;

        -- We need to update default value regardless of user changes
        UPDATE vdc_options
        SET default_value = v_option_value
        WHERE option_name ilike v_option_name
            AND version = v_version;
    END;
    END IF;
END;$$;


ALTER FUNCTION public.fn_db_update_default_config_value(v_option_name character varying, v_default_option_value text, v_option_value text, v_version character varying, v_ignore_default_value_case boolean) OWNER TO engine;

--
-- Name: fn_db_varchar_to_jsonb(character varying, jsonb); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_db_varchar_to_jsonb(v_text character varying, v_default_value jsonb) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN v_text::jsonb;
    EXCEPTION
        WHEN SQLSTATE '22P02' THEN -- '22P02' stands for 'invalid_text_representation', 'invalid input syntax for type json' in this case
            RETURN v_default_value;
END;$$;


ALTER FUNCTION public.fn_db_varchar_to_jsonb(v_text character varying, v_default_value jsonb) OWNER TO engine;

--
-- Name: fn_get_ad_element_name(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_ad_element_name(v_ad_element_id uuid) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    result TEXT;
BEGIN
    IF (v_ad_element_id = getGlobalIds('everyone')) THEN
        result := 'Everyone';
    ELSE
        SELECT (COALESCE(name, '') || ' ' || COALESCE(surname, '') || ' (' || COALESCE(username, '') || '@' || COALESCE(domain, '') || ')')
        INTO result
        FROM users
        WHERE user_id = v_ad_element_id;

        IF (result IS NULL) THEN
            SELECT name
            INTO result
            FROM ad_groups
            WHERE ID = v_ad_element_id;
        END IF ;
   END IF;
   RETURN result;
END;$$;


ALTER FUNCTION public.fn_get_ad_element_name(v_ad_element_id uuid) OWNER TO engine;

--
-- Name: fn_get_column_size(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_column_size(v_table character varying, v_column character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$

    DECLARE retvalue INT;

    BEGIN
        retvalue := character_maximum_length
        FROM information_schema.columns
        WHERE table_schema = 'public'
            AND table_name ilike v_table
            AND column_name ilike v_column
            AND table_schema = 'public'
            AND udt_name IN (
                'char',
                'varchar'
                );

        RETURN retvalue;
    END;$$;


ALTER FUNCTION public.fn_get_column_size(v_table character varying, v_column character varying) OWNER TO engine;

--
-- Name: fn_get_comparable_ip_list(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_comparable_ip_list(text) RETURNS inet[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
    CASE
        WHEN ($1 IS NULL)
        OR ($1 ~ E'^\\s*$')
            THEN RETURN NULL;
        ELSE
            RETURN regexp_split_to_array(trim(both FROM $1), E'\\s+')::inet [];
    END CASE ;
END;$_$;


ALTER FUNCTION public.fn_get_comparable_ip_list(text) OWNER TO engine;

--
-- Name: fn_get_dedicated_hosts_ids_by_vm_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_dedicated_hosts_ids_by_vm_id(v_vm_id uuid) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN array_to_string(array_agg(vds_id), ',')
    FROM vm_host_pinning_map
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.fn_get_dedicated_hosts_ids_by_vm_id(v_vm_id uuid) OWNER TO engine;

--
-- Name: fn_get_entity_name(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_entity_name(v_entity_id uuid, v_object_type integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
            /*    Gets object name by its id and type

    Object Types (compatible with VdcObjectType, XXX entries are unused currently)
        Unknown XXX,
        System XXX,
        VM = 2,
        VDS = 3,
        VmTemplate = 4,
        VmPool = 5,
        AdElements XXX,
        Tags XXX,
        Bookmarks XXX,
        Cluster = 9,
        MultiLevelAdministration XXX,
        Storage = 11,
        EventNotification XXX,
        ImportExport XXX,
        StoragePool = 14,
        User = 15,
        Role = 16,
        Quota = 17,
        GlusterVolume = 18,
        Disk = 19,
        Network = 20,
        VNICProfile = 27,
        MacPool = 28,
        DiskProfile = 29
        CpuProfile = 30
*/
    DECLARE v_entity_type int4 := v_object_type;result TEXT;BEGIN
    CASE
        WHEN v_entity_type = 1
            THEN result := 'System';
        WHEN v_entity_type = 2
        OR v_entity_type = 4
            THEN result := (
                            SELECT vm_name
                            FROM vm_static
                            WHERE vm_guid = v_entity_id
                           );
        WHEN v_entity_type = 3
            THEN result := (
                            SELECT vds_name
                            FROM vds_static
                            WHERE vds_id = v_entity_id
                           );
        WHEN v_entity_type = 5
            THEN result := (
                            SELECT vm_pool_name
                            FROM vm_pools
                            WHERE vm_pool_id = v_entity_id
                           );
        WHEN v_entity_type = 7
            THEN result := (
                            SELECT tag_name
                            FROM tags
                             WHERE tag_id = v_entity_id
                            );
        WHEN v_entity_type = 8
            THEN result := (
                            SELECT bookmark_name
                            FROM bookmarks
                            WHERE bookmark_id = v_entity_id
                           );
        WHEN v_entity_type = 9
            THEN result := (
                            SELECT name
                            FROM cluster
                            WHERE cluster_id = v_entity_id
                           );
        WHEN v_entity_type = 11
             THEN result := (
                             SELECT storage_name
                             FROM storage_domain_static
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 14
             THEN result := (
                             SELECT name
                             FROM storage_pool
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 15
             THEN result := (
                             SELECT username
                             FROM users
                             WHERE user_id = v_entity_id
                            );
        WHEN v_entity_type = 16
             THEN result := (
                             SELECT name
                             FROM roles
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 17
             THEN result := (
                             SELECT quota_name
                             FROM quota
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 18
             THEN result := (
                             SELECT vol_name
                             FROM gluster_volumes
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 19
             THEN result := (
                             SELECT disk_alias
                             FROM base_disks
                             WHERE disk_id = v_entity_id
                            );
        WHEN v_entity_type = 20
             THEN result := (
                             SELECT name
                             FROM network
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 23
             THEN result := (
                             SELECT CONCAT (
                                     gluster_command,
                                     '-',
                                     stage,
                                     '-',
                                     name
                                     )
                             FROM gluster_hooks
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 25
             THEN result := (
                             SELECT service_name
                             FROM gluster_services
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 27
             THEN result := (
                             SELECT name
                             FROM vnic_profiles
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 28
             THEN result := (
                             SELECT name
                             FROM mac_pools
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 29
             THEN result := (
                             SELECT name
                             FROM disk_profiles
                             WHERE id = v_entity_id
                            );
        WHEN v_entity_type = 30
             THEN result := (
                             SELECT name
                             FROM cpu_profiles
                             WHERE id = v_entity_id
                            );
        ELSE result := 'Unknown type ' || v_entity_type;
        END CASE ;
        -- This should be written to an error var or include object_id that is missing
        --    IF result IS NULL THEN
        --        result := v_entity_id || '' NOT FOUND'';
        --    END IF;
        RETURN result;
END;$$;


ALTER FUNCTION public.fn_get_entity_name(v_entity_id uuid, v_object_type integer) OWNER TO engine;

--
-- Name: fn_get_entity_parents(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_entity_parents(v_entity_id uuid, v_object_type integer) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$

/*Gets a list of all parent GUID to the system root (including)

Object Types (compatible with VdcObjectType, XXX entries are unused currently)
Unknown XXX,
System XXX,
       Bottom = 0,
                VM = 2,
                VDS = 3,
                VmTemplate = 4,
                VmPool = 5,
                AdElements XXX,
                Tags XXX,
                Bookmarks XXX,
                Cluster = 9,
                MultiLevelAdministration XXX,
                Storage = 11,
                EventNotification XXX,
                ImportExport XXX,
                StoragePool = 14,
                User = 15,
                Role = 16,
                Quota = 17,
                GlusterVolume = 18,
        Disk = 19,
        Network = 20,
        VNICProfile = 27,
        MacPool = 28
        DiskProfile = 29
        CpuProfile = 30
*/
DECLARE
    v_entity_type int4 := v_object_type;
    system_root_id uuid;
    v_cluster_id uuid;
    ds_id uuid;
    v_image_id uuid;
    v_storage_id uuid;
    v_vm_id uuid;
    v_storage_pool_id uuid;
    v_profile_network_id uuid;
    v_disk_profile_storage_id uuid;
    v_cpu_profile_cluster_id uuid;

BEGIN
    system_root_id := (
        SELECT getGlobalIds('system')
    );-- hardcoded also in MLA Handler
    CASE
        WHEN v_entity_type = 0
            THEN -- Bottom
                RETURN QUERY SELECT object_id FROM permissions;
        WHEN v_entity_type = 2
            THEN -- VM
                -- get cluster id
                v_cluster_id := (
                    SELECT cluster_id
                    FROM vm_static
                    WHERE vm_guid = v_entity_id
                    );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                    );RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 3
            THEN -- VDS
                -- get cluster id
                v_cluster_id := (
                    SELECT cluster_id
                    FROM vds_static
                    WHERE vds_id = v_entity_id
                    );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                    );RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 4
            THEN -- Template
                -- get image id first
                v_image_id := (
                    SELECT image_guid
                    FROM images i
                    INNER JOIN vm_device vd
                        ON i.image_group_id = vd.device_id
                    WHERE vm_id = v_entity_id limit 1
                    );
                -- get the storage id from images
                v_storage_id := (
                    SELECT storage_domain_id
                    FROM image_storage_domain_map
                    WHERE image_id = v_image_id limit 1
                    );
                -- finally get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM storage_pool_iso_map
                    WHERE storage_id = v_storage_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 5
            THEN -- VM Pool
                -- get cluster id
                v_cluster_id := (
                    SELECT cluster_id
                    FROM vm_pools
                    WHERE vm_pool_id = v_entity_id
                    );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 9
            THEN -- Cluster
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_entity_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 11
            THEN -- Storage Domain
                RETURN QUERY SELECT system_root_id AS id

            UNION ALL

                SELECT storage_pool_id AS id
                FROM storage_pool_iso_map
                WHERE storage_id = v_entity_id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 17
            THEN -- Quota
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM quota
                    WHERE id = v_entity_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 18
            THEN -- GlusterVolume
                -- get cluster id
                v_cluster_id := (
                    SELECT v.cluster_id
                    FROM gluster_volumes v
                    WHERE id = v_entity_id
                    );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 19
            THEN -- Disk
                -- get data center, storage domain and vm
                SELECT INTO ds_id,
                v_storage_id,
                v_vm_id storage_pool_id,
                storage_id,
                vm_id
                FROM images_storage_domain_view
                LEFT JOIN vm_device
                ON vm_device.device_id = images_storage_domain_view.disk_id
                WHERE image_group_id = v_entity_id;
                -- get cluster
                v_cluster_id := (
                    SELECT cluster_id
                    FROM vm_static
                    WHERE vm_guid = v_vm_id
                    );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_storage_id AS id

            UNION

                SELECT v_vm_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 20
            THEN -- Network
                SELECT INTO v_storage_pool_id network.storage_pool_id
                FROM network
                WHERE network.id = v_entity_id;
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT v_storage_pool_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 27
            THEN -- VNICProfile
                SELECT INTO v_profile_network_id vnic_profiles.network_id
                FROM vnic_profiles
                WHERE vnic_profiles.id = v_entity_id;

                SELECT INTO v_storage_pool_id network.storage_pool_id
                FROM network
                WHERE network.id = v_profile_network_id;
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT v_storage_pool_id AS id

            UNION

                SELECT v_profile_network_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 29
            THEN -- DiskProfile
                SELECT INTO v_disk_profile_storage_id disk_profiles.storage_domain_id
                FROM disk_profiles
                WHERE disk_profiles.id = v_entity_id;

                SELECT INTO v_storage_pool_id storage_pool_iso_map.storage_pool_id
                FROM storage_pool_iso_map
                WHERE storage_pool_iso_map.storage_id = v_disk_profile_storage_id;
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT v_storage_pool_id AS id

            UNION

                SELECT v_disk_profile_storage_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 30
            THEN -- CpuProfile
                SELECT INTO v_cpu_profile_cluster_id cpu_profiles.cluster_id
                FROM cpu_profiles
                WHERE cpu_profiles.id = v_entity_id;

                SELECT INTO v_storage_pool_id cluster.storage_pool_id
                FROM cluster
                WHERE cluster.cluster_id = v_cpu_profile_cluster_id;
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT v_storage_pool_id AS id

            UNION

                SELECT v_cpu_profile_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 23
            THEN -- Gluster Hook
                -- get cluster id
                v_cluster_id := (
                    SELECT cluster_id
                    FROM gluster_hooks
                    WHERE id = v_entity_id
                );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        WHEN v_entity_type = 25
            THEN -- Gluster Service
                -- get cluster id
                v_cluster_id := (
                    SELECT cluster_id
                    FROM vds_static
                    WHERE vds_id = v_entity_id
                );
                -- get data center id
                ds_id := (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                );
                RETURN QUERY SELECT system_root_id AS id

            UNION

                SELECT ds_id AS id

            UNION

                SELECT v_cluster_id AS id

            UNION

                SELECT v_entity_id AS id;
        ELSE IF
            v_entity_type IN (
                    1,
                    14,
                    15,
                    16,
                    28
                    ) THEN -- Data Center, users, roles and mac pools are under system
            RETURN QUERY SELECT system_root_id AS id

        UNION

            SELECT v_entity_id AS id;
        END IF;

    END CASE ;
END;$$;


ALTER FUNCTION public.fn_get_entity_parents(v_entity_id uuid, v_object_type integer) OWNER TO engine;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: vm_static; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_static (
    vm_guid uuid NOT NULL,
    vm_name character varying(255) NOT NULL,
    mem_size_mb integer NOT NULL,
    vmt_guid uuid NOT NULL,
    os integer DEFAULT 0 NOT NULL,
    description character varying(4000) DEFAULT ''::character varying NOT NULL,
    cluster_id uuid,
    creation_date timestamp with time zone,
    num_of_monitors integer NOT NULL,
    is_initialized boolean,
    is_auto_suspend boolean DEFAULT false,
    num_of_sockets integer DEFAULT 1 NOT NULL,
    cpu_per_socket integer DEFAULT 1 NOT NULL,
    usb_policy integer,
    time_zone character varying(40),
    is_stateless boolean,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    auto_startup boolean,
    vm_type integer DEFAULT 0 NOT NULL,
    nice_level integer DEFAULT 0 NOT NULL,
    default_boot_sequence integer DEFAULT 0 NOT NULL,
    default_display_type integer DEFAULT 0 NOT NULL,
    priority integer DEFAULT 0 NOT NULL,
    iso_path character varying(4000) DEFAULT ''::character varying,
    origin integer DEFAULT 0,
    initrd_url character varying(4000),
    kernel_url character varying(4000),
    kernel_params character varying(4000),
    migration_support integer DEFAULT 0 NOT NULL,
    userdefined_properties character varying(4000),
    predefined_properties character varying(4000),
    min_allocated_mem integer DEFAULT 0 NOT NULL,
    entity_type character varying(32) NOT NULL,
    child_count integer DEFAULT 0,
    template_status integer,
    quota_id uuid,
    allow_console_reconnect boolean DEFAULT false NOT NULL,
    cpu_pinning character varying(4000) DEFAULT NULL::character varying,
    is_smartcard_enabled boolean DEFAULT false,
    host_cpu_flags boolean DEFAULT false,
    db_generation bigint DEFAULT 1,
    is_delete_protected boolean DEFAULT false,
    is_disabled boolean DEFAULT false,
    is_run_and_pause boolean DEFAULT false NOT NULL,
    created_by_user_id uuid,
    tunnel_migration boolean,
    free_text_comment text DEFAULT ''::text NOT NULL,
    cpu_shares integer DEFAULT 0 NOT NULL,
    vnc_keyboard_layout character varying(16) DEFAULT NULL::character varying,
    instance_type_id uuid,
    image_type_id uuid,
    sso_method character varying(32) DEFAULT 'guest_agent'::character varying NOT NULL,
    original_template_id uuid,
    original_template_name character varying(255) DEFAULT NULL::character varying,
    migration_downtime integer,
    template_version_number integer,
    template_version_name character varying(40) DEFAULT NULL::character varying,
    serial_number_policy smallint,
    custom_serial_number character varying(255) DEFAULT NULL::character varying,
    is_boot_menu_enabled boolean DEFAULT false NOT NULL,
    is_spice_file_transfer_enabled boolean DEFAULT true NOT NULL,
    is_spice_copy_paste_enabled boolean DEFAULT true NOT NULL,
    cpu_profile_id uuid,
    is_auto_converge boolean,
    is_migrate_compressed boolean,
    custom_emulated_machine character varying(40),
    custom_cpu_name character varying(255),
    small_icon_id uuid,
    large_icon_id uuid,
    provider_id uuid,
    num_of_io_threads integer DEFAULT 0 NOT NULL,
    console_disconnect_action character varying(64),
    threads_per_cpu integer DEFAULT 1 NOT NULL,
    custom_compatibility_version character varying(40),
    migration_policy_id uuid,
    max_memory_size_mb integer NOT NULL,
    lease_sd_id uuid,
    resume_behavior character varying(64) DEFAULT 'AUTO_RESUME'::character varying,
    multi_queues_enabled boolean DEFAULT true NOT NULL,
    is_migrate_encrypted boolean,
    use_tsc_frequency boolean DEFAULT false,
    namespace character varying(253),
    is_template_sealed boolean DEFAULT false NOT NULL,
    bios_type integer,
    balloon_enabled boolean DEFAULT false NOT NULL,
    virtio_scsi_multi_queues integer DEFAULT 0 NOT NULL,
    console_disconnect_action_delay integer,
    cpu_pinning_policy smallint DEFAULT 0 NOT NULL,
    parallel_migrations smallint,
    CONSTRAINT vm_static_bios_type_not_null_if_cluster_set CHECK (((cluster_id IS NULL) = (bios_type IS NULL))),
    CONSTRAINT vm_static_cpu_pinning_set_for_manual_pinning_policy_only CHECK (((cpu_pinning_policy = 1) = (cpu_pinning IS NOT NULL))),
    CONSTRAINT vm_static_cpu_profile_not_null CHECK (((cluster_id IS NULL) OR (cpu_profile_id IS NOT NULL))),
    CONSTRAINT vm_static_max_memory_size_lower_bound CHECK ((mem_size_mb <= max_memory_size_mb))
);


ALTER TABLE public.vm_static OWNER TO engine;

--
-- Name: fn_get_num_of_vcpus(public.vm_static); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_get_num_of_vcpus(public.vm_static) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$

BEGIN
    RETURN $1. num_of_sockets * $1. cpu_per_socket * $1. threads_per_cpu;
END;$_$;


ALTER FUNCTION public.fn_get_num_of_vcpus(public.vm_static) OWNER TO engine;

--
-- Name: fn_image_deleted(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_image_deleted() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

BEGIN
    DELETE
    FROM disk_image_dynamic dim
    WHERE DIM.image_id = OLD.image_guid;

    RETURN OLD;
END;$$;


ALTER FUNCTION public.fn_image_deleted() OWNER TO engine;

--
-- Name: cluster; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cluster (
    cluster_id uuid NOT NULL,
    name character varying(40) NOT NULL,
    description character varying(4000) DEFAULT ''::character varying NOT NULL,
    cpu_name character varying(255) DEFAULT ''::character varying,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    storage_pool_id uuid,
    max_vds_memory_over_commit integer DEFAULT 100 NOT NULL,
    compatibility_version character varying(40) DEFAULT '2.2'::character varying NOT NULL,
    transparent_hugepages boolean DEFAULT false NOT NULL,
    migrate_on_error integer DEFAULT 1 NOT NULL,
    virt_service boolean DEFAULT true NOT NULL,
    gluster_service boolean DEFAULT false NOT NULL,
    count_threads_as_cores boolean DEFAULT false NOT NULL,
    emulated_machine character varying(40) DEFAULT ''::character varying,
    trusted_service boolean DEFAULT false NOT NULL,
    tunnel_migration boolean DEFAULT false NOT NULL,
    cluster_policy_id uuid,
    cluster_policy_custom_properties text,
    enable_balloon boolean DEFAULT false NOT NULL,
    free_text_comment text DEFAULT ''::text NOT NULL,
    detect_emulated_machine boolean DEFAULT false,
    architecture integer DEFAULT 0 NOT NULL,
    optimization_type smallint DEFAULT 0,
    spice_proxy character varying(255),
    ha_reservation boolean DEFAULT false NOT NULL,
    enable_ksm boolean DEFAULT true NOT NULL,
    serial_number_policy smallint,
    custom_serial_number character varying(255) DEFAULT NULL::character varying,
    additional_rng_sources character varying(255),
    skip_fencing_if_sd_active boolean DEFAULT false,
    skip_fencing_if_connectivity_broken boolean DEFAULT false,
    hosts_with_broken_connectivity_threshold smallint DEFAULT 50,
    fencing_enabled boolean DEFAULT true,
    is_auto_converge boolean,
    is_migrate_compressed boolean,
    gluster_tuned_profile character varying(50),
    gluster_cli_based_snapshot_scheduled boolean DEFAULT true NOT NULL,
    ksm_merge_across_nodes boolean DEFAULT true,
    migration_bandwidth_limit_type character varying(16) DEFAULT 'AUTO'::character varying NOT NULL,
    custom_migration_bandwidth_limit integer,
    migration_policy_id uuid,
    mac_pool_id uuid NOT NULL,
    switch_type character varying(6) DEFAULT 'legacy'::character varying NOT NULL,
    skip_fencing_if_gluster_bricks_up boolean DEFAULT false,
    skip_fencing_if_gluster_quorum_not_met boolean DEFAULT false,
    firewall_type integer DEFAULT 1 NOT NULL,
    default_network_provider_id uuid,
    log_max_memory_used_threshold integer DEFAULT 95 NOT NULL,
    log_max_memory_used_threshold_type smallint DEFAULT 0 NOT NULL,
    vnc_encryption_enabled boolean DEFAULT false,
    upgrade_running boolean DEFAULT false NOT NULL,
    smt_disabled boolean DEFAULT false NOT NULL,
    bios_type integer,
    cpu_flags text,
    cpu_verb text,
    is_migrate_encrypted boolean,
    managed boolean DEFAULT true,
    fips_mode smallint DEFAULT 0 NOT NULL,
    parallel_migrations smallint DEFAULT 0 NOT NULL,
    upgrade_percent_complete smallint DEFAULT 0 NOT NULL,
    upgrade_correlation_id character varying(50),
    CONSTRAINT check_cluster_custom_migration_bandwidth_set CHECK ((((migration_bandwidth_limit_type)::text <> 'CUSTOM'::text) OR (custom_migration_bandwidth_limit IS NOT NULL))),
    CONSTRAINT check_cluster_migration_bandwidth_limit_type_enum CHECK ((((migration_bandwidth_limit_type)::text = 'AUTO'::text) OR ((migration_bandwidth_limit_type)::text = 'VDSM_CONFIG'::text) OR ((migration_bandwidth_limit_type)::text = 'CUSTOM'::text)))
);


ALTER TABLE public.cluster OWNER TO engine;

--
-- Name: cluster_policies; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cluster_policies (
    id uuid NOT NULL,
    name character varying(128) NOT NULL,
    description character varying(4000),
    is_locked boolean NOT NULL,
    is_default boolean NOT NULL,
    custom_properties text
);


ALTER TABLE public.cluster_policies OWNER TO engine;

--
-- Name: storage_pool; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_pool (
    id uuid NOT NULL,
    name character varying(40) NOT NULL,
    description character varying(4000) NOT NULL,
    storage_pool_type integer,
    storage_pool_format_type character varying(50),
    status integer NOT NULL,
    master_domain_version integer NOT NULL,
    spm_vds_id uuid,
    compatibility_version character varying(40) DEFAULT '2.2'::character varying NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    quota_enforcement_type integer,
    free_text_comment text DEFAULT ''::text NOT NULL,
    is_local boolean,
    managed boolean DEFAULT true
);


ALTER TABLE public.storage_pool OWNER TO engine;

--
-- Name: cluster_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.cluster_view AS
 SELECT cluster.cluster_id,
    cluster.name,
    cluster.description,
    cluster.cpu_name,
    cluster._create_date,
    cluster._update_date,
    cluster.storage_pool_id,
    cluster.max_vds_memory_over_commit,
    cluster.compatibility_version,
    cluster.transparent_hugepages,
    cluster.migrate_on_error,
    cluster.virt_service,
    cluster.gluster_service,
    cluster.count_threads_as_cores,
    cluster.emulated_machine,
    cluster.trusted_service,
    cluster.tunnel_migration,
    cluster.cluster_policy_id,
    cluster.cluster_policy_custom_properties,
    cluster.enable_balloon,
    cluster.free_text_comment,
    cluster.detect_emulated_machine,
    cluster.architecture,
    cluster.optimization_type,
    cluster.spice_proxy,
    cluster.ha_reservation,
    cluster.enable_ksm,
    cluster.serial_number_policy,
    cluster.custom_serial_number,
    cluster.additional_rng_sources,
    cluster.skip_fencing_if_sd_active,
    cluster.skip_fencing_if_connectivity_broken,
    cluster.hosts_with_broken_connectivity_threshold,
    cluster.fencing_enabled,
    cluster.is_auto_converge,
    cluster.is_migrate_compressed,
    cluster.gluster_tuned_profile,
    cluster.gluster_cli_based_snapshot_scheduled,
    cluster.ksm_merge_across_nodes,
    cluster.migration_bandwidth_limit_type,
    cluster.custom_migration_bandwidth_limit,
    cluster.migration_policy_id,
    cluster.mac_pool_id,
    cluster.switch_type,
    cluster.skip_fencing_if_gluster_bricks_up,
    cluster.skip_fencing_if_gluster_quorum_not_met,
    cluster.firewall_type,
    cluster.default_network_provider_id,
    cluster.log_max_memory_used_threshold,
    cluster.log_max_memory_used_threshold_type,
    cluster.vnc_encryption_enabled,
    cluster.upgrade_running,
    cluster.smt_disabled,
    cluster.bios_type,
    cluster.cpu_flags,
    cluster.cpu_verb,
    cluster.is_migrate_encrypted,
    cluster.managed,
    cluster.fips_mode,
    cluster.parallel_migrations,
    cluster.upgrade_percent_complete,
    cluster.upgrade_correlation_id,
    storage_pool.name AS storage_pool_name,
    cluster_policies.name AS cluster_policy_name
   FROM ((public.cluster
     LEFT JOIN public.storage_pool ON ((cluster.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.cluster_policies ON ((cluster.cluster_policy_id = cluster_policies.id)));


ALTER TABLE public.cluster_view OWNER TO engine;

--
-- Name: fn_perms_get_clusters_with_permitted_action(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_perms_get_clusters_with_permitted_action(v_user_id uuid, v_action_group_id integer) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE (
            SELECT 1
            FROM get_entity_permissions(v_user_id, v_action_group_id, cluster_view.cluster_id, 9)
            ) IS NOT NULL;
END;$$;


ALTER FUNCTION public.fn_perms_get_clusters_with_permitted_action(v_user_id uuid, v_action_group_id integer) OWNER TO engine;

--
-- Name: fn_perms_get_storage_pools_with_permitted_action_on_clusters(uuid, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_perms_get_storage_pools_with_permitted_action_on_clusters(v_user_id uuid, v_action_group_id integer, v_supports_virt_service boolean, v_supports_gluster_service boolean) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT sp.*
    FROM storage_pool sp
    WHERE sp.id IN (
            SELECT vg.storage_pool_id
            FROM cluster vg
            WHERE (
                    SELECT get_entity_permissions(v_user_id, v_action_group_id, vg.cluster_id, 9)
                    ) IS NOT NULL
                AND (
                    (
                        v_supports_virt_service = TRUE
                        AND vg.virt_service = TRUE
                        )
                    OR (
                        v_supports_gluster_service = TRUE
                        AND vg.gluster_service = TRUE
                        )
                    )
            );
END;$$;


ALTER FUNCTION public.fn_perms_get_storage_pools_with_permitted_action_on_clusters(v_user_id uuid, v_action_group_id integer, v_supports_virt_service boolean, v_supports_gluster_service boolean) OWNER TO engine;

--
-- Name: quota; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.quota (
    id uuid NOT NULL,
    storage_pool_id uuid NOT NULL,
    quota_name character varying(65) NOT NULL,
    description character varying(250) DEFAULT ''::character varying NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    threshold_cluster_percentage integer DEFAULT 80,
    threshold_storage_percentage integer DEFAULT 80,
    grace_cluster_percentage integer DEFAULT 20,
    grace_storage_percentage integer DEFAULT 20,
    is_default boolean DEFAULT false
);


ALTER TABLE public.quota OWNER TO engine;

--
-- Name: vm_templates_based_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_templates_based_view AS
 SELECT vm_templates.vm_guid AS vmt_guid,
    vm_templates.vm_name AS name,
    vm_templates.mem_size_mb,
    vm_templates.max_memory_size_mb,
    vm_templates.num_of_io_threads,
    vm_templates.os,
    vm_templates.creation_date,
    vm_templates.child_count,
    vm_templates.num_of_sockets,
    vm_templates.cpu_per_socket,
    vm_templates.threads_per_cpu,
    public.fn_get_num_of_vcpus(vm_templates.*) AS num_of_cpus,
    vm_templates.description,
    vm_templates.free_text_comment,
    vm_templates.cluster_id,
    vm_templates.num_of_monitors,
    vm_templates.allow_console_reconnect,
    vm_templates.template_status AS status,
    vm_templates.usb_policy,
    vm_templates.time_zone,
    cluster.name AS cluster_name,
    cluster.compatibility_version AS cluster_compatibility_version,
    cluster.trusted_service,
    cluster.bios_type AS cluster_bios_type,
    vm_templates.vm_type,
    vm_templates.nice_level,
    vm_templates.cpu_shares,
    storage_pool.id AS storage_pool_id,
    storage_pool.name AS storage_pool_name,
    storage_pool.quota_enforcement_type,
    vm_templates.default_boot_sequence,
    vm_templates.default_display_type,
    vm_templates.priority,
    vm_templates.auto_startup,
    vm_templates.lease_sd_id,
    vm_templates.is_stateless,
    vm_templates.is_smartcard_enabled,
    vm_templates.is_delete_protected,
    vm_templates.sso_method,
    vm_templates.iso_path,
    vm_templates.origin,
    vm_templates.initrd_url,
    vm_templates.kernel_url,
    vm_templates.kernel_params,
    vm_templates.quota_id,
    quota.quota_name,
    vm_templates.db_generation,
    vm_templates.host_cpu_flags,
    vm_templates.migration_support,
    public.fn_get_dedicated_hosts_ids_by_vm_id(vm_templates.vm_guid) AS dedicated_vm_for_vds,
    vm_templates.is_disabled,
    vm_templates.tunnel_migration,
    vm_templates.vnc_keyboard_layout,
    vm_templates.min_allocated_mem,
    vm_templates.is_run_and_pause,
    vm_templates.created_by_user_id,
    vm_templates.entity_type,
    vm_templates.migration_downtime,
    cluster.architecture,
    vm_templates.template_version_number,
    vm_templates.vmt_guid AS base_template_id,
    vm_templates.template_version_name,
    vm_templates.serial_number_policy,
    vm_templates.custom_serial_number,
    vm_templates.is_boot_menu_enabled,
    vm_templates.is_spice_file_transfer_enabled,
    vm_templates.is_spice_copy_paste_enabled,
    vm_templates.cpu_profile_id,
    vm_templates.is_auto_converge,
    vm_templates.is_migrate_compressed,
    vm_templates.is_migrate_encrypted,
    vm_templates.predefined_properties,
    vm_templates.userdefined_properties,
    vm_templates.custom_emulated_machine,
    vm_templates.bios_type,
    vm_templates.custom_cpu_name,
    vm_templates.small_icon_id,
    vm_templates.large_icon_id,
    vm_templates.migration_policy_id,
    vm_templates.console_disconnect_action,
    vm_templates.resume_behavior,
    vm_templates.custom_compatibility_version,
    vm_templates.multi_queues_enabled,
    vm_templates.virtio_scsi_multi_queues,
    vm_templates.use_tsc_frequency,
    vm_templates.is_template_sealed,
    vm_templates.cpu_pinning,
    vm_templates.balloon_enabled,
    vm_templates.console_disconnect_action_delay,
    vm_templates.cpu_pinning_policy,
    vm_templates.parallel_migrations
   FROM (((public.vm_static vm_templates
     LEFT JOIN public.cluster ON ((vm_templates.cluster_id = cluster.cluster_id)))
     LEFT JOIN public.storage_pool ON ((storage_pool.id = cluster.storage_pool_id)))
     LEFT JOIN public.quota ON ((vm_templates.quota_id = quota.id)))
  WHERE (((vm_templates.entity_type)::text = 'TEMPLATE'::text) OR ((vm_templates.entity_type)::text = 'INSTANCE_TYPE'::text) OR ((vm_templates.entity_type)::text = 'IMAGE_TYPE'::text));


ALTER TABLE public.vm_templates_based_view OWNER TO engine;

--
-- Name: fn_perms_get_templates_with_permitted_action(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_perms_get_templates_with_permitted_action(v_user_id uuid, v_action_group_id integer) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vm_templates_based_view.*
      FROM vm_templates_based_view, user_vm_template_permissions_view
      WHERE vm_templates_based_view.vmt_guid = user_vm_template_permissions_view.entity_id
          AND user_vm_template_permissions_view.user_id = v_user_id
          AND (SELECT get_entity_permissions(
              v_user_id,
              v_action_group_id,
              vm_templates_based_view.vmt_guid,
              4) IS NOT NULL);
END; $$;


ALTER FUNCTION public.fn_perms_get_templates_with_permitted_action(v_user_id uuid, v_action_group_id integer) OWNER TO engine;

--
-- Name: fn_user_permissions(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fn_user_permissions(v_userid uuid) RETURNS SETOF public.user_permissions
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE

BEGIN
    RETURN QUERY

    SELECT permissions.id AS permission_id,
        permissions.role_id,
        permissions.ad_element_id AS user_id
    FROM permissions
    INNER JOIN users
        ON permissions.ad_element_id = users.user_id
    WHERE users.user_id = v_userId

    UNION

    SELECT
        permissions.id AS permission_id,
        permissions.role_id,
        TEMP.user_id AS user_id
    FROM permissions
    INNER JOIN (
        -- get all groups of admin users
        SELECT
            ad_groups.id group_id,
            users.user_id
        FROM
            ad_groups,
            engine_sessions
        WHERE ad_groups.id IN (
            SELECT *
            FROM fnsplitteruuid(engine_sessions.group_ids)
            )
            AND users.user_id = v_userId
        ) TEMP
        ON permissions.ad_element_id = TEMP.group_id;
END;$$;


ALTER FUNCTION public.fn_user_permissions(v_userid uuid) OWNER TO engine;

--
-- Name: fnsplitter(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fnsplitter(ids text) RETURNS SETOF public.idtexttype
    LANGUAGE plpgsql IMMUTABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT regexp_split_to_table(ids, ',') AS id;
END;$$;


ALTER FUNCTION public.fnsplitter(ids text) OWNER TO engine;

--
-- Name: fnsplitterinteger(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fnsplitterinteger(ids text) RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN QUERY
        SELECT CAST(regexp_split_to_table(ids, ',') AS INTEGER);
END; $$;


ALTER FUNCTION public.fnsplitterinteger(ids text) OWNER TO engine;

--
-- Name: fnsplitteruuid(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fnsplitteruuid(ids text) RETURNS SETOF uuid
    LANGUAGE plpgsql IMMUTABLE
    AS $$

BEGIN
    IF ids != '' THEN
        RETURN QUERY
        SELECT CAST(regexp_split_to_table(ids, ',') AS UUID);
    END IF;

END;$$;


ALTER FUNCTION public.fnsplitteruuid(ids text) OWNER TO engine;

--
-- Name: fnsplitterwithseperator(text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.fnsplitterwithseperator(ids text, separator character varying) RETURNS SETOF public.idtexttype
    LANGUAGE plpgsql IMMUTABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT regexp_split_to_table(ids, separator) AS id;
END;$$;


ALTER FUNCTION public.fnsplitterwithseperator(ids text, separator character varying) OWNER TO engine;

--
-- Name: force_delete_storage_domain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.force_delete_storage_domain(v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM Remove_Entities_From_storage_domain(v_storage_domain_id);

    PERFORM DeletePermissionsByEntityId(v_storage_domain_id);

    DELETE
    FROM storage_domain_dynamic
    WHERE id = v_storage_domain_id;

    DELETE
    FROM storage_domain_static
    WHERE id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.force_delete_storage_domain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: freehostdevicesusedbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.freehostdevicesusedbyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE host_device
    SET vm_id = NULL
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.freehostdevicesusedbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: generate_drop_all_functions_syntax(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.generate_drop_all_functions_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $_$

    BEGIN
        RETURN QUERY

        SELECT 'drop function if exists ' || ns.nspname || '.' || proname || '(' || oidvectortypes(proargtypes) || ') cascade;'
        FROM pg_proc
        INNER JOIN pg_namespace ns
            ON (pg_proc.pronamespace = ns.oid)
        WHERE
            ns.nspname = 'public'
            AND (
                 probin IS  NULL
                 OR
                 -- prevent dropping installed extension functions
                 probin NOT IN  (SELECT '$libdir/' || extname from pg_extension)
            )
        ORDER BY proname;
    END;$_$;


ALTER FUNCTION public.generate_drop_all_functions_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_seq_syntax(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.generate_drop_all_seq_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT 'DROP SEQUENCE if exists ' || sequence_name || ' CASCADE;'
        FROM information_schema.sequences
        WHERE sequence_schema = 'public'
        ORDER BY sequence_name;
    END;$$;


ALTER FUNCTION public.generate_drop_all_seq_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_tables_syntax(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.generate_drop_all_tables_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT 'DROP TABLE if exists ' || table_name || ' CASCADE;'
        FROM information_schema.tables
        WHERE table_schema = 'public'
            AND table_type = 'BASE TABLE'
        ORDER BY table_name;
    END;$$;


ALTER FUNCTION public.generate_drop_all_tables_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_user_types_syntax(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.generate_drop_all_user_types_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT 'DROP TYPE if exists ' || c.relname::information_schema.sql_identifier || ' CASCADE;'
        FROM pg_namespace n,
            pg_class c,
            pg_type t
        WHERE n.oid = c.relnamespace
            AND t.typrelid = c.oid
            AND c.relkind = 'c'::"char"
            AND n.nspname = 'public'
        ORDER BY c.relname::information_schema.sql_identifier;
    END;$$;


ALTER FUNCTION public.generate_drop_all_user_types_syntax() OWNER TO engine;

--
-- Name: generate_drop_all_views_syntax(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.generate_drop_all_views_syntax() RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT 'DROP VIEW if exists ' || table_name || ' CASCADE;'
        FROM information_schema.VIEWS
        WHERE table_schema = 'public'
        AND table_name NOT ILIKE 'pg_%'
        ORDER BY table_name;
    END;$$;


ALTER FUNCTION public.generate_drop_all_views_syntax() OWNER TO engine;

--
-- Name: get_all_commands(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_all_commands() RETURNS SETOF public.get_all_commands_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT business_entity_snapshot.command_id,
        business_entity_snapshot.command_type
    FROM business_entity_snapshot;
END;$$;


ALTER FUNCTION public.get_all_commands() OWNER TO engine;

--
-- Name: get_entity_permissions(uuid, integer, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_entity_permissions(v_user_id uuid, v_action_group_id integer, v_object_id uuid, v_object_type_id integer) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
   DECLARE
   v_everyone_object_id  UUID;
BEGIN
   v_everyone_object_id := getGlobalIds('everyone'); -- hardcoded also in MLA Handler
   RETURN QUERY
   SELECT   id
   FROM permissions
   WHERE
       role_id IN(
           SELECT role_id
           FROM roles_groups
           WHERE action_group_id = v_action_group_id)
       -- get allparents of object
       AND (object_id IN(
           SELECT id
           FROM fn_get_entity_parents(v_object_id,v_object_type_id)))
       -- get user and his groups
       AND (ad_element_id = v_everyone_object_id
       OR ad_element_id = v_user_id
       OR ad_element_id IN(
           SELECT *
           FROM getUserAndGroupsById(v_user_id)
       )) LIMIT 1;
END; $$;


ALTER FUNCTION public.get_entity_permissions(v_user_id uuid, v_action_group_id integer, v_object_id uuid, v_object_type_id integer) OWNER TO engine;

--
-- Name: get_entity_permissions_for_user_and_groups(uuid, text, integer, uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_entity_permissions_for_user_and_groups(v_user_id uuid, v_group_ids text, v_action_group_id integer, v_object_id uuid, v_object_type_id integer, v_ignore_everyone boolean) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
   DECLARE
   v_everyone_object_id  UUID;
BEGIN
   v_everyone_object_id := getGlobalIds('everyone'); -- hardcoded also in MLA Handler
   RETURN QUERY
   SELECT id from permissions
   WHERE
   -- get all roles of action
       role_id IN(
           SELECT role_id from roles_groups
           WHERE action_group_id = v_action_group_id)
	-- get allparents of object
       AND (object_id IN(
           SELECT id
           FROM fn_get_entity_parents(v_object_id,v_object_type_id)))
	-- get user and his groups
       AND ((NOT v_ignore_everyone
           AND ad_element_id = v_everyone_object_id)
       OR ad_element_id = v_user_id
       OR ad_element_id IN(
            SELECT *
            FROM fnsplitteruuid(v_group_ids)
       )) LIMIT 1;
END; $$;


ALTER FUNCTION public.get_entity_permissions_for_user_and_groups(v_user_id uuid, v_group_ids text, v_action_group_id integer, v_object_id uuid, v_object_type_id integer, v_ignore_everyone boolean) OWNER TO engine;

--
-- Name: business_entity_snapshot; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.business_entity_snapshot (
    id uuid NOT NULL,
    command_id uuid NOT NULL,
    command_type character varying(256) NOT NULL,
    entity_id character varying(128),
    entity_type character varying(128),
    entity_snapshot text,
    snapshot_class character varying(128),
    snapshot_type integer,
    insertion_order integer,
    started_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.business_entity_snapshot OWNER TO engine;

--
-- Name: get_entity_snapshot_by_command_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_entity_snapshot_by_command_id(v_command_id uuid) RETURNS SETOF public.business_entity_snapshot
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT business_entity_snapshot.*
    FROM business_entity_snapshot
    WHERE command_id = v_command_id
    ORDER BY insertion_order DESC;
END;$$;


ALTER FUNCTION public.get_entity_snapshot_by_command_id(v_command_id uuid) OWNER TO engine;

--
-- Name: get_entity_snapshot_by_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_entity_snapshot_by_id(v_id uuid) RETURNS SETOF public.business_entity_snapshot
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT business_entity_snapshot.*
    FROM business_entity_snapshot
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.get_entity_snapshot_by_id(v_id uuid) OWNER TO engine;

--
-- Name: sso_clients_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.sso_clients_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sso_clients_seq OWNER TO engine;

--
-- Name: sso_clients; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.sso_clients (
    id bigint DEFAULT nextval('public.sso_clients_seq'::regclass) NOT NULL,
    client_id character varying(128) NOT NULL,
    client_secret character varying(1024) NOT NULL,
    callback_prefix character varying(1024),
    certificate_location character varying(1024),
    notification_callback character varying(1024),
    description text,
    email character varying(256),
    scope character varying(1024),
    trusted boolean DEFAULT true NOT NULL,
    notification_callback_protocol character varying(32) NOT NULL,
    notification_callback_verify_host boolean DEFAULT false NOT NULL,
    notification_callback_verify_chain boolean DEFAULT true NOT NULL,
    encrypted_userinfo boolean DEFAULT true NOT NULL
);


ALTER TABLE public.sso_clients OWNER TO engine;

--
-- Name: get_oauth_client(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_oauth_client(v_client_id character varying) RETURNS SETOF public.sso_clients
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT *
    FROM sso_clients
    WHERE client_id = v_client_id;
END;$$;


ALTER FUNCTION public.get_oauth_client(v_client_id character varying) OWNER TO engine;

--
-- Name: roles_groups; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.roles_groups (
    role_id uuid NOT NULL,
    action_group_id integer NOT NULL
);


ALTER TABLE public.roles_groups OWNER TO engine;

--
-- Name: get_role_groups_by_role_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_role_groups_by_role_id(v_role_id uuid) RETURNS SETOF public.roles_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM roles_groups
    WHERE
        role_id = v_role_id;

END; $$;


ALTER FUNCTION public.get_role_groups_by_role_id(v_role_id uuid) OWNER TO engine;

--
-- Name: get_roles_groups_by_action_group_id_and_by_role_id(integer, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_roles_groups_by_action_group_id_and_by_role_id(v_action_group_id integer, v_role_id uuid) RETURNS SETOF public.roles_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM roles_groups
    WHERE
        action_group_id = v_action_group_id
        AND role_id = v_role_id;

END; $$;


ALTER FUNCTION public.get_roles_groups_by_action_group_id_and_by_role_id(v_action_group_id integer, v_role_id uuid) OWNER TO engine;

--
-- Name: get_seconds_to_wait_before_pm_operation(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_seconds_to_wait_before_pm_operation(v_vds_name character varying, v_event character varying, v_wait_for_sec integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_last_event_dt TIMESTAMP
WITH TIME zone;
DECLARE v_now_dt TIMESTAMP
WITH TIME zone;

BEGIN
    IF EXISTS (
            SELECT 1
            FROM audit_log
            WHERE vds_name = v_vds_name
                AND log_type_name = v_event
            ) THEN
    BEGIN
        v_last_event_dt := log_time
        FROM audit_log
        WHERE vds_name = v_vds_name
            AND log_type_name = v_event
        ORDER BY audit_log_id DESC limit 1;

        v_now_dt := CURRENT_TIMESTAMP;

        RETURN cast((extract(epoch FROM v_last_event_dt) + v_wait_for_sec) - extract(epoch FROM v_now_dt) AS INT);
    END;
    ELSE
        RETURN 0;
END

IF ;END;$$;


ALTER FUNCTION public.get_seconds_to_wait_before_pm_operation(v_vds_name character varying, v_event character varying, v_wait_for_sec integer) OWNER TO engine;

--
-- Name: permissions; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.permissions (
    id uuid NOT NULL,
    role_id uuid NOT NULL,
    ad_element_id uuid NOT NULL,
    object_id uuid NOT NULL,
    object_type_id integer NOT NULL,
    creation_date bigint DEFAULT date_part('epoch'::text, now())
);


ALTER TABLE public.permissions OWNER TO engine;

--
-- Name: roles; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.roles (
    id uuid NOT NULL,
    name character varying(126) NOT NULL,
    description character varying(4000),
    is_readonly boolean NOT NULL,
    role_type integer NOT NULL,
    allows_viewing_children boolean DEFAULT false NOT NULL,
    app_mode integer NOT NULL
);


ALTER TABLE public.roles OWNER TO engine;

--
-- Name: permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.permissions_view AS
 SELECT permissions.id,
    permissions.role_id,
    permissions.ad_element_id,
    permissions.object_id,
    permissions.object_type_id,
    roles.name AS role_name,
    roles.role_type,
    roles.allows_viewing_children,
    roles.app_mode,
    public.fn_get_entity_name(permissions.object_id, permissions.object_type_id) AS object_name,
    (public.fn_authz_entry_info(permissions.ad_element_id)).name AS owner_name,
    (public.fn_authz_entry_info(permissions.ad_element_id)).namespace AS namespace,
    (public.fn_authz_entry_info(permissions.ad_element_id)).authz AS authz,
    permissions.creation_date
   FROM (public.permissions
     JOIN public.roles ON ((permissions.role_id = roles.id)));


ALTER TABLE public.permissions_view OWNER TO engine;

--
-- Name: get_user_permissions_for_domain(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.get_user_permissions_for_domain(v_name character varying, v_domain character varying) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_user_name VARCHAR(255);

v_index INT;

BEGIN
    -- find if name already includes domain (@)
    v_index := POSITION('@' IN v_name);

    IF (v_index > 0) THEN
        v_user_name := substr(v_name, 0, v_index);
    ELSE
        v_user_name := v_name;
    END IF;

    RETURN QUERY

SELECT *
FROM permissions_view
WHERE permissions_view.ad_element_id IN (
        SELECT users.user_id
        FROM users
        WHERE users.domain = v_domain
            AND (
                users.name = v_user_name
                OR users.name = v_user_name || '@' || upper(v_domain)
                )
        );END;$$;


ALTER FUNCTION public.get_user_permissions_for_domain(v_name character varying, v_domain character varying) OWNER TO engine;

--
-- Name: gluster_volume_access_protocols; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_access_protocols (
    volume_id uuid NOT NULL,
    access_protocol character varying(32) NOT NULL
);


ALTER TABLE public.gluster_volume_access_protocols OWNER TO engine;

--
-- Name: getaccessprotocolsbyglustervolumeguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getaccessprotocolsbyglustervolumeguid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_access_protocols
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_access_protocols
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getaccessprotocolsbyglustervolumeguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: network; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.network (
    id uuid NOT NULL,
    name character varying(256) DEFAULT ''::character varying NOT NULL,
    description character varying(4000) DEFAULT ''::character varying NOT NULL,
    type integer,
    addr character varying(50),
    subnet character varying(20),
    gateway character varying(20),
    vlan_id integer,
    stp boolean DEFAULT false NOT NULL,
    storage_pool_id uuid,
    mtu integer,
    vm_network boolean DEFAULT true NOT NULL,
    provider_network_provider_id uuid,
    provider_network_external_id text,
    free_text_comment text DEFAULT ''::text NOT NULL,
    label text,
    qos_id uuid,
    dns_resolver_configuration_id uuid,
    vdsm_name character varying(15) NOT NULL,
    provider_physical_network_id uuid,
    port_isolation boolean DEFAULT false NOT NULL
);


ALTER TABLE public.network OWNER TO engine;

--
-- Name: network_attachments; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.network_attachments (
    id uuid NOT NULL,
    network_id uuid NOT NULL,
    nic_id uuid NOT NULL,
    boot_protocol character varying(20) DEFAULT 'NONE'::character varying NOT NULL,
    address character varying(20),
    netmask character varying(20),
    gateway character varying(20),
    custom_properties text,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    ipv6_boot_protocol character varying(20) DEFAULT 'NONE'::character varying NOT NULL,
    ipv6_address character varying(50) DEFAULT NULL::character varying,
    ipv6_prefix integer,
    ipv6_gateway character varying(50) DEFAULT NULL::character varying,
    dns_resolver_configuration_id uuid,
    CONSTRAINT boot_protocol_enum_values CHECK ((((boot_protocol)::text = 'DHCP'::text) OR ((boot_protocol)::text = 'STATIC_IP'::text) OR ((boot_protocol)::text = 'NONE'::text)))
);


ALTER TABLE public.network_attachments OWNER TO engine;

--
-- Name: network_cluster; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.network_cluster (
    network_id uuid NOT NULL,
    cluster_id uuid NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    is_display boolean DEFAULT false NOT NULL,
    required boolean DEFAULT true NOT NULL,
    migration boolean DEFAULT false NOT NULL,
    management boolean DEFAULT false NOT NULL,
    is_gluster boolean DEFAULT false NOT NULL,
    default_route boolean DEFAULT false NOT NULL
);


ALTER TABLE public.network_cluster OWNER TO engine;

--
-- Name: vds_dynamic; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_dynamic (
    vds_id uuid NOT NULL,
    status integer NOT NULL,
    cpu_cores integer,
    cpu_model character varying(255),
    cpu_speed_mh numeric(18,0),
    if_total_speed character varying(40),
    kvm_enabled boolean,
    physical_mem_mb integer,
    mem_commited integer DEFAULT 0,
    vm_active integer DEFAULT 0,
    vm_count integer DEFAULT 0 NOT NULL,
    vm_migrating integer DEFAULT 0,
    reserved_mem integer,
    guest_overhead integer,
    software_version character varying(40),
    version_name character varying(40),
    build_name character varying(40),
    previous_status integer,
    cpu_flags character varying(4000),
    vms_cores_count integer,
    pending_vcpus_count integer,
    cpu_sockets integer,
    net_config_dirty boolean,
    supported_cluster_levels character varying(40),
    host_os character varying(4000),
    kvm_version character varying(4000),
    spice_version character varying(4000),
    kernel_version character varying(4000),
    iscsi_initiator_name character varying(4000),
    transparent_hugepages_state integer DEFAULT 0 NOT NULL,
    hooks text DEFAULT ''::character varying,
    _update_date timestamp with time zone,
    non_operational_reason integer DEFAULT 0 NOT NULL,
    pending_vmem_size integer DEFAULT 0 NOT NULL,
    rpm_version character varying(256) DEFAULT NULL::character varying,
    supported_engines character varying(40),
    libvirt_version character varying(256) DEFAULT NULL::character varying,
    cpu_threads integer,
    hw_manufacturer character varying(255),
    hw_product_name character varying(255),
    hw_version character varying(255),
    hw_serial_number character varying(255),
    hw_uuid character varying(255),
    hw_family character varying(255),
    hbas text,
    supported_emulated_machines text,
    gluster_version character varying(4000),
    controlled_by_pm_policy boolean DEFAULT false,
    kdump_status smallint DEFAULT '-1'::integer NOT NULL,
    selinux_enforce_mode integer,
    auto_numa_balancing smallint,
    is_numa_supported boolean,
    supported_rng_sources character varying(255),
    online_cpus text,
    maintenance_reason text,
    incoming_migrations integer DEFAULT 0 NOT NULL,
    outgoing_migrations integer DEFAULT 0 NOT NULL,
    is_update_available boolean DEFAULT false NOT NULL,
    external_status integer DEFAULT 0 NOT NULL,
    is_hostdev_enabled boolean DEFAULT false NOT NULL,
    librbd1_version character varying(4000),
    glusterfs_cli_version character varying(4000),
    kernel_args text,
    pretty_name character varying(255),
    hosted_engine_configured boolean DEFAULT false NOT NULL,
    in_fence_flow boolean DEFAULT false NOT NULL,
    kernel_features jsonb,
    openvswitch_version character varying(4000),
    vnc_encryption_enabled boolean DEFAULT false,
    connector_info jsonb,
    backup_enabled boolean DEFAULT false NOT NULL,
    supported_domain_versions character varying(256),
    supported_block_size jsonb,
    tsc_frequency character varying(10),
    tsc_scaling boolean DEFAULT false NOT NULL,
    fips_enabled boolean DEFAULT false NOT NULL,
    boot_uuid character varying(64),
    nmstate_version character varying(4000),
    cold_backup_enabled boolean DEFAULT false NOT NULL,
    cd_change_pdiv boolean DEFAULT false NOT NULL,
    clear_bitmaps_enabled boolean DEFAULT false NOT NULL,
    ovn_configured boolean DEFAULT false NOT NULL,
    cpu_topology jsonb,
    vdsm_cpus_affinity character varying(256)
);


ALTER TABLE public.vds_dynamic OWNER TO engine;

--
-- Name: vds_interface; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_interface (
    id uuid NOT NULL,
    name character varying(50) NOT NULL,
    network_name character varying(256),
    vds_id uuid,
    mac_addr character varying(59),
    is_bond boolean DEFAULT false,
    bond_name character varying(50),
    bond_type integer,
    bond_opts character varying(4000),
    vlan_id integer,
    speed integer,
    addr character varying(20),
    subnet character varying(20),
    gateway character varying(20),
    boot_protocol integer,
    type integer DEFAULT 0,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    mtu integer,
    bridged boolean DEFAULT true NOT NULL,
    labels text,
    qos_overridden boolean DEFAULT false NOT NULL,
    base_interface character varying(50),
    ipv6_boot_protocol integer,
    ipv6_address character varying(50),
    ipv6_prefix integer,
    ipv6_gateway character varying(50),
    ad_partner_mac character varying(59),
    reported_switch_type character varying(6),
    ad_aggregator_id integer,
    bond_active_slave character varying(50),
    ipv4_default_route boolean DEFAULT false NOT NULL
);


ALTER TABLE public.vds_interface OWNER TO engine;

--
-- Name: vds_interface_statistics; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_interface_statistics (
    id uuid NOT NULL,
    vds_id uuid,
    rx_rate numeric(24,4),
    tx_rate numeric(24,4),
    rx_drop numeric(20,0),
    tx_drop numeric(20,0),
    iface_status integer,
    _update_date timestamp with time zone,
    rx_total numeric(20,0),
    rx_offset numeric(20,0),
    tx_total numeric(20,0),
    tx_offset numeric(20,0),
    sample_time double precision
);


ALTER TABLE public.vds_interface_statistics OWNER TO engine;

--
-- Name: vds_static; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_static (
    vds_id uuid NOT NULL,
    vds_name character varying(255) NOT NULL,
    vds_unique_id character varying(128),
    host_name character varying(255) NOT NULL,
    port integer NOT NULL,
    cluster_id uuid NOT NULL,
    server_ssl_enabled boolean,
    vds_type integer DEFAULT 0 NOT NULL,
    pm_enabled boolean DEFAULT false NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    otp_validity bigint,
    vds_spm_priority smallint DEFAULT 5,
    recoverable boolean DEFAULT true NOT NULL,
    sshkeyfingerprint character varying(1024),
    pm_proxy_preferences character varying(255) DEFAULT ''::character varying,
    console_address character varying(255) DEFAULT NULL::character varying,
    ssh_username character varying(255),
    ssh_port integer,
    free_text_comment text DEFAULT ''::text NOT NULL,
    disable_auto_pm boolean DEFAULT false,
    pm_detect_kdump boolean DEFAULT false NOT NULL,
    host_provider_id uuid,
    kernel_cmdline text,
    last_stored_kernel_cmdline text,
    reinstall_required boolean DEFAULT false NOT NULL,
    vgpu_placement integer DEFAULT 1 NOT NULL,
    ssh_public_key character varying(8192),
    CONSTRAINT vds_static_vds_spm_priority_check CHECK (((vds_spm_priority >= '-1'::integer) AND (vds_spm_priority <= 10)))
);


ALTER TABLE public.vds_static OWNER TO engine;

--
-- Name: vds_interface_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vds_interface_view AS
 SELECT vds_interface_statistics.rx_rate,
    vds_interface_statistics.tx_rate,
    vds_interface_statistics.rx_drop,
    vds_interface_statistics.tx_drop,
    vds_interface_statistics.rx_total,
    vds_interface_statistics.tx_total,
    vds_interface_statistics.rx_offset,
    vds_interface_statistics.tx_offset,
    vds_interface_statistics.iface_status,
    vds_interface_statistics.sample_time,
    vds_interface.type,
    vds_interface.gateway,
    vds_interface.ipv4_default_route,
    vds_interface.ipv6_gateway,
    vds_interface.subnet,
    vds_interface.ipv6_prefix,
    vds_interface.addr,
    vds_interface.ipv6_address,
    vds_interface.speed,
    vds_interface.base_interface,
    vds_interface.vlan_id,
    vds_interface.bond_type,
    vds_interface.bond_name,
    vds_interface.is_bond,
    vds_interface.bond_opts,
    vds_interface.mac_addr,
    vds_interface.network_name,
    vds_interface.name,
    vds_static.vds_id,
    vds_static.vds_name,
    vds_interface.id,
    vds_interface.boot_protocol,
    vds_interface.ipv6_boot_protocol,
    vds_interface.mtu,
    vds_interface.bridged,
    vds_interface.reported_switch_type,
    1 AS is_vds,
    vds_interface.qos_overridden,
    vds_interface.labels,
    vds_static.cluster_id,
    vds_interface.ad_partner_mac,
    vds_interface.ad_aggregator_id,
    vds_interface.bond_active_slave
   FROM ((public.vds_interface_statistics
     JOIN public.vds_interface ON ((vds_interface_statistics.id = vds_interface.id)))
     JOIN public.vds_static ON ((vds_interface.vds_id = vds_static.vds_id)));


ALTER TABLE public.vds_interface_view OWNER TO engine;

--
-- Name: active_migration_network_interfaces; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.active_migration_network_interfaces AS
 SELECT vds_interface_view.rx_rate,
    vds_interface_view.tx_rate,
    vds_interface_view.rx_drop,
    vds_interface_view.tx_drop,
    vds_interface_view.rx_total,
    vds_interface_view.tx_total,
    vds_interface_view.rx_offset,
    vds_interface_view.tx_offset,
    vds_interface_view.iface_status,
    vds_interface_view.sample_time,
    vds_interface_view.type,
    vds_interface_view.gateway,
    vds_interface_view.ipv4_default_route,
    vds_interface_view.ipv6_gateway,
    vds_interface_view.subnet,
    vds_interface_view.ipv6_prefix,
    vds_interface_view.addr,
    vds_interface_view.ipv6_address,
    vds_interface_view.speed,
    vds_interface_view.base_interface,
    vds_interface_view.vlan_id,
    vds_interface_view.bond_type,
    vds_interface_view.bond_name,
    vds_interface_view.is_bond,
    vds_interface_view.bond_opts,
    vds_interface_view.mac_addr,
    vds_interface_view.network_name,
    vds_interface_view.name,
    vds_interface_view.vds_id,
    vds_interface_view.vds_name,
    vds_interface_view.id,
    vds_interface_view.boot_protocol,
    vds_interface_view.ipv6_boot_protocol,
    vds_interface_view.mtu,
    vds_interface_view.bridged,
    vds_interface_view.reported_switch_type,
    vds_interface_view.is_vds,
    vds_interface_view.qos_overridden,
    vds_interface_view.labels,
    vds_interface_view.cluster_id,
    vds_interface_view.ad_partner_mac,
    vds_interface_view.ad_aggregator_id,
    vds_interface_view.bond_active_slave
   FROM public.vds_interface_view,
    public.vds_dynamic,
    public.network_attachments,
    public.network,
    public.network_cluster
  WHERE ((vds_interface_view.id = network_attachments.nic_id) AND (network_attachments.network_id = network.id) AND (network.id = network_cluster.network_id) AND network_cluster.migration AND (network_cluster.cluster_id = vds_interface_view.cluster_id) AND (vds_dynamic.vds_id = vds_interface_view.vds_id) AND (vds_dynamic.status = ANY (ARRAY[3, 9])) AND (vds_interface_view.iface_status = 1));


ALTER TABLE public.active_migration_network_interfaces OWNER TO engine;

--
-- Name: getactivemigrationnetworkinterfaceforhost(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivemigrationnetworkinterfaceforhost(v_host_id uuid) RETURNS SETOF public.active_migration_network_interfaces
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM active_migration_network_interfaces
    WHERE vds_id = v_host_id;
END;$$;


ALTER FUNCTION public.getactivemigrationnetworkinterfaceforhost(v_host_id uuid) OWNER TO engine;

--
-- Name: vm_interface; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_interface (
    id uuid NOT NULL,
    vm_guid uuid NOT NULL,
    mac_addr character varying(20),
    name character varying(50) NOT NULL,
    speed integer,
    type integer DEFAULT 0,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    linked boolean DEFAULT true NOT NULL,
    vnic_profile_id uuid,
    synced boolean DEFAULT true
);


ALTER TABLE public.vm_interface OWNER TO engine;

--
-- Name: getactivevminterfacesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevminterfacesbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface.*
    FROM vm_interfaces_plugged_on_vm_not_down_view as vm_interface
    INNER JOIN vnic_profiles
        ON vm_interface.vnic_profile_id = vnic_profiles.id
    WHERE vnic_profiles.network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getactivevminterfacesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getactivevminterfacesbyprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevminterfacesbyprofileid(v_profile_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface.*
    FROM vm_interfaces_plugged_on_vm_not_down_view as vm_interface
    WHERE vm_interface.vnic_profile_id = v_profile_id;
END;$$;


ALTER FUNCTION public.getactivevminterfacesbyprofileid(v_profile_id uuid) OWNER TO engine;

--
-- Name: getactivevmnameswithisoattached(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevmnameswithisoattached(v_iso_disk_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vs.vm_name
    FROM vm_static vs
    JOIN vm_dynamic vd ON vd.vm_guid = vs.vm_guid
    WHERE vs.iso_path = v_iso_disk_id::VARCHAR
        AND vd.status NOT IN (0, 14, 15);
END; $$;


ALTER FUNCTION public.getactivevmnameswithisoattached(v_iso_disk_id uuid) OWNER TO engine;

--
-- Name: getactivevmnameswithisoonstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevmnameswithisoonstoragedomain(v_storage_domain_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vd.vm_name
    FROM images_storage_domain_view image, vms_monitoring_view vd
    WHERE image.storage_id = v_storage_domain_id
    AND vd.status not in (0, 14, 15) -- Down, ImageIllegal, ImageLocked
    AND image.image_group_id::VARCHAR = vd.current_cd;
END; $$;


ALTER FUNCTION public.getactivevmnameswithisoonstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getactivevmnameswithleaseonstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevmnameswithleaseonstoragedomain(v_storage_domain_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vs.vm_name
    FROM vm_static vs
    JOIN vm_dynamic vd ON vd.vm_guid = vs.vm_guid
    WHERE lease_sd_id = v_storage_domain_id
        AND vd.status <> 0;
END; $$;


ALTER FUNCTION public.getactivevmnameswithleaseonstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: disk_vm_element; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.disk_vm_element (
    disk_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    is_boot boolean DEFAULT false NOT NULL,
    disk_interface character varying(32) NOT NULL,
    is_using_scsi_reservation boolean DEFAULT false NOT NULL,
    pass_discard boolean DEFAULT false NOT NULL
);


ALTER TABLE public.disk_vm_element OWNER TO engine;

--
-- Name: images; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.images (
    image_guid uuid NOT NULL,
    creation_date timestamp with time zone NOT NULL,
    size bigint NOT NULL,
    it_guid uuid NOT NULL,
    parentid uuid,
    imagestatus integer DEFAULT 0,
    lastmodified timestamp with time zone NOT NULL,
    vm_snapshot_id uuid,
    volume_type integer DEFAULT 2 NOT NULL,
    volume_format integer DEFAULT 4 NOT NULL,
    image_group_id uuid,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    active boolean DEFAULT false NOT NULL,
    volume_classification smallint,
    qcow_compat integer DEFAULT 0,
    sequence_number integer DEFAULT 0
);


ALTER TABLE public.images OWNER TO engine;

--
-- Name: snapshots; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.snapshots (
    snapshot_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    snapshot_type character varying(32) NOT NULL,
    status character varying(32) NOT NULL,
    description character varying(4000),
    creation_date timestamp with time zone NOT NULL,
    app_list text,
    vm_configuration text,
    _create_date timestamp with time zone DEFAULT now(),
    _update_date timestamp with time zone,
    memory_metadata_disk_id uuid,
    memory_dump_disk_id uuid,
    vm_configuration_broken boolean DEFAULT false NOT NULL,
    changed_fields text
);


ALTER TABLE public.snapshots OWNER TO engine;

--
-- Name: vm_dynamic; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_dynamic (
    vm_guid uuid NOT NULL,
    status integer NOT NULL,
    vm_ip text,
    vm_host character varying(255),
    last_start_time timestamp with time zone,
    guest_cur_user_name text,
    guest_os character varying(255),
    run_on_vds uuid,
    migrating_to_vds uuid,
    app_list text,
    acpi_enable boolean,
    session integer,
    utc_diff integer,
    client_ip character varying(255),
    guest_requested_memory integer,
    boot_sequence integer,
    exit_status integer DEFAULT 0 NOT NULL,
    pause_status integer DEFAULT 0 NOT NULL,
    exit_message character varying(4000),
    hash character varying(30),
    console_user_id uuid,
    guest_agent_nics_hash integer,
    console_cur_user_name character varying(255),
    last_watchdog_event bigint,
    last_watchdog_action character varying(8),
    is_run_once boolean DEFAULT false NOT NULL,
    vm_fqdn text DEFAULT ''::text,
    cpu_name character varying(4000),
    last_stop_time timestamp with time zone,
    current_cd character varying(4000) DEFAULT NULL::character varying,
    reason text,
    exit_reason integer DEFAULT '-1'::integer,
    guest_cpu_count integer,
    emulated_machine character varying(255),
    spice_port integer,
    spice_tls_port integer,
    spice_ip character varying(255) DEFAULT NULL::character varying,
    vnc_port integer,
    vnc_ip character varying(255) DEFAULT NULL::character varying,
    ovirt_guest_agent_status integer DEFAULT 0,
    guest_timezone_offset integer,
    guest_timezone_name character varying(255),
    guestos_arch integer DEFAULT 0 NOT NULL,
    guestos_codename character varying(255),
    guestos_distribution character varying(255),
    guestos_kernel_version character varying(255),
    guestos_type character varying(255) DEFAULT 'Other'::character varying NOT NULL,
    guestos_version character varying(255),
    guest_containers text DEFAULT '[]'::text,
    boot_time timestamp with time zone,
    downtime bigint DEFAULT 0,
    volatile_run boolean DEFAULT false NOT NULL,
    lease_info character varying(1000),
    runtime_name character varying(255),
    qemu_guest_agent_status integer DEFAULT 0,
    current_cpu_pinning character varying(4000),
    current_sockets integer DEFAULT 0 NOT NULL,
    current_cores integer DEFAULT 0 NOT NULL,
    current_threads integer DEFAULT 0 NOT NULL,
    current_numa_pinning character varying(4000)
);


ALTER TABLE public.vm_dynamic OWNER TO engine;

--
-- Name: vm_pool_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_pool_map (
    vm_pool_id uuid,
    vm_guid uuid NOT NULL
);


ALTER TABLE public.vm_pool_map OWNER TO engine;

--
-- Name: vm_pools; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_pools (
    vm_pool_id uuid NOT NULL,
    vm_pool_name character varying(255) NOT NULL,
    vm_pool_description character varying(4000) NOT NULL,
    vm_pool_type integer,
    parameters character varying(200),
    cluster_id uuid,
    prestarted_vms smallint DEFAULT 0,
    max_assigned_vms_per_user smallint DEFAULT 1,
    vm_pool_comment text,
    spice_proxy character varying(255),
    is_being_destroyed boolean DEFAULT false NOT NULL,
    stateful boolean DEFAULT false NOT NULL,
    is_auto_storage_select boolean DEFAULT false
);


ALTER TABLE public.vm_pools OWNER TO engine;

--
-- Name: vm_pool_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_pool_map_view AS
 SELECT vm_pool_map.vm_guid,
    vm_pool_map.vm_pool_id,
    vm_pools.vm_pool_name,
    vm_pools.spice_proxy AS vm_pool_spice_proxy
   FROM (public.vm_pool_map
     JOIN public.vm_pools ON ((vm_pool_map.vm_pool_id = vm_pools.vm_pool_id)));


ALTER TABLE public.vm_pool_map_view OWNER TO engine;

--
-- Name: vm_statistics; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_statistics (
    vm_guid uuid NOT NULL,
    cpu_user numeric(18,0) DEFAULT 0,
    cpu_sys numeric(18,0) DEFAULT 0,
    usage_mem_percent integer DEFAULT 0,
    usage_cpu_percent integer DEFAULT 0,
    disks_usage text,
    _update_date timestamp with time zone,
    guest_mem_buffered bigint,
    guest_mem_cached bigint,
    usage_network_percent smallint DEFAULT 0,
    elapsed_time numeric(18,0) DEFAULT 0
);


ALTER TABLE public.vm_statistics OWNER TO engine;

--
-- Name: vms; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vms AS
 SELECT vm_static.vm_name,
    vm_static.mem_size_mb,
    vm_static.max_memory_size_mb,
    vm_static.num_of_io_threads,
    vm_static.nice_level,
    vm_static.cpu_shares,
    vm_static.vmt_guid,
    vm_static.os,
    vm_static.description,
    vm_static.free_text_comment,
    vm_static.cluster_id,
    vm_static.creation_date,
    vm_static.auto_startup,
    vm_static.lease_sd_id,
    vm_dynamic.lease_info,
    vm_static.is_stateless,
    vm_static.is_smartcard_enabled,
    vm_static.is_delete_protected,
    vm_static.sso_method,
    public.fn_get_dedicated_hosts_ids_by_vm_id(vm_static.vm_guid) AS dedicated_vm_for_vds,
    vm_static.default_boot_sequence,
    vm_static.vm_type,
    vm_pool_map_view.vm_pool_spice_proxy,
    cluster.name AS cluster_name,
    cluster.transparent_hugepages,
    cluster.trusted_service,
    storage_pool.id AS storage_pool_id,
    storage_pool.name AS storage_pool_name,
    cluster.spice_proxy AS cluster_spice_proxy,
    vm_templates.vm_name AS vmt_name,
    vm_dynamic.status,
    vm_dynamic.vm_ip,
    public.fn_get_comparable_ip_list(vm_dynamic.vm_ip) AS vm_ip_inet_array,
    vm_dynamic.vm_host,
    vm_dynamic.last_start_time,
    vm_dynamic.boot_time,
    vm_dynamic.downtime,
    vm_dynamic.guest_cur_user_name,
    vm_dynamic.console_cur_user_name,
    vm_dynamic.runtime_name,
    vm_dynamic.guest_os,
    vm_dynamic.console_user_id,
    vm_dynamic.guest_agent_nics_hash,
    vm_dynamic.run_on_vds,
    vm_dynamic.migrating_to_vds,
    vm_dynamic.app_list,
    vm_pool_map_view.vm_pool_name,
    vm_pool_map_view.vm_pool_id,
    vm_static.vm_guid,
    vm_static.num_of_monitors,
    vm_static.allow_console_reconnect,
    vm_static.is_initialized,
    vm_static.num_of_sockets,
    vm_static.cpu_per_socket,
    vm_static.threads_per_cpu,
    vm_static.usb_policy,
    vm_dynamic.acpi_enable,
    vm_dynamic.session,
    public.fn_get_num_of_vcpus(vm_static.*) AS num_of_cpus,
    vm_static.quota_id,
    quota.quota_name,
    storage_pool.quota_enforcement_type,
    vm_dynamic.boot_sequence,
    vm_dynamic.utc_diff,
    vm_dynamic.client_ip,
    vm_dynamic.guest_requested_memory,
    vm_static.time_zone,
    vm_statistics.cpu_user,
    vm_statistics.cpu_sys,
    vm_statistics.elapsed_time,
    vm_statistics.usage_network_percent,
    vm_statistics.disks_usage,
    vm_statistics.usage_mem_percent,
    vm_statistics.usage_cpu_percent,
    vds_static.vds_name AS run_on_vds_name,
    cluster.cpu_name AS cluster_cpu_name,
    cluster.cpu_flags AS cluster_cpu_flags,
    cluster.cpu_verb AS cluster_cpu_verb,
    vm_static.default_display_type,
    vm_static.priority,
    vm_static.iso_path,
    vm_static.origin,
    cluster.compatibility_version AS cluster_compatibility_version,
    vm_static.initrd_url,
    vm_static.kernel_url,
    vm_static.kernel_params,
    vm_dynamic.pause_status,
    vm_dynamic.exit_message,
    vm_dynamic.exit_status,
    vm_static.migration_support,
    vm_static.predefined_properties,
    vm_static.userdefined_properties,
    vm_static.min_allocated_mem,
    vm_dynamic.hash,
    vm_static.cpu_pinning,
    vm_static.db_generation,
    vm_static.host_cpu_flags,
    vm_static.tunnel_migration,
    vm_static.vnc_keyboard_layout,
    vm_static.is_run_and_pause,
    vm_static.created_by_user_id,
    vm_dynamic.last_watchdog_event,
    vm_dynamic.last_watchdog_action,
    vm_dynamic.is_run_once,
    vm_dynamic.volatile_run,
    vm_dynamic.vm_fqdn,
    vm_dynamic.cpu_name,
    vm_dynamic.emulated_machine,
    vm_dynamic.current_cd,
    vm_dynamic.reason,
    vm_dynamic.exit_reason,
    vm_static.instance_type_id,
    vm_static.image_type_id,
    cluster.architecture,
    vm_static.original_template_id,
    vm_static.original_template_name,
    vm_dynamic.last_stop_time,
    vm_static.migration_downtime,
    vm_static.template_version_number,
    vm_static.serial_number_policy,
    vm_static.custom_serial_number,
    vm_static.is_boot_menu_enabled,
    vm_dynamic.guest_cpu_count,
    vm_snapshots.next_run_config_exists,
    vm_snapshots.is_previewing_snapshot,
    vm_snapshots.changed_fields,
    vm_static.is_spice_file_transfer_enabled,
    vm_static.is_spice_copy_paste_enabled,
    vm_static.cpu_profile_id,
    vm_static.is_auto_converge,
    vm_static.is_migrate_compressed,
    vm_static.is_migrate_encrypted,
    vm_static.custom_emulated_machine,
    vm_static.bios_type,
    cluster.bios_type AS cluster_bios_type,
    vm_static.custom_cpu_name,
    vm_dynamic.spice_port,
    vm_dynamic.spice_tls_port,
    vm_dynamic.spice_ip,
    vm_dynamic.vnc_port,
    vm_dynamic.vnc_ip,
    vm_dynamic.ovirt_guest_agent_status,
    vm_dynamic.qemu_guest_agent_status,
    vm_statistics.guest_mem_buffered,
    vm_statistics.guest_mem_cached,
    vm_static.small_icon_id,
    vm_static.large_icon_id,
    vm_static.migration_policy_id,
    vm_static.provider_id,
    vm_static.console_disconnect_action,
    vm_static.resume_behavior,
    vm_dynamic.guest_timezone_offset,
    vm_dynamic.guest_timezone_name,
    vm_dynamic.guestos_arch,
    vm_dynamic.guestos_codename,
    vm_dynamic.guestos_distribution,
    vm_dynamic.guestos_kernel_version,
    vm_dynamic.guestos_type,
    vm_dynamic.guestos_version,
    vm_static.custom_compatibility_version,
    vm_dynamic.guest_containers,
    image_details.has_illegal_images,
    vm_static.multi_queues_enabled,
    vm_static.virtio_scsi_multi_queues,
    vm_static.use_tsc_frequency,
    vm_static.namespace,
    vm_static.balloon_enabled,
    vm_static.console_disconnect_action_delay,
    vm_static.cpu_pinning_policy,
    vm_dynamic.current_cpu_pinning,
    vm_dynamic.current_sockets,
    vm_dynamic.current_cores,
    vm_dynamic.current_threads,
    vm_dynamic.current_numa_pinning,
    vm_static.parallel_migrations
   FROM ((((((((((public.vm_static
     JOIN public.vm_dynamic ON ((vm_static.vm_guid = vm_dynamic.vm_guid)))
     JOIN public.vm_static vm_templates ON ((vm_static.vmt_guid = vm_templates.vm_guid)))
     JOIN public.vm_statistics ON ((vm_static.vm_guid = vm_statistics.vm_guid)))
     JOIN public.cluster ON ((vm_static.cluster_id = cluster.cluster_id)))
     LEFT JOIN public.storage_pool ON (((vm_static.cluster_id = cluster.cluster_id) AND (cluster.storage_pool_id = storage_pool.id))))
     LEFT JOIN public.quota ON ((vm_static.quota_id = quota.id)))
     LEFT JOIN public.vds_static ON ((vm_dynamic.run_on_vds = vds_static.vds_id)))
     LEFT JOIN public.vm_pool_map_view ON ((vm_static.vm_guid = vm_pool_map_view.vm_guid)))
     LEFT JOIN ( SELECT snapshots.vm_id,
            (count(
                CASE snapshots.snapshot_type
                    WHEN 'NEXT_RUN'::text THEN 1
                    ELSE NULL::integer
                END) > 0) AS next_run_config_exists,
            (count(
                CASE snapshots.snapshot_type
                    WHEN 'PREVIEW'::text THEN 1
                    ELSE NULL::integer
                END) > 0) AS is_previewing_snapshot,
            array_to_string(array_agg(snapshots.changed_fields), ''::text) AS changed_fields
           FROM public.snapshots
          WHERE (((snapshots.snapshot_type)::text = 'NEXT_RUN'::text) OR ((snapshots.snapshot_type)::text = 'PREVIEW'::text))
          GROUP BY snapshots.vm_id) vm_snapshots ON ((vm_static.vm_guid = vm_snapshots.vm_id)))
     LEFT JOIN ( SELECT disk_vm_element.vm_id,
            (count(
                CASE images.imagestatus
                    WHEN 4 THEN 1
                    ELSE NULL::integer
                END) > 0) AS has_illegal_images
           FROM (public.disk_vm_element
             JOIN public.images ON ((images.image_group_id = disk_vm_element.disk_id)))
          GROUP BY disk_vm_element.vm_id
         HAVING (bool_or(images.active) = true)) image_details ON ((image_details.vm_id = vm_static.vm_guid)))
  WHERE ((vm_static.entity_type)::text = 'VM'::text);


ALTER TABLE public.vms OWNER TO engine;

--
-- Name: getactivevmsbystoragedomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getactivevmsbystoragedomainid(v_storage_domain_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT DISTINCT vms.*
      FROM vms
      INNER JOIN vm_device vd ON vd.vm_id = vms.vm_guid
      INNER JOIN images i ON i.image_group_id = vd.device_id
      inner join image_storage_domain_map on i.image_guid = image_storage_domain_map.image_id
      WHERE status not in (0, 13)
      AND is_plugged = TRUE
      AND image_storage_domain_map.storage_domain_id = v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getactivevmsbystoragedomainid(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: affinity_group_members; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.affinity_group_members (
    affinity_group_id uuid NOT NULL,
    vm_id uuid,
    vds_id uuid,
    vm_label_id uuid,
    host_label_id uuid,
    CONSTRAINT affinity_group_member_not_all_null CHECK (((vm_id IS NOT NULL) OR (vds_id IS NOT NULL) OR (vm_label_id IS NOT NULL) OR (host_label_id IS NOT NULL)))
);


ALTER TABLE public.affinity_group_members OWNER TO engine;

--
-- Name: affinity_groups; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.affinity_groups (
    id uuid NOT NULL,
    name character varying(128) NOT NULL,
    description character varying(4000),
    cluster_id uuid NOT NULL,
    vm_positive boolean DEFAULT true,
    vm_enforcing boolean DEFAULT true NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    vds_positive boolean DEFAULT true NOT NULL,
    vds_enforcing boolean DEFAULT false NOT NULL,
    vms_affinity_enabled boolean DEFAULT true NOT NULL,
    vds_affinity_enabled boolean DEFAULT false NOT NULL,
    priority bigint DEFAULT 10000000 NOT NULL
);


ALTER TABLE public.affinity_groups OWNER TO engine;

--
-- Name: labels; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.labels (
    label_id uuid NOT NULL,
    label_name character varying(50) NOT NULL,
    read_only boolean DEFAULT false NOT NULL,
    has_implicit_affinity_group boolean DEFAULT false NOT NULL
);


ALTER TABLE public.labels OWNER TO engine;

--
-- Name: affinity_groups_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.affinity_groups_view AS
 SELECT affinity_groups.id,
    affinity_groups.name,
    affinity_groups.description,
    affinity_groups.cluster_id,
    affinity_groups.vm_positive,
    affinity_groups.vm_enforcing,
    affinity_groups._create_date,
    affinity_groups._update_date,
    affinity_groups.vds_positive,
    affinity_groups.vds_enforcing,
    affinity_groups.vms_affinity_enabled,
    affinity_groups.vds_affinity_enabled,
    affinity_groups.priority,
    array_agg((affinity_group_members.vm_id)::text) AS vm_ids,
    array_agg((vm_static.vm_name)::text) AS vm_names,
    array_agg((affinity_group_members.vds_id)::text) AS vds_ids,
    array_agg((vds_static.vds_name)::text) AS vds_names,
    array_agg((affinity_group_members.vm_label_id)::text) AS vm_label_ids,
    array_agg((vm_labels.label_name)::text) AS vm_label_names,
    array_agg((affinity_group_members.host_label_id)::text) AS host_label_ids,
    array_agg((vds_labels.label_name)::text) AS host_label_names
   FROM (((((public.affinity_groups
     LEFT JOIN public.affinity_group_members ON ((affinity_group_members.affinity_group_id = affinity_groups.id)))
     LEFT JOIN public.vm_static ON ((vm_static.vm_guid = affinity_group_members.vm_id)))
     LEFT JOIN public.vds_static ON ((vds_static.vds_id = affinity_group_members.vds_id)))
     LEFT JOIN public.labels vm_labels ON ((vm_labels.label_id = affinity_group_members.vm_label_id)))
     LEFT JOIN public.labels vds_labels ON ((vds_labels.label_id = affinity_group_members.host_label_id)))
  GROUP BY affinity_groups.id, affinity_groups.name, affinity_groups.description, affinity_groups.cluster_id, affinity_groups.vm_positive, affinity_groups.vm_enforcing, affinity_groups.vds_positive, affinity_groups.vds_enforcing, affinity_groups.vms_affinity_enabled, affinity_groups.vds_affinity_enabled, affinity_groups.priority, affinity_groups._create_date, affinity_groups._update_date;


ALTER TABLE public.affinity_groups_view OWNER TO engine;

--
-- Name: getaffinitygroupbyaffinitygroupid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getaffinitygroupbyaffinitygroupid(v_id uuid) RETURNS SETOF public.affinity_groups_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM affinity_groups_view
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getaffinitygroupbyaffinitygroupid(v_id uuid) OWNER TO engine;

--
-- Name: getaffinitygroupbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getaffinitygroupbyname(v_name character varying) RETURNS SETOF public.affinity_groups_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM affinity_groups_view
    WHERE name = v_name;
END;$$;


ALTER FUNCTION public.getaffinitygroupbyname(v_name character varying) OWNER TO engine;

--
-- Name: getallaffinitygroupsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallaffinitygroupsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.affinity_groups_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM affinity_groups_view
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getallaffinitygroupsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getallaffinitygroupsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallaffinitygroupsbyvmid(v_vm_id uuid) RETURNS SETOF public.affinity_groups_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT affinity_groups_view.*
    FROM affinity_groups_view
    INNER JOIN affinity_group_members
        ON v_vm_id = affinity_group_members.vm_id
            AND affinity_group_members.affinity_group_id = affinity_groups_view.id;
END;$$;


ALTER FUNCTION public.getallaffinitygroupsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: affinity_groups_with_members_from_labels_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.affinity_groups_with_members_from_labels_view AS
SELECT
    NULL::uuid AS id,
    NULL::character varying(128) AS name,
    NULL::character varying(4000) AS description,
    NULL::uuid AS cluster_id,
    NULL::boolean AS vm_positive,
    NULL::boolean AS vm_enforcing,
    NULL::timestamp with time zone AS _create_date,
    NULL::timestamp with time zone AS _update_date,
    NULL::boolean AS vds_positive,
    NULL::boolean AS vds_enforcing,
    NULL::boolean AS vms_affinity_enabled,
    NULL::boolean AS vds_affinity_enabled,
    NULL::bigint AS priority,
    NULL::text[] AS vm_ids,
    NULL::text[] AS vm_names,
    NULL::text[] AS vds_ids,
    NULL::text[] AS vds_names,
    NULL::text[] AS vm_label_ids,
    NULL::text[] AS vm_label_names,
    NULL::text[] AS host_label_ids,
    NULL::text[] AS host_label_names;


ALTER TABLE public.affinity_groups_with_members_from_labels_view OWNER TO engine;

--
-- Name: getallaffinitygroupswithflatlabelsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallaffinitygroupswithflatlabelsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.affinity_groups_with_members_from_labels_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM affinity_groups_with_members_from_labels_view
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getallaffinitygroupswithflatlabelsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getallaffinitygroupswithflatlabelsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallaffinitygroupswithflatlabelsbyvmid(v_vm_id uuid) RETURNS SETOF public.affinity_groups_with_members_from_labels_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT groups_view.*
    FROM affinity_groups_with_members_from_labels_view as groups_view
    INNER JOIN affinity_groups_members_flat_labels_view as members
        ON v_vm_id = members.vm_id
            AND members.affinity_group_id = groups_view.id;
END;$$;


ALTER FUNCTION public.getallaffinitygroupswithflatlabelsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: numa_node; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.numa_node (
    numa_node_id uuid NOT NULL,
    vds_id uuid,
    vm_id uuid,
    numa_node_index smallint,
    mem_total bigint,
    cpu_count smallint,
    mem_free bigint,
    usage_mem_percent integer,
    cpu_sys numeric(5,2),
    cpu_user numeric(5,2),
    cpu_idle numeric(5,2),
    usage_cpu_percent integer,
    distance text,
    hugepages text,
    numa_tune_mode character varying(20)
);


ALTER TABLE public.numa_node OWNER TO engine;

--
-- Name: vm_vds_numa_node_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_vds_numa_node_map (
    id uuid NOT NULL,
    vm_numa_node_id uuid NOT NULL,
    vds_numa_node_index smallint
);


ALTER TABLE public.vm_vds_numa_node_map OWNER TO engine;

--
-- Name: numa_node_assignment_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.numa_node_assignment_view AS
 SELECT vm_vds_numa_node_map.vm_numa_node_id AS assigned_vm_numa_node_id,
    vm_vds_numa_node_map.vds_numa_node_index AS run_in_vds_numa_node_index,
    vm_numa_node.vm_id AS vm_numa_node_vm_id,
    vm_numa_node.numa_node_index AS vm_numa_node_index,
    vm_numa_node.mem_total AS vm_numa_node_mem_total,
    vm_numa_node.cpu_count AS vm_numa_node_cpu_count,
    vm_numa_node.mem_free AS vm_numa_node_mem_free,
    vm_numa_node.usage_mem_percent AS vm_numa_node_usage_mem_percent,
    vm_numa_node.cpu_sys AS vm_numa_node_cpu_sys,
    vm_numa_node.cpu_user AS vm_numa_node_cpu_user,
    vm_numa_node.cpu_idle AS vm_numa_node_cpu_idle,
    vm_numa_node.usage_cpu_percent AS vm_numa_node_usage_cpu_percent,
    vm_numa_node.distance AS vm_numa_node_distance,
    vm_numa_node.hugepages AS vm_numa_node_hugepages,
    vm_numa_node.numa_tune_mode AS vm_numa_node_numa_tune_mode
   FROM (public.vm_vds_numa_node_map
     LEFT JOIN public.numa_node vm_numa_node ON ((vm_vds_numa_node_map.vm_numa_node_id = vm_numa_node.numa_node_id)));


ALTER TABLE public.numa_node_assignment_view OWNER TO engine;

--
-- Name: getallassignednumanodeinfomation(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallassignednumanodeinfomation() RETURNS SETOF public.numa_node_assignment_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT numa_node_assignment_view.*
        FROM numa_node_assignment_view;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getallassignednumanodeinfomation() OWNER TO engine;

--
-- Name: base_disks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.base_disks (
    disk_id uuid NOT NULL,
    wipe_after_delete boolean DEFAULT false NOT NULL,
    propagate_errors character varying(32) DEFAULT 'Off'::character varying NOT NULL,
    disk_alias character varying(255),
    disk_description character varying(500) DEFAULT ''::character varying NOT NULL,
    shareable boolean DEFAULT false,
    sgio smallint,
    disk_storage_type smallint,
    cinder_volume_type character varying(255),
    disk_content_type smallint DEFAULT 0 NOT NULL,
    backup character varying(32) DEFAULT 'None'::character varying,
    backup_mode character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.base_disks OWNER TO engine;

--
-- Name: disk_image_dynamic; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.disk_image_dynamic (
    image_id uuid NOT NULL,
    read_rate bigint,
    write_rate bigint,
    actual_size bigint NOT NULL,
    read_latency_seconds numeric(18,9),
    write_latency_seconds numeric(18,9),
    flush_latency_seconds numeric(18,9),
    _update_date timestamp with time zone,
    read_ops bigint DEFAULT 0,
    write_ops bigint DEFAULT 0
);


ALTER TABLE public.disk_image_dynamic OWNER TO engine;

--
-- Name: disk_lun_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.disk_lun_map (
    disk_id uuid NOT NULL,
    lun_id character varying NOT NULL
);


ALTER TABLE public.disk_lun_map OWNER TO engine;

--
-- Name: disk_profiles; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.disk_profiles (
    id uuid NOT NULL,
    name character varying(50) NOT NULL,
    storage_domain_id uuid NOT NULL,
    qos_id uuid,
    description text,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.disk_profiles OWNER TO engine;

--
-- Name: job; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.job (
    job_id uuid NOT NULL,
    action_type character varying(50) NOT NULL,
    description text NOT NULL,
    status character varying(32) NOT NULL,
    owner_id uuid,
    visible boolean DEFAULT true NOT NULL,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone,
    last_update_time timestamp with time zone,
    correlation_id character varying(50) NOT NULL,
    is_external boolean DEFAULT false,
    is_auto_cleared boolean DEFAULT true,
    engine_session_seq_id bigint
);


ALTER TABLE public.job OWNER TO engine;

--
-- Name: step; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.step (
    step_id uuid NOT NULL,
    parent_step_id uuid,
    job_id uuid NOT NULL,
    step_type character varying(32) NOT NULL,
    description text NOT NULL,
    step_number integer NOT NULL,
    status character varying(32) NOT NULL,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone,
    correlation_id character varying(50) NOT NULL,
    external_id uuid,
    external_system_type character varying(32),
    is_external boolean DEFAULT false,
    progress smallint
);


ALTER TABLE public.step OWNER TO engine;

--
-- Name: step_progress; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.step_progress AS
 SELECT s.step_id,
    s.job_id,
    COALESCE((s.progress)::integer,
        CASE s.status
            WHEN 'FINISHED'::text THEN 100
            ELSE NULL::integer
        END, 0) AS progress
   FROM public.step s;


ALTER TABLE public.step_progress OWNER TO engine;

--
-- Name: step_subject_entity; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.step_subject_entity (
    step_id uuid NOT NULL,
    entity_id uuid NOT NULL,
    entity_type character varying(32) NOT NULL,
    step_entity_weight smallint
);


ALTER TABLE public.step_subject_entity OWNER TO engine;

--
-- Name: entity_step_progress; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.entity_step_progress AS
 SELECT sse.entity_id,
    sum(((s.progress * sse.step_entity_weight) / 100)) AS progress
   FROM ((public.step_subject_entity sse
     JOIN public.step_progress s ON ((s.step_id = sse.step_id)))
     JOIN public.job j ON ((s.job_id = j.job_id)))
  WHERE ((sse.step_entity_weight IS NOT NULL) AND ((j.status)::text = 'STARTED'::text) AND (s.progress IS NOT NULL))
  GROUP BY sse.entity_id;


ALTER TABLE public.entity_step_progress OWNER TO engine;

--
-- Name: image_storage_domain_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.image_storage_domain_map (
    image_id uuid NOT NULL,
    storage_domain_id uuid NOT NULL,
    quota_id uuid,
    disk_profile_id uuid
);


ALTER TABLE public.image_storage_domain_map OWNER TO engine;

--
-- Name: image_transfers; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.image_transfers (
    command_id uuid NOT NULL,
    command_type integer NOT NULL,
    phase integer NOT NULL,
    last_updated timestamp with time zone NOT NULL,
    message character varying,
    vds_id uuid,
    disk_id uuid,
    imaged_ticket_id uuid,
    proxy_uri character varying,
    bytes_sent bigint,
    bytes_total bigint,
    type integer DEFAULT 0 NOT NULL,
    active boolean DEFAULT false NOT NULL,
    daemon_uri character varying,
    client_inactivity_timeout integer,
    image_format integer DEFAULT 0 NOT NULL,
    backend integer DEFAULT 0 NOT NULL,
    backup_id uuid,
    client_type smallint DEFAULT 0 NOT NULL,
    shallow boolean DEFAULT false NOT NULL,
    timeout_policy character varying(10) DEFAULT 'legacy'::character varying NOT NULL
);


ALTER TABLE public.image_transfers OWNER TO engine;

--
-- Name: storage_domain_static; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_domain_static (
    id uuid NOT NULL,
    storage character varying(250) NOT NULL,
    storage_name character varying(250) NOT NULL,
    storage_domain_type integer NOT NULL,
    storage_type integer NOT NULL,
    storage_domain_format_type character varying(50) DEFAULT '0'::character varying NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    recoverable boolean DEFAULT true NOT NULL,
    last_time_used_as_master bigint,
    storage_description character varying(4000) DEFAULT ''::character varying NOT NULL,
    storage_comment text DEFAULT ''::text NOT NULL,
    wipe_after_delete boolean DEFAULT false NOT NULL,
    warning_low_space_indicator integer,
    critical_space_action_blocker integer,
    first_metadata_device character varying(100) DEFAULT NULL::character varying,
    vg_metadata_device character varying(100) DEFAULT NULL::character varying,
    discard_after_delete boolean DEFAULT false NOT NULL,
    backup boolean DEFAULT false NOT NULL,
    warning_low_confirmed_space_indicator integer,
    block_size integer DEFAULT 512
);


ALTER TABLE public.storage_domain_static OWNER TO engine;

--
-- Name: storage_pool_iso_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_pool_iso_map (
    storage_id uuid NOT NULL,
    storage_pool_id uuid NOT NULL,
    status integer
);


ALTER TABLE public.storage_pool_iso_map OWNER TO engine;

--
-- Name: vm_device; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_device (
    device_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    type character varying(30) NOT NULL,
    device character varying(255) NOT NULL,
    address character varying(255) NOT NULL,
    spec_params text,
    is_managed boolean DEFAULT false NOT NULL,
    is_plugged boolean DEFAULT false NOT NULL,
    is_readonly boolean DEFAULT false NOT NULL,
    _create_date timestamp with time zone DEFAULT now(),
    _update_date timestamp with time zone,
    alias character varying(255) DEFAULT ''::character varying NOT NULL,
    custom_properties text,
    snapshot_id uuid,
    logical_name character varying(255),
    host_device character varying(255)
);


ALTER TABLE public.vm_device OWNER TO engine;

--
-- Name: vms_for_disk_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vms_for_disk_view AS
 SELECT array_agg(vm_static.vm_name) AS array_vm_names,
    vm_device.device_id,
    vm_static.entity_type,
    array_agg(vm_static.template_version_name) AS array_template_version_name
   FROM (public.vm_static
     JOIN public.vm_device ON ((vm_static.vm_guid = vm_device.vm_id)))
  WHERE ((vm_device.device)::text = 'disk'::text)
  GROUP BY vm_device.device_id, vm_static.entity_type;


ALTER TABLE public.vms_for_disk_view OWNER TO engine;

--
-- Name: images_storage_domain_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.images_storage_domain_view AS
 SELECT images.image_guid,
    storage_domain_static.storage_name,
    storage_pool_iso_map.storage_pool_id,
    storage_domain_static.storage_type,
    images.creation_date,
    images.size,
    images.it_guid,
    snap.description,
    snap.creation_date AS snapshot_creation_date,
    images.parentid,
    images.lastmodified,
    snap.app_list,
    image_storage_domain_map.storage_domain_id AS storage_id,
    images.vm_snapshot_id,
    images.volume_type,
    images.volume_format,
    images.qcow_compat,
    images.imagestatus,
    images.image_group_id,
    images.active,
    images.volume_classification,
    images.sequence_number,
    vms_for_disk_view.entity_type,
    array_to_string(vms_for_disk_view.array_vm_names, ','::text) AS vm_names,
    COALESCE(array_upper(vms_for_disk_view.array_vm_names, 1), 0) AS number_of_vms,
    array_to_string(vms_for_disk_view.array_template_version_name, ','::text) AS template_version_names,
    base_disks.disk_id,
    base_disks.disk_alias,
    base_disks.disk_description,
    base_disks.shareable,
    base_disks.wipe_after_delete,
    base_disks.propagate_errors,
    base_disks.sgio,
    base_disks.disk_content_type,
    base_disks.backup,
    base_disks.backup_mode,
    image_storage_domain_map.quota_id,
    quota.quota_name,
    storage_pool.quota_enforcement_type,
    image_storage_domain_map.disk_profile_id,
    disk_profiles.name AS disk_profile_name,
    disk_image_dynamic.actual_size,
    disk_image_dynamic.read_rate,
    disk_image_dynamic.read_ops,
    disk_image_dynamic.write_rate,
    disk_image_dynamic.write_ops,
    disk_image_dynamic.read_latency_seconds,
    disk_image_dynamic.write_latency_seconds,
    disk_image_dynamic.flush_latency_seconds,
    base_disks.disk_storage_type,
    base_disks.cinder_volume_type,
    image_transfers.phase AS image_transfer_phase,
    image_transfers.type AS image_transfer_type,
    image_transfers.bytes_sent AS image_transfer_bytes_sent,
    image_transfers.bytes_total AS image_transfer_bytes_total,
    entity_step_progress.progress
   FROM ((((((((((((public.images
     LEFT JOIN public.disk_image_dynamic ON ((images.image_guid = disk_image_dynamic.image_id)))
     LEFT JOIN public.base_disks ON ((images.image_group_id = base_disks.disk_id)))
     LEFT JOIN public.vms_for_disk_view ON ((vms_for_disk_view.device_id = images.image_group_id)))
     LEFT JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images.image_guid)))
     LEFT JOIN public.storage_domain_static ON ((image_storage_domain_map.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.snapshots snap ON ((images.vm_snapshot_id = snap.snapshot_id)))
     LEFT JOIN public.quota ON ((image_storage_domain_map.quota_id = quota.id)))
     LEFT JOIN public.disk_profiles ON ((image_storage_domain_map.disk_profile_id = disk_profiles.id)))
     LEFT JOIN public.storage_pool_iso_map ON ((storage_pool_iso_map.storage_id = storage_domain_static.id)))
     LEFT JOIN public.storage_pool ON ((storage_pool.id = storage_pool_iso_map.storage_pool_id)))
     LEFT JOIN public.image_transfers ON (((images.image_group_id = image_transfers.disk_id) AND (image_transfers.phase <> ALL (ARRAY[9, 10])))))
     LEFT JOIN public.entity_step_progress ON ((images.image_group_id = entity_step_progress.entity_id)))
  WHERE (images.image_guid <> '00000000-0000-0000-0000-000000000000'::uuid);


ALTER TABLE public.images_storage_domain_view OWNER TO engine;

--
-- Name: luns; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.luns (
    physical_volume_id character varying(50),
    lun_id character varying(255) NOT NULL,
    volume_group_id character varying(50) NOT NULL,
    serial character varying(4000),
    lun_mapping integer,
    vendor_id character varying(50),
    product_id character varying(50),
    device_size integer DEFAULT 0,
    discard_max_size bigint
);


ALTER TABLE public.luns OWNER TO engine;

--
-- Name: storage_for_image_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_for_image_view AS
 SELECT images.image_guid AS image_id,
    array_to_string(array_agg(storage_domain_static.id), ','::text) AS storage_id,
    array_to_string(array_agg(storage_domain_static.storage_type), ','::text) AS storage_type,
    array_to_string(array_agg(storage_domain_static.storage_name), ','::text) AS storage_name,
    array_to_string(array_agg(COALESCE((quota.id)::character varying, ''::character varying)), ','::text) AS quota_id,
    array_to_string(array_agg(COALESCE(quota.quota_name, ''::character varying)), ','::text) AS quota_name,
    array_to_string(array_agg(COALESCE((disk_profiles.id)::character varying, ''::character varying)), ','::text) AS disk_profile_id,
    array_to_string(array_agg(COALESCE(disk_profiles.name, ''::character varying)), ','::text) AS disk_profile_name
   FROM ((((public.images
     LEFT JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images.image_guid)))
     LEFT JOIN public.storage_domain_static ON ((image_storage_domain_map.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.quota ON ((image_storage_domain_map.quota_id = quota.id)))
     LEFT JOIN public.disk_profiles ON ((image_storage_domain_map.disk_profile_id = disk_profiles.id)))
  GROUP BY images.image_guid;


ALTER TABLE public.storage_for_image_view OWNER TO engine;

--
-- Name: all_disks_including_snapshots_and_memory; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.all_disks_including_snapshots_and_memory AS
 SELECT storage_impl.storage_id,
    storage_impl.storage_name,
    storage_impl.storage_type,
    storage_impl.storage_pool_id,
    storage_impl.image_guid,
    storage_impl.creation_date,
    storage_impl.actual_size,
    storage_impl.read_rate,
    storage_impl.read_ops,
    storage_impl.write_rate,
    storage_impl.write_ops,
    storage_impl.read_latency_seconds,
    storage_impl.write_latency_seconds,
    storage_impl.flush_latency_seconds,
    storage_impl.size,
    storage_impl.it_guid,
    storage_impl.imagestatus,
    storage_impl.lastmodified,
    storage_impl.volume_type,
    storage_impl.volume_format,
    storage_impl.qcow_compat,
    storage_impl.image_group_id,
    storage_impl.description,
    storage_impl.parentid,
    storage_impl.app_list,
    storage_impl.vm_snapshot_id,
    storage_impl.active,
    storage_impl.volume_classification,
    storage_impl.sequence_number,
    storage_impl.entity_type,
    storage_impl.number_of_vms,
    storage_impl.vm_names,
    storage_impl.template_version_names,
    storage_impl.quota_id,
    storage_impl.quota_name,
    storage_impl.quota_enforcement_type,
    storage_impl.image_transfer_phase,
    storage_impl.image_transfer_type,
    storage_impl.image_transfer_bytes_sent,
    storage_impl.image_transfer_bytes_total,
    storage_impl.progress,
    storage_impl.disk_profile_id,
    storage_impl.disk_profile_name,
    storage_impl.lun_id,
    storage_impl.physical_volume_id,
    storage_impl.volume_group_id,
    storage_impl.serial,
    storage_impl.lun_mapping,
    storage_impl.vendor_id,
    storage_impl.product_id,
    storage_impl.device_size,
    storage_impl.discard_max_size,
    bd.disk_id,
    bd.wipe_after_delete,
    bd.propagate_errors,
    bd.disk_alias,
    bd.disk_description,
    bd.shareable,
    bd.sgio,
    bd.disk_storage_type,
    bd.cinder_volume_type,
    bd.disk_content_type,
    bd.backup,
    bd.backup_mode
   FROM (( SELECT storage_for_image_view.storage_id,
            storage_for_image_view.storage_name,
            storage_for_image_view.storage_type,
            images_storage_domain_view.storage_pool_id,
            images_storage_domain_view.image_guid,
            images_storage_domain_view.creation_date,
            images_storage_domain_view.actual_size,
            images_storage_domain_view.read_rate,
            images_storage_domain_view.read_ops,
            images_storage_domain_view.write_rate,
            images_storage_domain_view.write_ops,
            images_storage_domain_view.read_latency_seconds,
            images_storage_domain_view.write_latency_seconds,
            images_storage_domain_view.flush_latency_seconds,
            images_storage_domain_view.size,
            images_storage_domain_view.it_guid,
            images_storage_domain_view.imagestatus,
            images_storage_domain_view.lastmodified,
            images_storage_domain_view.volume_type,
            images_storage_domain_view.volume_format,
            images_storage_domain_view.qcow_compat,
            images_storage_domain_view.image_group_id,
            images_storage_domain_view.description,
            images_storage_domain_view.parentid,
            images_storage_domain_view.app_list,
            images_storage_domain_view.vm_snapshot_id,
            images_storage_domain_view.active,
            images_storage_domain_view.volume_classification,
            images_storage_domain_view.sequence_number,
            images_storage_domain_view.entity_type,
            images_storage_domain_view.number_of_vms,
            images_storage_domain_view.vm_names,
            images_storage_domain_view.template_version_names,
            storage_for_image_view.quota_id,
            storage_for_image_view.quota_name,
            images_storage_domain_view.quota_enforcement_type,
            images_storage_domain_view.image_transfer_phase,
            images_storage_domain_view.image_transfer_type,
            images_storage_domain_view.image_transfer_bytes_sent,
            images_storage_domain_view.image_transfer_bytes_total,
            images_storage_domain_view.progress,
            storage_for_image_view.disk_profile_id,
            storage_for_image_view.disk_profile_name,
            NULL::character varying AS lun_id,
            NULL::character varying AS physical_volume_id,
            NULL::character varying AS volume_group_id,
            NULL::character varying AS serial,
            NULL::integer AS lun_mapping,
            NULL::character varying AS vendor_id,
            NULL::character varying AS product_id,
            NULL::integer AS device_size,
            NULL::bigint AS discard_max_size
           FROM (public.images_storage_domain_view
             JOIN public.storage_for_image_view ON ((images_storage_domain_view.image_guid = storage_for_image_view.image_id)))
          GROUP BY storage_for_image_view.storage_id, storage_for_image_view.storage_name, storage_for_image_view.storage_type, images_storage_domain_view.storage_pool_id, images_storage_domain_view.image_guid, images_storage_domain_view.creation_date, images_storage_domain_view.actual_size, images_storage_domain_view.read_rate, images_storage_domain_view.read_ops, images_storage_domain_view.write_rate, images_storage_domain_view.write_ops, images_storage_domain_view.read_latency_seconds, images_storage_domain_view.write_latency_seconds, images_storage_domain_view.flush_latency_seconds, images_storage_domain_view.size, images_storage_domain_view.it_guid, images_storage_domain_view.imagestatus, images_storage_domain_view.lastmodified, images_storage_domain_view.volume_type, images_storage_domain_view.volume_format, images_storage_domain_view.qcow_compat, images_storage_domain_view.image_group_id, images_storage_domain_view.description, images_storage_domain_view.parentid, images_storage_domain_view.app_list, images_storage_domain_view.vm_snapshot_id, images_storage_domain_view.active, images_storage_domain_view.volume_classification, images_storage_domain_view.sequence_number, images_storage_domain_view.entity_type, images_storage_domain_view.number_of_vms, images_storage_domain_view.vm_names, images_storage_domain_view.template_version_names, storage_for_image_view.quota_id, storage_for_image_view.quota_name, images_storage_domain_view.quota_enforcement_type, images_storage_domain_view.image_transfer_phase, images_storage_domain_view.image_transfer_type, images_storage_domain_view.image_transfer_bytes_sent, images_storage_domain_view.image_transfer_bytes_total, images_storage_domain_view.progress, storage_for_image_view.disk_profile_id, storage_for_image_view.disk_profile_name
        UNION ALL
         SELECT NULL::text AS storage_id,
            NULL::text AS storage_name,
            NULL::text AS storage_type,
            NULL::uuid AS storage_pool_id,
            NULL::uuid AS image_guid,
            NULL::timestamp with time zone AS creation_date,
            NULL::bigint AS actual_size,
            NULL::bigint AS read_rate,
            NULL::bigint AS read_ops,
            NULL::bigint AS write_rate,
            NULL::bigint AS write_ops,
            NULL::numeric AS read_latency_seconds,
            NULL::numeric AS write_latency_seconds,
            NULL::numeric AS flush_latency_seconds,
            NULL::bigint AS size,
            NULL::uuid AS it_guid,
            NULL::integer AS imagestatus,
            NULL::timestamp with time zone AS lastmodified,
            NULL::integer AS volume_type,
            NULL::integer AS volume_format,
            NULL::integer AS qcow_compat,
            dlm.disk_id AS image_group_id,
            NULL::character varying AS description,
            NULL::uuid AS parentid,
            NULL::text AS app_list,
            NULL::uuid AS vm_snapshot_id,
            NULL::boolean AS active,
            NULL::smallint AS volume_classification,
            NULL::integer AS sequence_number,
            vms_for_disk_view.entity_type,
            COALESCE(array_upper(vms_for_disk_view.array_vm_names, 1), 0) AS number_of_vms,
            array_to_string(vms_for_disk_view.array_vm_names, ','::text) AS vm_names,
            array_to_string(vms_for_disk_view.array_template_version_name, ','::text) AS template_version_names,
            NULL::text AS quota_id,
            NULL::text AS quota_name,
            NULL::integer AS quota_enforcement_type,
            NULL::integer AS image_transfer_phase,
            NULL::integer AS image_transfer_type,
            NULL::bigint AS image_transfer_bytes_sent,
            NULL::bigint AS image_transfer_bytes_total,
            NULL::bigint AS progress,
            NULL::text AS disk_profile_id,
            NULL::text AS disk_profile_name,
            l.lun_id,
            l.physical_volume_id,
            l.volume_group_id,
            l.serial,
            l.lun_mapping,
            l.vendor_id,
            l.product_id,
            l.device_size,
            l.discard_max_size
           FROM ((public.disk_lun_map dlm
             JOIN public.luns l ON (((l.lun_id)::text = (dlm.lun_id)::text)))
             LEFT JOIN public.vms_for_disk_view ON ((vms_for_disk_view.device_id = dlm.disk_id)))) storage_impl
     JOIN public.base_disks bd ON ((bd.disk_id = storage_impl.image_group_id)));


ALTER TABLE public.all_disks_including_snapshots_and_memory OWNER TO engine;

--
-- Name: all_disks; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.all_disks AS
 SELECT all_disks_including_snapshots_and_memory.storage_id,
    all_disks_including_snapshots_and_memory.storage_name,
    all_disks_including_snapshots_and_memory.storage_type,
    all_disks_including_snapshots_and_memory.storage_pool_id,
    all_disks_including_snapshots_and_memory.image_guid,
    all_disks_including_snapshots_and_memory.creation_date,
    all_disks_including_snapshots_and_memory.actual_size,
    all_disks_including_snapshots_and_memory.read_rate,
    all_disks_including_snapshots_and_memory.read_ops,
    all_disks_including_snapshots_and_memory.write_rate,
    all_disks_including_snapshots_and_memory.write_ops,
    all_disks_including_snapshots_and_memory.read_latency_seconds,
    all_disks_including_snapshots_and_memory.write_latency_seconds,
    all_disks_including_snapshots_and_memory.flush_latency_seconds,
    all_disks_including_snapshots_and_memory.size,
    all_disks_including_snapshots_and_memory.it_guid,
    all_disks_including_snapshots_and_memory.imagestatus,
    all_disks_including_snapshots_and_memory.lastmodified,
    all_disks_including_snapshots_and_memory.volume_type,
    all_disks_including_snapshots_and_memory.volume_format,
    all_disks_including_snapshots_and_memory.qcow_compat,
    all_disks_including_snapshots_and_memory.image_group_id,
    all_disks_including_snapshots_and_memory.description,
    all_disks_including_snapshots_and_memory.parentid,
    all_disks_including_snapshots_and_memory.app_list,
    all_disks_including_snapshots_and_memory.vm_snapshot_id,
    all_disks_including_snapshots_and_memory.active,
    all_disks_including_snapshots_and_memory.volume_classification,
    all_disks_including_snapshots_and_memory.sequence_number,
    all_disks_including_snapshots_and_memory.entity_type,
    all_disks_including_snapshots_and_memory.number_of_vms,
    all_disks_including_snapshots_and_memory.vm_names,
    all_disks_including_snapshots_and_memory.template_version_names,
    all_disks_including_snapshots_and_memory.quota_id,
    all_disks_including_snapshots_and_memory.quota_name,
    all_disks_including_snapshots_and_memory.quota_enforcement_type,
    all_disks_including_snapshots_and_memory.image_transfer_phase,
    all_disks_including_snapshots_and_memory.image_transfer_type,
    all_disks_including_snapshots_and_memory.image_transfer_bytes_sent,
    all_disks_including_snapshots_and_memory.image_transfer_bytes_total,
    all_disks_including_snapshots_and_memory.progress,
    all_disks_including_snapshots_and_memory.disk_profile_id,
    all_disks_including_snapshots_and_memory.disk_profile_name,
    all_disks_including_snapshots_and_memory.lun_id,
    all_disks_including_snapshots_and_memory.physical_volume_id,
    all_disks_including_snapshots_and_memory.volume_group_id,
    all_disks_including_snapshots_and_memory.serial,
    all_disks_including_snapshots_and_memory.lun_mapping,
    all_disks_including_snapshots_and_memory.vendor_id,
    all_disks_including_snapshots_and_memory.product_id,
    all_disks_including_snapshots_and_memory.device_size,
    all_disks_including_snapshots_and_memory.discard_max_size,
    all_disks_including_snapshots_and_memory.disk_id,
    all_disks_including_snapshots_and_memory.wipe_after_delete,
    all_disks_including_snapshots_and_memory.propagate_errors,
    all_disks_including_snapshots_and_memory.disk_alias,
    all_disks_including_snapshots_and_memory.disk_description,
    all_disks_including_snapshots_and_memory.shareable,
    all_disks_including_snapshots_and_memory.sgio,
    all_disks_including_snapshots_and_memory.disk_storage_type,
    all_disks_including_snapshots_and_memory.cinder_volume_type,
    all_disks_including_snapshots_and_memory.disk_content_type,
    all_disks_including_snapshots_and_memory.backup,
    all_disks_including_snapshots_and_memory.backup_mode
   FROM public.all_disks_including_snapshots_and_memory
  WHERE ((all_disks_including_snapshots_and_memory.active IS NULL) OR (all_disks_including_snapshots_and_memory.active = true));


ALTER TABLE public.all_disks OWNER TO engine;

--
-- Name: getallattachabledisksbypoolid(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallattachabledisksbypoolid(v_storage_pool_id uuid, v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT all_disks.*
    FROM all_disks
    WHERE (
            v_storage_pool_id IS NULL
            OR all_disks.storage_pool_id = v_storage_pool_id
            )
        AND (
            all_disks.number_of_vms = 0
            OR all_disks.shareable
            )
        -- ImageStatus.ILLEGAL=4 / imagestatus IS NULL -> LunDiski / ImageStatus.Locked=2
        AND (
            all_disks.imagestatus IS NULL
            OR (
                all_disks.imagestatus != 4
                AND all_disks.imagestatus != 2
                )
            )
        AND all_disks.disk_content_type = 0 -- Allow attaching of data disks only
        AND (
            v_vm_id IS NULL
            OR v_vm_id NOT IN (
                SELECT vm_id
                FROM vm_device
                WHERE vm_device.device_id = all_disks.image_group_id
                )
            )
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getallattachabledisksbypoolid(v_storage_pool_id uuid, v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallbystatus(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallbystatus(v_status integer) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE status = v_status;
END;$$;


ALTER FUNCTION public.getallbystatus(v_status integer) OWNER TO engine;

--
-- Name: getallclustersbydefaultnetworkproviderid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallclustersbydefaultnetworkproviderid(v_id uuid) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cv.*
    FROM cluster_view cv
    WHERE cv.default_network_provider_id = v_id;
END;$$;


ALTER FUNCTION public.getallclustersbydefaultnetworkproviderid(v_id uuid) OWNER TO engine;

--
-- Name: getallclustersbymacpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallclustersbymacpoolid(v_id uuid) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cv.*
    FROM cluster_view cv
    WHERE cv.mac_pool_id = v_id;
END;$$;


ALTER FUNCTION public.getallclustersbymacpoolid(v_id uuid) OWNER TO engine;

--
-- Name: qos; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.qos (
    id uuid NOT NULL,
    qos_type smallint NOT NULL,
    name character varying(50),
    description text,
    storage_pool_id uuid,
    max_throughput integer,
    max_read_throughput integer,
    max_write_throughput integer,
    max_iops integer,
    max_read_iops integer,
    max_write_iops integer,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    cpu_limit smallint,
    inbound_average integer,
    inbound_peak integer,
    inbound_burst integer,
    outbound_average integer,
    outbound_peak integer,
    outbound_burst integer,
    out_average_linkshare integer,
    out_average_upperlimit integer,
    out_average_realtime integer
);


ALTER TABLE public.qos OWNER TO engine;

--
-- Name: getallcpuqos(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallcpuqos(v_user_id uuid) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
      FROM qos WHERE
        qos_type = 2 AND
        EXISTS (
            SELECT 1
            FROM cpu_profiles
            INNER JOIN user_cluster_permissions_view
                ON cpu_profiles.cluster_id = user_cluster_permissions_view.entity_id
            WHERE cpu_profiles.qos_id = qos.id
                AND user_cluster_permissions_view.user_id = v_user_id
        );

END;$$;


ALTER FUNCTION public.getallcpuqos(v_user_id uuid) OWNER TO engine;

--
-- Name: getallfordiskprofiles(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfordiskprofiles(v_disk_profile_ids uuid[]) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT images_storage_domain_view.*
        FROM images_storage_domain_view
        WHERE images_storage_domain_view.disk_profile_id = ANY(v_disk_profile_ids);
END; $$;


ALTER FUNCTION public.getallfordiskprofiles(v_disk_profile_ids uuid[]) OWNER TO engine;

--
-- Name: getallforstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallforstoragedomain(v_storage_domain_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT images_storage_domain_view.*
     FROM  images_storage_domain_view
     WHERE active AND images_storage_domain_view.storage_id = v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getallforstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getallforstoragepool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallforstoragepool(v_storage_pool_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT *
             FROM vms
             WHERE storage_pool_id = v_storage_pool_id;
END; $$;


ALTER FUNCTION public.getallforstoragepool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getallfromaffinitygroups(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromaffinitygroups() RETURNS SETOF public.affinity_groups_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT affinity_groups_view.*
    FROM affinity_groups_view;
END;$$;


ALTER FUNCTION public.getallfromaffinitygroups() OWNER TO engine;

--
-- Name: async_tasks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.async_tasks (
    task_id uuid NOT NULL,
    action_type integer NOT NULL,
    status integer NOT NULL,
    result integer NOT NULL,
    step_id uuid,
    command_id uuid NOT NULL,
    started_at timestamp with time zone,
    storage_pool_id uuid,
    task_type integer DEFAULT 0 NOT NULL,
    vdsm_task_id uuid,
    root_command_id uuid,
    user_id uuid
);


ALTER TABLE public.async_tasks OWNER TO engine;

--
-- Name: getallfromasync_tasks(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromasync_tasks() RETURNS SETOF public.async_tasks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM async_tasks;
END;$$;


ALTER FUNCTION public.getallfromasync_tasks() OWNER TO engine;

--
-- Name: audit_log_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.audit_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.audit_log_seq OWNER TO engine;

--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.audit_log (
    audit_log_id bigint DEFAULT nextval('public.audit_log_seq'::regclass) NOT NULL,
    user_id uuid,
    user_name character varying(255) DEFAULT ''::character varying NOT NULL,
    vm_id uuid,
    vm_name character varying(255) DEFAULT ''::character varying NOT NULL,
    vm_template_id uuid,
    vm_template_name character varying(255) DEFAULT ''::character varying NOT NULL,
    vds_id uuid,
    vds_name character varying(255) DEFAULT ''::character varying NOT NULL,
    log_time timestamp with time zone NOT NULL,
    log_type_name character varying(100) DEFAULT ''::character varying,
    log_type integer NOT NULL,
    severity integer NOT NULL,
    message text NOT NULL,
    processed boolean DEFAULT false NOT NULL,
    storage_pool_id uuid,
    storage_pool_name character varying(40) DEFAULT ''::character varying NOT NULL,
    storage_domain_id uuid,
    storage_domain_name character varying(250) DEFAULT ''::character varying NOT NULL,
    cluster_id uuid,
    cluster_name character varying(255) DEFAULT ''::character varying NOT NULL,
    correlation_id character varying(50),
    job_id uuid,
    quota_id uuid,
    quota_name character varying(60) DEFAULT ''::character varying NOT NULL,
    gluster_volume_id uuid,
    gluster_volume_name character varying(1000) DEFAULT ''::character varying NOT NULL,
    origin character varying(255) DEFAULT 'oVirt'::character varying,
    custom_event_id integer DEFAULT '-1'::integer,
    event_flood_in_sec integer DEFAULT 30,
    custom_data text DEFAULT ''::text,
    deleted boolean DEFAULT false,
    call_stack text DEFAULT ''::text,
    brick_id uuid,
    brick_path text DEFAULT ''::text,
    custom_id character varying(255)
);


ALTER TABLE public.audit_log OWNER TO engine;

--
-- Name: getallfromauditlog(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromauditlog(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log a
    WHERE NOT deleted
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.vm_id
                    AND pv.entity_id = dpv.entity_id
                )
            OR EXISTS (
                SELECT 1
                FROM user_vm_template_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.vm_template_id
                    AND pv.entity_id = dpv.entity_id
                )
            OR EXISTS (
                SELECT 1
                FROM user_vds_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.vds_id
                    AND pv.entity_id = dpv.entity_id
                )
            OR EXISTS (
                SELECT 1
                FROM user_storage_pool_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.storage_pool_id
                    AND pv.entity_id = dpv.entity_id
                )
            OR EXISTS (
                SELECT 1
                FROM user_storage_domain_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.storage_domain_id
                    AND pv.entity_id = dpv.entity_id
                )
            OR EXISTS (
                SELECT 1
                FROM user_cluster_permissions_view pv,
                    user_object_permissions_view dpv
                WHERE pv.user_id = v_user_id
                    AND pv.entity_id = a.cluster_id
                    AND pv.entity_id = dpv.entity_id
                )
            )
    ORDER BY audit_log_id DESC;
END;$$;


ALTER FUNCTION public.getallfromauditlog(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfrombasedisks(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfrombasedisks() RETURNS SETOF public.base_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM base_disks;
END;$$;


ALTER FUNCTION public.getallfrombasedisks() OWNER TO engine;

--
-- Name: bookmarks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.bookmarks (
    bookmark_id uuid NOT NULL,
    bookmark_name character varying(40),
    bookmark_value character varying(300) NOT NULL
);


ALTER TABLE public.bookmarks OWNER TO engine;

--
-- Name: getallfrombookmarks(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfrombookmarks() RETURNS SETOF public.bookmarks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM bookmarks;
END;$$;


ALTER FUNCTION public.getallfrombookmarks() OWNER TO engine;

--
-- Name: getallfromcluster(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromcluster(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_cluster_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = cluster_id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromcluster(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromclusterpolicys(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromclusterpolicys() RETURNS SETOF public.cluster_policies
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cluster_policies;
END;$$;


ALTER FUNCTION public.getallfromclusterpolicys() OWNER TO engine;

--
-- Name: cluster_policy_units; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cluster_policy_units (
    cluster_policy_id uuid,
    policy_unit_id uuid,
    filter_sequence integer DEFAULT 0,
    factor integer DEFAULT 1
);


ALTER TABLE public.cluster_policy_units OWNER TO engine;

--
-- Name: getallfromclusterpolicyunits(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromclusterpolicyunits() RETURNS SETOF public.cluster_policy_units
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cluster_policy_units;
END;$$;


ALTER FUNCTION public.getallfromclusterpolicyunits() OWNER TO engine;

--
-- Name: command_entities; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.command_entities (
    command_id uuid NOT NULL,
    command_type integer NOT NULL,
    root_command_id uuid,
    command_parameters text,
    command_params_class character varying(256),
    created_at timestamp with time zone,
    status character varying(20) DEFAULT NULL::character varying,
    callback_enabled boolean DEFAULT false,
    callback_notified boolean DEFAULT false,
    return_value text,
    return_value_class character varying(256),
    executed boolean DEFAULT false,
    user_id uuid,
    parent_command_id uuid,
    data text,
    engine_session_seq_id bigint,
    command_context text
);


ALTER TABLE public.command_entities OWNER TO engine;

--
-- Name: getallfromcommandentities(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromcommandentities() RETURNS SETOF public.command_entities
    LANGUAGE plpgsql
    AS $$

BEGIN
    RETURN QUERY

    SELECT *
    FROM command_entities;
END;$$;


ALTER FUNCTION public.getallfromcommandentities() OWNER TO engine;

--
-- Name: cpu_profiles; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cpu_profiles (
    id uuid NOT NULL,
    name character varying(50) NOT NULL,
    cluster_id uuid NOT NULL,
    qos_id uuid,
    description text,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.cpu_profiles OWNER TO engine;

--
-- Name: getallfromcpuprofiles(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromcpuprofiles() RETURNS SETOF public.cpu_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cpu_profiles;
END;$$;


ALTER FUNCTION public.getallfromcpuprofiles() OWNER TO engine;

--
-- Name: custom_actions_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.custom_actions_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custom_actions_seq OWNER TO engine;

--
-- Name: custom_actions; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.custom_actions (
    action_id integer DEFAULT nextval('public.custom_actions_seq'::regclass) NOT NULL,
    action_name character varying(50) NOT NULL,
    path character varying(300) NOT NULL,
    tab integer NOT NULL,
    description character varying(4000)
);


ALTER TABLE public.custom_actions OWNER TO engine;

--
-- Name: getallfromcustom_actions(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromcustom_actions() RETURNS SETOF public.custom_actions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM custom_actions;
END;$$;


ALTER FUNCTION public.getallfromcustom_actions() OWNER TO engine;

--
-- Name: getallfromdisk_image_dynamic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdisk_image_dynamic() RETURNS SETOF public.disk_image_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_image_dynamic;
END;$$;


ALTER FUNCTION public.getallfromdisk_image_dynamic() OWNER TO engine;

--
-- Name: getallfromdisklunmaps(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdisklunmaps() RETURNS SETOF public.disk_lun_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_lun_map;
END;$$;


ALTER FUNCTION public.getallfromdisklunmaps() OWNER TO engine;

--
-- Name: getallfromdiskprofiles(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdiskprofiles() RETURNS SETOF public.disk_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_profiles;
END;$$;


ALTER FUNCTION public.getallfromdiskprofiles() OWNER TO engine;

--
-- Name: getallfromdisks(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdisks(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks
    WHERE (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromdisks(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromdisksbydiskstoragetype(smallint, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdisksbydiskstoragetype(v_disk_storage_type smallint, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks
    WHERE disk_storage_type = v_disk_storage_type
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromdisksbydiskstoragetype(v_disk_storage_type smallint, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: all_disks_including_snapshots; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.all_disks_including_snapshots AS
 SELECT storage_impl.storage_id,
    storage_impl.storage_name,
    storage_impl.storage_type,
    storage_impl.storage_pool_id,
    storage_impl.image_guid,
    storage_impl.creation_date,
    storage_impl.actual_size,
    storage_impl.read_rate,
    storage_impl.read_ops,
    storage_impl.write_rate,
    storage_impl.write_ops,
    storage_impl.read_latency_seconds,
    storage_impl.write_latency_seconds,
    storage_impl.flush_latency_seconds,
    storage_impl.size,
    storage_impl.it_guid,
    storage_impl.imagestatus,
    storage_impl.lastmodified,
    storage_impl.volume_type,
    storage_impl.volume_format,
    storage_impl.qcow_compat,
    storage_impl.image_group_id,
    storage_impl.description,
    storage_impl.parentid,
    storage_impl.app_list,
    storage_impl.vm_snapshot_id,
    storage_impl.active,
    storage_impl.volume_classification,
    storage_impl.sequence_number,
    storage_impl.entity_type,
    storage_impl.number_of_vms,
    storage_impl.vm_names,
    storage_impl.template_version_names,
    storage_impl.quota_id,
    storage_impl.quota_name,
    storage_impl.quota_enforcement_type,
    storage_impl.image_transfer_phase,
    storage_impl.image_transfer_type,
    storage_impl.image_transfer_bytes_sent,
    storage_impl.image_transfer_bytes_total,
    storage_impl.progress,
    storage_impl.disk_profile_id,
    storage_impl.disk_profile_name,
    storage_impl.lun_id,
    storage_impl.physical_volume_id,
    storage_impl.volume_group_id,
    storage_impl.serial,
    storage_impl.lun_mapping,
    storage_impl.vendor_id,
    storage_impl.product_id,
    storage_impl.device_size,
    storage_impl.discard_max_size,
    bd.disk_id,
    bd.wipe_after_delete,
    bd.propagate_errors,
    bd.disk_alias,
    bd.disk_description,
    bd.shareable,
    bd.sgio,
    bd.disk_storage_type,
    bd.cinder_volume_type,
    bd.disk_content_type,
    bd.backup,
    bd.backup_mode
   FROM (( SELECT storage_for_image_view.storage_id,
            storage_for_image_view.storage_name,
            storage_for_image_view.storage_type,
            images_storage_domain_view.storage_pool_id,
            images_storage_domain_view.image_guid,
            images_storage_domain_view.creation_date,
            images_storage_domain_view.actual_size,
            images_storage_domain_view.read_rate,
            images_storage_domain_view.read_ops,
            images_storage_domain_view.write_rate,
            images_storage_domain_view.write_ops,
            images_storage_domain_view.read_latency_seconds,
            images_storage_domain_view.write_latency_seconds,
            images_storage_domain_view.flush_latency_seconds,
            images_storage_domain_view.size,
            images_storage_domain_view.it_guid,
            images_storage_domain_view.imagestatus,
            images_storage_domain_view.lastmodified,
            images_storage_domain_view.volume_type,
            images_storage_domain_view.volume_format,
            images_storage_domain_view.qcow_compat,
            images_storage_domain_view.image_group_id,
            images_storage_domain_view.description,
            images_storage_domain_view.parentid,
            images_storage_domain_view.app_list,
            images_storage_domain_view.vm_snapshot_id,
            images_storage_domain_view.active,
            images_storage_domain_view.volume_classification,
            images_storage_domain_view.sequence_number,
            images_storage_domain_view.entity_type,
            images_storage_domain_view.number_of_vms,
            images_storage_domain_view.vm_names,
            images_storage_domain_view.template_version_names,
            storage_for_image_view.quota_id,
            storage_for_image_view.quota_name,
            images_storage_domain_view.quota_enforcement_type,
            images_storage_domain_view.image_transfer_phase,
            images_storage_domain_view.image_transfer_type,
            images_storage_domain_view.image_transfer_bytes_sent,
            images_storage_domain_view.image_transfer_bytes_total,
            images_storage_domain_view.progress,
            storage_for_image_view.disk_profile_id,
            storage_for_image_view.disk_profile_name,
            NULL::character varying AS lun_id,
            NULL::character varying AS physical_volume_id,
            NULL::character varying AS volume_group_id,
            NULL::character varying AS serial,
            NULL::integer AS lun_mapping,
            NULL::character varying AS vendor_id,
            NULL::character varying AS product_id,
            NULL::integer AS device_size,
            NULL::bigint AS discard_max_size
           FROM (public.images_storage_domain_view
             JOIN public.storage_for_image_view ON ((images_storage_domain_view.image_guid = storage_for_image_view.image_id)))
          GROUP BY storage_for_image_view.storage_id, storage_for_image_view.storage_name, storage_for_image_view.storage_type, images_storage_domain_view.storage_pool_id, images_storage_domain_view.image_guid, images_storage_domain_view.creation_date, images_storage_domain_view.actual_size, images_storage_domain_view.read_rate, images_storage_domain_view.read_ops, images_storage_domain_view.write_rate, images_storage_domain_view.write_ops, images_storage_domain_view.read_latency_seconds, images_storage_domain_view.write_latency_seconds, images_storage_domain_view.flush_latency_seconds, images_storage_domain_view.size, images_storage_domain_view.it_guid, images_storage_domain_view.imagestatus, images_storage_domain_view.lastmodified, images_storage_domain_view.volume_type, images_storage_domain_view.volume_format, images_storage_domain_view.qcow_compat, images_storage_domain_view.image_group_id, images_storage_domain_view.description, images_storage_domain_view.parentid, images_storage_domain_view.app_list, images_storage_domain_view.vm_snapshot_id, images_storage_domain_view.active, images_storage_domain_view.volume_classification, images_storage_domain_view.sequence_number, images_storage_domain_view.entity_type, images_storage_domain_view.number_of_vms, images_storage_domain_view.vm_names, images_storage_domain_view.template_version_names, storage_for_image_view.quota_id, storage_for_image_view.quota_name, images_storage_domain_view.quota_enforcement_type, images_storage_domain_view.image_transfer_phase, images_storage_domain_view.image_transfer_type, images_storage_domain_view.image_transfer_bytes_sent, images_storage_domain_view.image_transfer_bytes_total, images_storage_domain_view.progress, storage_for_image_view.disk_profile_id, storage_for_image_view.disk_profile_name
        UNION ALL
         SELECT NULL::text AS storage_id,
            NULL::text AS storage_name,
            NULL::text AS storage_type,
            NULL::uuid AS storage_pool_id,
            NULL::uuid AS image_guid,
            NULL::timestamp with time zone AS creation_date,
            NULL::bigint AS actual_size,
            NULL::bigint AS read_rate,
            NULL::bigint AS read_ops,
            NULL::bigint AS write_rate,
            NULL::bigint AS write_ops,
            NULL::numeric AS read_latency_seconds,
            NULL::numeric AS write_latency_seconds,
            NULL::numeric AS flush_latency_seconds,
            NULL::bigint AS size,
            NULL::uuid AS it_guid,
            NULL::integer AS imagestatus,
            NULL::timestamp with time zone AS lastmodified,
            NULL::integer AS volume_type,
            NULL::integer AS volume_format,
            NULL::integer AS qcow_compat,
            dlm.disk_id AS image_group_id,
            NULL::character varying AS description,
            NULL::uuid AS parentid,
            NULL::text AS app_list,
            NULL::uuid AS vm_snapshot_id,
            NULL::boolean AS active,
            NULL::smallint AS volume_classification,
            NULL::integer AS sequence_number,
            vms_for_disk_view.entity_type,
            COALESCE(array_upper(vms_for_disk_view.array_vm_names, 1), 0) AS number_of_vms,
            array_to_string(vms_for_disk_view.array_vm_names, ','::text) AS vm_names,
            array_to_string(vms_for_disk_view.array_template_version_name, ','::text) AS template_version_names,
            NULL::text AS quota_id,
            NULL::text AS quota_name,
            NULL::integer AS quota_enforcement_type,
            NULL::integer AS image_transfer_phase,
            NULL::integer AS image_transfer_type,
            NULL::bigint AS image_transfer_bytes_sent,
            NULL::bigint AS image_transfer_bytes_total,
            NULL::bigint AS progress,
            NULL::text AS disk_profile_id,
            NULL::text AS disk_profile_name,
            l.lun_id,
            l.physical_volume_id,
            l.volume_group_id,
            l.serial,
            l.lun_mapping,
            l.vendor_id,
            l.product_id,
            l.device_size,
            l.discard_max_size
           FROM ((public.disk_lun_map dlm
             JOIN public.luns l ON (((l.lun_id)::text = (dlm.lun_id)::text)))
             LEFT JOIN public.vms_for_disk_view ON ((vms_for_disk_view.device_id = dlm.disk_id)))) storage_impl
     JOIN public.base_disks bd ON ((bd.disk_id = storage_impl.image_group_id)));


ALTER TABLE public.all_disks_including_snapshots OWNER TO engine;

--
-- Name: getallfromdisksincludingsnapshots(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdisksincludingsnapshots(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks_including_snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks_including_snapshots
    WHERE (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromdisksincludingsnapshots(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: disk_vm_element_extended; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.disk_vm_element_extended AS
 SELECT dve.disk_id,
    dve.vm_id,
    dve.is_boot,
    dve.disk_interface,
    dve.is_using_scsi_reservation,
    dve.pass_discard,
    vd.is_plugged,
    vd.logical_name,
    vd.is_readonly
   FROM (public.disk_vm_element dve
     JOIN public.vm_device vd ON (((dve.disk_id = vd.device_id) AND (dve.vm_id = vd.vm_id))));


ALTER TABLE public.disk_vm_element_extended OWNER TO engine;

--
-- Name: getallfromdiskvmelements(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdiskvmelements() RETURNS SETOF public.disk_vm_element_extended
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM disk_vm_element_extended;
END;$$;


ALTER FUNCTION public.getallfromdiskvmelements() OWNER TO engine;

--
-- Name: dns_resolver_configuration; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.dns_resolver_configuration (
    id uuid NOT NULL
);


ALTER TABLE public.dns_resolver_configuration OWNER TO engine;

--
-- Name: getallfromdnsresolverconfigurations(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromdnsresolverconfigurations() RETURNS SETOF public.dns_resolver_configuration
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM dns_resolver_configuration;
END;$$;


ALTER FUNCTION public.getallfromdnsresolverconfigurations() OWNER TO engine;

--
-- Name: gluster_server_services; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_server_services (
    id uuid NOT NULL,
    server_id uuid NOT NULL,
    service_id uuid NOT NULL,
    pid integer,
    status character varying(32) NOT NULL,
    message character varying(1000),
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_server_services OWNER TO engine;

--
-- Name: gluster_services; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_services (
    id uuid NOT NULL,
    service_type character varying(100) NOT NULL,
    service_name character varying(100) NOT NULL
);


ALTER TABLE public.gluster_services OWNER TO engine;

--
-- Name: gluster_server_services_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_server_services_view AS
 SELECT gluster_server_services.id,
    gluster_server_services.server_id,
    gluster_server_services.service_id,
    gluster_server_services.pid,
    gluster_server_services.status,
    gluster_server_services.message,
    gluster_server_services._create_date,
    gluster_server_services._update_date,
    gluster_services.service_name,
    gluster_services.service_type,
    vds_static.vds_name
   FROM ((public.gluster_server_services
     JOIN public.gluster_services ON ((gluster_server_services.service_id = gluster_services.id)))
     JOIN public.vds_static ON ((gluster_server_services.server_id = vds_static.vds_id)));


ALTER TABLE public.gluster_server_services_view OWNER TO engine;

--
-- Name: getallfromglusterserverservices(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromglusterserverservices() RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_services_view;
END;$$;


ALTER FUNCTION public.getallfromglusterserverservices() OWNER TO engine;

--
-- Name: getallfromglusterservices(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromglusterservices() RETURNS SETOF public.gluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_services;
END;$$;


ALTER FUNCTION public.getallfromglusterservices() OWNER TO engine;

--
-- Name: host_device; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.host_device (
    host_id uuid NOT NULL,
    device_name character varying(255) NOT NULL,
    parent_device_name character varying(255) NOT NULL,
    capability character varying(32) NOT NULL,
    iommu_group integer,
    product_name character varying(255),
    product_id character varying(255),
    vendor_name character varying(255),
    vendor_id character varying(255),
    physfn character varying(255),
    total_vfs integer,
    vm_id uuid,
    net_iface_name character varying(50),
    driver character varying(255),
    is_assignable boolean DEFAULT true NOT NULL,
    address character varying(255),
    mdev_types text,
    block_path text,
    hostdev_spec_params text
);


ALTER TABLE public.host_device OWNER TO engine;

--
-- Name: getallfromhostdevices(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromhostdevices() RETURNS SETOF public.host_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_device;
END;$$;


ALTER FUNCTION public.getallfromhostdevices() OWNER TO engine;

--
-- Name: host_nic_vfs_config; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.host_nic_vfs_config (
    id uuid NOT NULL,
    nic_id uuid NOT NULL,
    is_all_networks_allowed boolean NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.host_nic_vfs_config OWNER TO engine;

--
-- Name: getallfromhostnicvfsconfigs(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromhostnicvfsconfigs() RETURNS SETOF public.host_nic_vfs_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_nic_vfs_config;
END;$$;


ALTER FUNCTION public.getallfromhostnicvfsconfigs() OWNER TO engine;

--
-- Name: getallfromimages(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromimages() RETURNS SETOF public.images
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM images;
END;$$;


ALTER FUNCTION public.getallfromimages() OWNER TO engine;

--
-- Name: getallfromimageuploads(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromimageuploads() RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers;
END;$$;


ALTER FUNCTION public.getallfromimageuploads() OWNER TO engine;

--
-- Name: iscsi_bonds; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.iscsi_bonds (
    id uuid NOT NULL,
    name character varying(50) NOT NULL,
    description character varying(4000),
    storage_pool_id uuid NOT NULL
);


ALTER TABLE public.iscsi_bonds OWNER TO engine;

--
-- Name: getallfromiscsibonds(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromiscsibonds() RETURNS SETOF public.iscsi_bonds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds.*
    FROM iscsi_bonds;
END;$$;


ALTER FUNCTION public.getallfromiscsibonds() OWNER TO engine;

--
-- Name: libvirt_secrets; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.libvirt_secrets (
    secret_id uuid NOT NULL,
    secret_value text NOT NULL,
    secret_usage_type integer NOT NULL,
    secret_description text,
    provider_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.libvirt_secrets OWNER TO engine;

--
-- Name: getallfromlibvirtsecrets(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromlibvirtsecrets() RETURNS SETOF public.libvirt_secrets
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM libvirt_secrets;
END;$$;


ALTER FUNCTION public.getallfromlibvirtsecrets() OWNER TO engine;

--
-- Name: lun_storage_server_connection_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.lun_storage_server_connection_map (
    lun_id character varying(255) NOT NULL,
    storage_server_connection character varying(50) NOT NULL
);


ALTER TABLE public.lun_storage_server_connection_map OWNER TO engine;

--
-- Name: getallfromlun_storage_server_connection_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromlun_storage_server_connection_map() RETURNS SETOF public.lun_storage_server_connection_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM LUN_storage_server_connection_map lUN_storage_server_connection_map;
END;$$;


ALTER FUNCTION public.getallfromlun_storage_server_connection_map() OWNER TO engine;

--
-- Name: luns_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.luns_view AS
 SELECT luns.physical_volume_id,
    luns.lun_id,
    luns.volume_group_id,
    luns.serial,
    luns.lun_mapping,
    luns.vendor_id,
    luns.product_id,
    luns.device_size,
    luns.discard_max_size,
    storage_domain_static.id AS storage_id,
    storage_domain_static.storage_name,
    disk_lun_map.disk_id,
    all_disks.disk_alias
   FROM (((public.luns
     LEFT JOIN public.storage_domain_static ON (((luns.volume_group_id)::text = (storage_domain_static.storage)::text)))
     LEFT JOIN public.disk_lun_map ON (((luns.lun_id)::text = (disk_lun_map.lun_id)::text)))
     LEFT JOIN public.all_disks ON ((disk_lun_map.disk_id = all_disks.disk_id)));


ALTER TABLE public.luns_view OWNER TO engine;

--
-- Name: getallfromluns(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromluns() RETURNS SETOF public.luns_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM luns_view;
END;$$;


ALTER FUNCTION public.getallfromluns() OWNER TO engine;

--
-- Name: mac_pools; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.mac_pools (
    id uuid NOT NULL,
    name character varying(255),
    description character varying(4000),
    allow_duplicate_mac_addresses boolean DEFAULT false NOT NULL,
    default_pool boolean DEFAULT false NOT NULL
);


ALTER TABLE public.mac_pools OWNER TO engine;

--
-- Name: getallfrommacpools(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfrommacpools() RETURNS SETOF public.mac_pools
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM mac_pools;
END;$$;


ALTER FUNCTION public.getallfrommacpools() OWNER TO engine;

--
-- Name: getallfromnetwork(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnetwork(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network
    WHERE NOT v_is_filtered
        OR EXISTS (
            SELECT 1
            FROM user_network_permissions_view
            WHERE user_id = v_user_id
                AND entity_id = network.id
            );
END;$$;


ALTER FUNCTION public.getallfromnetwork(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromnetwork_cluster(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnetwork_cluster() RETURNS SETOF public.network_cluster
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_cluster;
END;$$;


ALTER FUNCTION public.getallfromnetwork_cluster() OWNER TO engine;

--
-- Name: getallfromnetwork_clusterbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnetwork_clusterbyclusterid(v_cluster_id uuid) RETURNS SETOF public.network_cluster
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_cluster
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getallfromnetwork_clusterbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getallfromnetwork_clusterbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnetwork_clusterbynetworkid(v_network_id uuid) RETURNS SETOF public.network_cluster
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_cluster
    WHERE network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getallfromnetwork_clusterbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getallfromnetworkattachments(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnetworkattachments() RETURNS SETOF public.network_attachments
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_attachments;
END;$$;


ALTER FUNCTION public.getallfromnetworkattachments() OWNER TO engine;

--
-- Name: numa_node_cpu_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.numa_node_cpu_map (
    id uuid NOT NULL,
    numa_node_id uuid NOT NULL,
    cpu_core_id integer
);


ALTER TABLE public.numa_node_cpu_map OWNER TO engine;

--
-- Name: getallfromnumanodecpumap(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromnumanodecpumap() RETURNS SETOF public.numa_node_cpu_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT numa_node_cpu_map.*
        FROM numa_node_cpu_map;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getallfromnumanodecpumap() OWNER TO engine;

--
-- Name: policy_units; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.policy_units (
    id uuid NOT NULL,
    name character varying(128) NOT NULL,
    is_internal boolean NOT NULL,
    custom_properties_regex text,
    type smallint DEFAULT 0,
    enabled boolean DEFAULT true NOT NULL,
    description text
);


ALTER TABLE public.policy_units OWNER TO engine;

--
-- Name: getallfrompolicyunits(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfrompolicyunits() RETURNS SETOF public.policy_units
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM policy_units;
END;$$;


ALTER FUNCTION public.getallfrompolicyunits() OWNER TO engine;

--
-- Name: providers; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.providers (
    id uuid NOT NULL,
    name character varying(128) NOT NULL,
    description character varying(4000) DEFAULT ''::character varying NOT NULL,
    url character varying(512),
    provider_type character varying(32) NOT NULL,
    auth_required boolean NOT NULL,
    auth_username character varying(64),
    auth_password text,
    _create_date timestamp with time zone DEFAULT now(),
    _update_date timestamp with time zone,
    custom_properties text,
    tenant_name character varying(128),
    plugin_type character varying(64),
    auth_url text,
    additional_properties text,
    read_only boolean DEFAULT false NOT NULL,
    is_unmanaged boolean DEFAULT false NOT NULL,
    auto_sync boolean DEFAULT false NOT NULL,
    user_domain_name character varying(128),
    project_name character varying(128),
    project_domain_name character varying(128),
    CONSTRAINT valid_auth_url CHECK ((auth_url ~ '^http(s)?://[^/]*:[\d]+/(v3|v2\.0)/?$'::text))
);


ALTER TABLE public.providers OWNER TO engine;

--
-- Name: getallfromproviders(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromproviders() RETURNS SETOF public.providers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM providers;
END;$$;


ALTER FUNCTION public.getallfromproviders() OWNER TO engine;

--
-- Name: getallfromprovidersbytypes(character varying[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromprovidersbytypes(v_provider_types character varying[]) RETURNS SETOF public.providers
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM providers
    WHERE provider_type = ANY(v_provider_types);
END;$$;


ALTER FUNCTION public.getallfromprovidersbytypes(v_provider_types character varying[]) OWNER TO engine;

--
-- Name: getallfromrole(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromrole(v_app_mode integer) RETURNS SETOF public.roles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM roles
   WHERE (roles.app_mode & v_app_mode) > 0;

END; $$;


ALTER FUNCTION public.getallfromrole(v_app_mode integer) OWNER TO engine;

--
-- Name: getallfromsnapshots(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromsnapshots() RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots;
END;$$;


ALTER FUNCTION public.getallfromsnapshots() OWNER TO engine;

--
-- Name: getallfromsnapshotsbyvmid(uuid, uuid, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromsnapshotsbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean, v_fill_configuration boolean) RETURNS SETOF public.getallfromsnapshotsbyvmid_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT snapshot_id,
        vm_id,
        snapshot_type,
        status,
        description,
        creation_date,
        app_list,
        memory_dump_disk_id,
        memory_metadata_disk_id,
        CASE
            WHEN v_fill_configuration = TRUE
                THEN vm_configuration
            ELSE NULL
            END,
        vm_configuration IS NOT NULL
        AND LENGTH(vm_configuration) > 0,
        vm_configuration_broken,
        changed_fields
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            )
    ORDER BY creation_date ASC;
END;$$;


ALTER FUNCTION public.getallfromsnapshotsbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean, v_fill_configuration boolean) OWNER TO engine;

--
-- Name: storage_domain_dynamic; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_domain_dynamic (
    id uuid NOT NULL,
    available_disk_size integer,
    used_disk_size integer,
    _update_date timestamp with time zone,
    external_status integer DEFAULT 0 NOT NULL,
    confirmed_available_disk_size integer,
    vdo_savings integer
);


ALTER TABLE public.storage_domain_dynamic OWNER TO engine;

--
-- Name: getallfromstorage_domain_dynamic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorage_domain_dynamic() RETURNS SETOF public.storage_domain_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_dynamic;
END;$$;


ALTER FUNCTION public.getallfromstorage_domain_dynamic() OWNER TO engine;

--
-- Name: getallfromstorage_domain_static(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorage_domain_static() RETURNS SETOF public.storage_domain_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_static;
END;$$;


ALTER FUNCTION public.getallfromstorage_domain_static() OWNER TO engine;

--
-- Name: unregistered_disks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.unregistered_disks (
    disk_id uuid NOT NULL,
    disk_alias character varying(255),
    disk_description character varying(255),
    storage_domain_id uuid NOT NULL,
    creation_date timestamp with time zone,
    last_modified timestamp with time zone,
    volume_type integer,
    volume_format integer,
    actual_size bigint,
    size bigint,
    image_id uuid
);


ALTER TABLE public.unregistered_disks OWNER TO engine;

--
-- Name: unregistered_ovf_of_entities; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.unregistered_ovf_of_entities (
    entity_guid uuid NOT NULL,
    entity_name character varying(255) NOT NULL,
    entity_type character varying(32) NOT NULL,
    architecture integer,
    lowest_comp_version character varying(40),
    storage_domain_id uuid NOT NULL,
    ovf_data text,
    ovf_extra_data text,
    status integer
);


ALTER TABLE public.unregistered_ovf_of_entities OWNER TO engine;

--
-- Name: domains_with_unregistered_entities_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.domains_with_unregistered_entities_view AS
 SELECT unregistered_ovf_of_entities.storage_domain_id
   FROM public.unregistered_ovf_of_entities
UNION
 SELECT unregistered_disks.storage_domain_id
   FROM public.unregistered_disks;


ALTER TABLE public.domains_with_unregistered_entities_view OWNER TO engine;

--
-- Name: hosted_engine_storage_domains_ids_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.hosted_engine_storage_domains_ids_view AS
 SELECT image_storage_domain_map.storage_domain_id AS id
   FROM (((public.vm_static
     JOIN public.vm_device ON ((vm_device.vm_id = vm_static.vm_guid)))
     JOIN public.images ON ((images.image_group_id = vm_device.device_id)))
     JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images.image_guid)))
  WHERE ((vm_static.origin = ANY (ARRAY[5, 6])) AND images.active);


ALTER TABLE public.hosted_engine_storage_domains_ids_view OWNER TO engine;

--
-- Name: storage_domain_shared_status; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domain_shared_status AS
 SELECT storage_pool_iso_map.storage_id,
        CASE
            WHEN (count(
            CASE storage_pool_iso_map.status
                WHEN 3 THEN 1
                ELSE NULL::integer
            END) > 0) THEN
            CASE
                WHEN (count(DISTINCT storage_pool_iso_map.status) > 1) THEN 3
                ELSE 1
            END
            ELSE 2
        END AS status
   FROM public.storage_pool_iso_map
  GROUP BY storage_pool_iso_map.storage_id;


ALTER TABLE public.storage_domain_shared_status OWNER TO engine;

--
-- Name: storage_domains_image_sizes; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domains_image_sizes AS
 SELECT isdm.storage_domain_id,
    ((COALESCE(sum(
        CASE
            WHEN ((i.active = true) AND ((vfdv.entity_type IS NULL) OR ((vfdv.entity_type)::text <> 'TEMPLATE'::text))) THEN i.size
            ELSE din.actual_size
        END), (0)::numeric) * 0.000000000931322574615478515625))::bigint AS commited_disk_size,
    ((COALESCE(sum(din.actual_size), (0)::numeric) * 0.000000000931322574615478515625))::bigint AS actual_images_size
   FROM (((public.images i
     JOIN public.image_storage_domain_map isdm ON ((i.image_guid = isdm.image_id)))
     LEFT JOIN public.disk_image_dynamic din ON ((i.image_guid = din.image_id)))
     LEFT JOIN public.vms_for_disk_view vfdv ON ((i.image_group_id = vfdv.device_id)))
  GROUP BY isdm.storage_domain_id;


ALTER TABLE public.storage_domains_image_sizes OWNER TO engine;

--
-- Name: vg_discard_support_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vg_discard_support_view AS
 SELECT luns.volume_group_id,
    bool_and((COALESCE(luns.discard_max_size, (0)::bigint) > 0)) AS supports_discard
   FROM public.luns
  WHERE ((luns.volume_group_id)::text <> ''::text)
  GROUP BY luns.volume_group_id;


ALTER TABLE public.vg_discard_support_view OWNER TO engine;

--
-- Name: storage_domains; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domains AS
 SELECT storage_domain_static.id,
    storage_domain_static.storage,
    storage_domain_static.storage_name,
    storage_domain_static.storage_description,
    storage_domain_static.storage_comment,
    storage_pool_iso_map.storage_pool_id,
    storage_domain_dynamic.available_disk_size,
    storage_domain_dynamic.confirmed_available_disk_size,
    storage_domain_dynamic.vdo_savings,
    storage_domain_dynamic.used_disk_size,
    storage_domains_image_sizes.commited_disk_size,
    storage_domains_image_sizes.actual_images_size,
    storage_pool_iso_map.status,
    storage_pool.name AS storage_pool_name,
    storage_domain_static.storage_type,
    storage_domain_static.storage_domain_type,
    storage_domain_static.storage_domain_format_type,
    storage_domain_static.last_time_used_as_master,
    storage_domain_static.wipe_after_delete,
    storage_domain_static.discard_after_delete,
    storage_domain_static.first_metadata_device,
    storage_domain_static.vg_metadata_device,
    storage_domain_static.backup,
    storage_domain_static.block_size,
    COALESCE(storage_domain_shared_status.status, 0) AS storage_domain_shared_status,
    storage_domain_static.recoverable,
    (domains_with_unregistered_entities_view.storage_domain_id IS NOT NULL) AS contains_unregistered_entities,
    storage_domain_static.warning_low_space_indicator,
    storage_domain_static.critical_space_action_blocker,
    storage_domain_static.warning_low_confirmed_space_indicator,
    storage_domain_dynamic.external_status,
    vg_discard_support_view.supports_discard,
    (EXISTS ( SELECT 1
           FROM public.hosted_engine_storage_domains_ids_view
          WHERE (hosted_engine_storage_domains_ids_view.id = storage_domain_static.id))) AS is_hosted_engine_storage
   FROM (((((((public.storage_domain_static
     JOIN public.storage_domain_dynamic ON ((storage_domain_static.id = storage_domain_dynamic.id)))
     LEFT JOIN public.storage_pool_iso_map ON ((storage_domain_static.id = storage_pool_iso_map.storage_id)))
     LEFT JOIN public.storage_pool ON ((storage_pool_iso_map.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.domains_with_unregistered_entities_view ON ((domains_with_unregistered_entities_view.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.storage_domains_image_sizes ON ((storage_domains_image_sizes.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.storage_domain_shared_status ON ((storage_domain_shared_status.storage_id = storage_domain_static.id)))
     LEFT JOIN public.vg_discard_support_view ON (((storage_domain_static.storage)::text = (vg_discard_support_view.volume_group_id)::text)));


ALTER TABLE public.storage_domains OWNER TO engine;

--
-- Name: getallfromstorage_domains(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorage_domains(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT ON (id) *
    FROM storage_domains
    WHERE (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_domain_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromstorage_domains(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromstorage_pool(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorage_pool(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_pool_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = id
                )
            );
END;$$;


ALTER FUNCTION public.getallfromstorage_pool(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromstorage_pool_iso_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorage_pool_iso_map() RETURNS SETOF public.storage_pool_iso_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool_iso_map;
END;$$;


ALTER FUNCTION public.getallfromstorage_pool_iso_map() OWNER TO engine;

--
-- Name: getallfromstoragedomainsbyconnectionid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstoragedomainsbyconnectionid(v_connection_id character varying) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage = v_connection_id;
END;$$;


ALTER FUNCTION public.getallfromstoragedomainsbyconnectionid(v_connection_id character varying) OWNER TO engine;

--
-- Name: storage_server_connection_extension; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_server_connection_extension (
    id uuid NOT NULL,
    vds_id uuid NOT NULL,
    iqn character varying(128) NOT NULL,
    user_name text NOT NULL,
    password text NOT NULL
);


ALTER TABLE public.storage_server_connection_extension OWNER TO engine;

--
-- Name: getallfromstorageserverconnectionextensions(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromstorageserverconnectionextensions() RETURNS SETOF public.storage_server_connection_extension
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connection_extension;
END;$$;


ALTER FUNCTION public.getallfromstorageserverconnectionextensions() OWNER TO engine;

--
-- Name: tags; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags (
    tag_id uuid NOT NULL,
    tag_name character varying(50) DEFAULT ''::character varying NOT NULL,
    description character varying(4000),
    parent_id uuid,
    readonly boolean,
    type integer DEFAULT 0 NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.tags OWNER TO engine;

--
-- Name: getallfromtags(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags() RETURNS SETOF public.tags
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags.*
    FROM tags;
END;$$;


ALTER FUNCTION public.getallfromtags() OWNER TO engine;

--
-- Name: tags_user_group_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags_user_group_map (
    tag_id uuid NOT NULL,
    group_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE public.tags_user_group_map OWNER TO engine;

--
-- Name: getallfromtags_user_group_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags_user_group_map() RETURNS SETOF public.tags_user_group_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_user_group_map.*
    FROM tags_user_group_map;
END;$$;


ALTER FUNCTION public.getallfromtags_user_group_map() OWNER TO engine;

--
-- Name: tags_user_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags_user_map (
    tag_id uuid NOT NULL,
    user_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE public.tags_user_map OWNER TO engine;

--
-- Name: getallfromtags_user_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags_user_map() RETURNS SETOF public.tags_user_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_user_map.*
    FROM tags_user_map;
END;$$;


ALTER FUNCTION public.getallfromtags_user_map() OWNER TO engine;

--
-- Name: tags_vds_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags_vds_map (
    tag_id uuid NOT NULL,
    vds_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE public.tags_vds_map OWNER TO engine;

--
-- Name: getallfromtags_vds_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags_vds_map() RETURNS SETOF public.tags_vds_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vds_map.*
    FROM tags_vds_map;
END;$$;


ALTER FUNCTION public.getallfromtags_vds_map() OWNER TO engine;

--
-- Name: tags_vm_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags_vm_map (
    tag_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    defaultdisplaytype integer DEFAULT 0
);


ALTER TABLE public.tags_vm_map OWNER TO engine;

--
-- Name: getallfromtags_vm_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags_vm_map() RETURNS SETOF public.tags_vm_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vm_map.*
    FROM tags_vm_map;
END;$$;


ALTER FUNCTION public.getallfromtags_vm_map() OWNER TO engine;

--
-- Name: tags_vm_pool_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.tags_vm_pool_map (
    tag_id uuid NOT NULL,
    vm_pool_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE public.tags_vm_pool_map OWNER TO engine;

--
-- Name: getallfromtags_vm_pool_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromtags_vm_pool_map() RETURNS SETOF public.tags_vm_pool_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vm_pool_map.*
    FROM tags_vm_pool_map;
END;$$;


ALTER FUNCTION public.getallfromtags_vm_pool_map() OWNER TO engine;

--
-- Name: users; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.users (
    user_id uuid NOT NULL,
    name character varying(255) DEFAULT ''::character varying NOT NULL,
    surname character varying(255) DEFAULT ''::character varying NOT NULL,
    domain character varying(255) NOT NULL,
    username character varying(255) NOT NULL,
    department character varying(255) DEFAULT ''::character varying NOT NULL,
    email character varying(255),
    note character varying(255),
    last_admin_check_status boolean DEFAULT false NOT NULL,
    external_id text NOT NULL,
    _create_date timestamp with time zone DEFAULT now(),
    _update_date timestamp with time zone,
    namespace character varying(2048) DEFAULT '*'::character varying,
    user_and_domain character varying(512) GENERATED ALWAYS AS (
CASE
    WHEN (domain IS NOT NULL) THEN ((((name)::text || '@'::text) || (domain)::text))::character varying
    ELSE name
END) STORED
);


ALTER TABLE public.users OWNER TO engine;

--
-- Name: getallfromusers(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromusers(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT users.*
        FROM users
        WHERE (
                NOT v_is_filtered
                OR EXISTS (
                    SELECT 1
                    FROM users u,
                        user_db_users_permissions_view p
                    WHERE u.user_id = v_user_id
                        AND u.user_id = p.ad_element_id
                    )
                );
    END;$$;


ALTER FUNCTION public.getallfromusers(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: vdc_options_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.vdc_options_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vdc_options_seq OWNER TO engine;

--
-- Name: vdc_options; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vdc_options (
    option_id integer DEFAULT nextval('public.vdc_options_seq'::regclass) NOT NULL,
    option_name character varying(100) NOT NULL,
    option_value text NOT NULL,
    version character varying(40) DEFAULT 'general'::character varying NOT NULL,
    default_value text NOT NULL
);


ALTER TABLE public.vdc_options OWNER TO engine;

--
-- Name: getallfromvdcoption(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvdcoption() RETURNS SETOF public.vdc_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vdc_options.*
    FROM vdc_options;
END;$$;


ALTER FUNCTION public.getallfromvdcoption() OWNER TO engine;

--
-- Name: gluster_server; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_server (
    server_id uuid NOT NULL,
    gluster_server_uuid uuid NOT NULL,
    known_addresses character varying(250),
    peer_status character varying(50) NOT NULL
);


ALTER TABLE public.gluster_server OWNER TO engine;

--
-- Name: vds_spm_id_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_spm_id_map (
    storage_pool_id uuid NOT NULL,
    vds_spm_id integer NOT NULL,
    vds_id uuid NOT NULL
);


ALTER TABLE public.vds_spm_id_map OWNER TO engine;

--
-- Name: vds_statistics; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_statistics (
    vds_id uuid NOT NULL,
    cpu_idle numeric(18,0) DEFAULT 0,
    cpu_load numeric(18,0) DEFAULT 0,
    cpu_sys numeric(18,0) DEFAULT 0,
    cpu_user numeric(18,0) DEFAULT 0,
    usage_mem_percent integer DEFAULT 0,
    usage_cpu_percent integer DEFAULT 0,
    usage_network_percent integer,
    mem_shared bigint,
    swap_free bigint,
    swap_total bigint,
    ksm_cpu_percent integer DEFAULT 0,
    ksm_pages bigint,
    ksm_state boolean,
    _update_date timestamp with time zone,
    mem_free bigint,
    ha_score integer DEFAULT 0 NOT NULL,
    anonymous_hugepages integer,
    ha_configured boolean DEFAULT false NOT NULL,
    ha_active boolean DEFAULT false NOT NULL,
    ha_global_maintenance boolean DEFAULT false NOT NULL,
    ha_local_maintenance boolean DEFAULT false NOT NULL,
    boot_time bigint,
    cpu_over_commit_time_stamp timestamp with time zone,
    hugepages text
);


ALTER TABLE public.vds_statistics OWNER TO engine;

--
-- Name: vds; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vds AS
 SELECT cluster.cluster_id,
    cluster.name AS cluster_name,
    cluster.description AS cluster_description,
    cluster.architecture,
    cluster.enable_balloon,
    vds_static.vds_id,
    vds_static.vds_name,
    vds_static.vds_unique_id,
    vds_static.host_name,
    vds_static.free_text_comment,
    vds_static.port,
    vds_static.server_ssl_enabled,
    vds_static.vds_type,
    vds_static.pm_enabled,
    vds_static.pm_proxy_preferences,
    vds_static.pm_detect_kdump,
    vds_static.vds_spm_priority,
    vds_dynamic.hooks,
    vds_dynamic.status,
    vds_dynamic.external_status,
    vds_dynamic.cpu_cores,
    vds_dynamic.cpu_threads,
    vds_dynamic.cpu_model,
    vds_dynamic.cpu_speed_mh,
    vds_dynamic.if_total_speed,
    vds_dynamic.kvm_enabled,
    vds_dynamic.physical_mem_mb,
    vds_dynamic.pending_vcpus_count,
    vds_dynamic.pending_vmem_size,
    vds_dynamic.mem_commited,
    vds_dynamic.vm_active,
    vds_dynamic.vm_count,
    vds_dynamic.vm_migrating,
    vds_dynamic.incoming_migrations,
    vds_dynamic.outgoing_migrations,
    vds_dynamic.kernel_args,
    vds_dynamic.pretty_name,
    vds_dynamic.hosted_engine_configured,
    vds_dynamic.vms_cores_count,
    vds_statistics.cpu_over_commit_time_stamp,
    cluster.max_vds_memory_over_commit,
    vds_dynamic.net_config_dirty,
    cluster.count_threads_as_cores,
    storage_pool.id AS storage_pool_id,
    storage_pool.name AS storage_pool_name,
    vds_dynamic.reserved_mem,
    vds_dynamic.guest_overhead,
    vds_dynamic.rpm_version,
    vds_dynamic.software_version,
    vds_dynamic.version_name,
    vds_dynamic.build_name,
    vds_dynamic.previous_status,
    vds_statistics.cpu_idle,
    vds_statistics.cpu_load,
    vds_statistics.cpu_sys,
    vds_statistics.cpu_user,
    vds_statistics.usage_mem_percent,
    vds_statistics.usage_cpu_percent,
    vds_statistics.usage_network_percent,
    vds_statistics.mem_free,
    vds_statistics.mem_shared,
    vds_statistics.swap_free,
    vds_statistics.swap_total,
    vds_statistics.ksm_cpu_percent,
    vds_statistics.ksm_pages,
    vds_statistics.ksm_state,
    vds_dynamic.cpu_flags,
    cluster.cpu_name AS cluster_cpu_name,
    cluster.cpu_flags AS cluster_cpu_flags,
    cluster.cpu_verb AS cluster_cpu_verb,
    vds_dynamic.cpu_sockets,
    vds_spm_id_map.vds_spm_id,
    vds_static.otp_validity,
        CASE
            WHEN (storage_pool.spm_vds_id = vds_static.vds_id) THEN
            CASE
                WHEN (storage_pool.status = 5) THEN 1
                ELSE 2
            END
            ELSE 0
        END AS spm_status,
    vds_dynamic.supported_cluster_levels,
    vds_dynamic.supported_engines,
    cluster.compatibility_version AS cluster_compatibility_version,
    cluster.virt_service AS cluster_virt_service,
    cluster.gluster_service AS cluster_gluster_service,
    vds_dynamic.host_os,
    vds_dynamic.kvm_version,
    vds_dynamic.libvirt_version,
    vds_dynamic.spice_version,
    vds_dynamic.gluster_version,
    vds_dynamic.librbd1_version,
    vds_dynamic.glusterfs_cli_version,
    vds_dynamic.openvswitch_version,
    vds_dynamic.nmstate_version,
    vds_dynamic.kernel_version,
    vds_dynamic.iscsi_initiator_name,
    vds_dynamic.transparent_hugepages_state,
    vds_statistics.anonymous_hugepages,
    vds_statistics.hugepages,
    vds_dynamic.non_operational_reason,
    vds_static.recoverable,
    vds_static.sshkeyfingerprint,
    vds_static.host_provider_id,
    vds_dynamic.hw_manufacturer,
    vds_dynamic.hw_product_name,
    vds_dynamic.hw_version,
    vds_dynamic.hw_serial_number,
    vds_dynamic.hw_uuid,
    vds_dynamic.hw_family,
    vds_static.console_address,
    vds_dynamic.hbas,
    vds_dynamic.supported_emulated_machines,
    vds_dynamic.supported_rng_sources,
    vds_static.ssh_port,
    vds_static.ssh_username,
    vds_statistics.ha_score,
    vds_statistics.ha_configured,
    vds_statistics.ha_active,
    vds_statistics.ha_global_maintenance,
    vds_statistics.ha_local_maintenance,
    vds_static.disable_auto_pm,
    vds_dynamic.controlled_by_pm_policy,
    vds_statistics.boot_time,
    vds_dynamic.kdump_status,
    vds_dynamic.selinux_enforce_mode,
    vds_dynamic.auto_numa_balancing,
    vds_dynamic.is_numa_supported,
    vds_dynamic.online_cpus,
    vds_dynamic.maintenance_reason,
    vds_dynamic.is_update_available,
    vds_dynamic.is_hostdev_enabled,
    ((vds_dynamic.vm_count > 0) AND (vds_statistics.ha_score IS NOT NULL) AND (EXISTS ( SELECT 1
           FROM (public.vm_dynamic
             LEFT JOIN public.vm_static ON ((vm_dynamic.vm_guid = vm_static.vm_guid)))
          WHERE ((vds_static.vds_id = vm_dynamic.run_on_vds) AND (vm_static.origin = ANY (ARRAY[5, 6])))))) AS is_hosted_engine_host,
    vds_static.kernel_cmdline,
    vds_static.last_stored_kernel_cmdline,
    cluster.fencing_enabled,
    gluster_server.peer_status AS gluster_peer_status,
    vds_dynamic.in_fence_flow,
    vds_static.reinstall_required,
    vds_dynamic.kernel_features,
    vds_dynamic.vnc_encryption_enabled,
    vds_static.vgpu_placement,
    vds_dynamic.connector_info,
    vds_dynamic.backup_enabled,
    vds_dynamic.cold_backup_enabled,
    vds_dynamic.clear_bitmaps_enabled,
    vds_dynamic.supported_domain_versions,
    vds_dynamic.supported_block_size,
    cluster.smt_disabled AS cluster_smt_disabled,
    vds_dynamic.tsc_frequency,
    vds_dynamic.tsc_scaling,
    vds_dynamic.fips_enabled,
    vds_dynamic.boot_uuid,
    vds_dynamic.cd_change_pdiv,
    vds_dynamic.ovn_configured,
    vds_static.ssh_public_key,
    vds_dynamic.cpu_topology,
    vds_dynamic.vdsm_cpus_affinity
   FROM ((((((public.cluster
     JOIN public.vds_static ON ((cluster.cluster_id = vds_static.cluster_id)))
     JOIN public.vds_dynamic ON ((vds_static.vds_id = vds_dynamic.vds_id)))
     JOIN public.vds_statistics ON ((vds_static.vds_id = vds_statistics.vds_id)))
     LEFT JOIN public.storage_pool ON ((cluster.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.vds_spm_id_map ON ((vds_static.vds_id = vds_spm_id_map.vds_id)))
     LEFT JOIN public.gluster_server ON ((vds_static.vds_id = gluster_server.server_id)));


ALTER TABLE public.vds OWNER TO engine;

--
-- Name: getallfromvds(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvds(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE (
                NOT v_is_filtered
                OR EXISTS (
                    SELECT 1
                    FROM user_vds_permissions_view
                    WHERE user_id = v_user_id
                        AND entity_id = vds_id
                    )
                );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getallfromvds(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromvds_spm_id_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvds_spm_id_map() RETURNS SETOF public.vds_spm_id_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_spm_id_map.*
    FROM vds_spm_id_map;
END;$$;


ALTER FUNCTION public.getallfromvds_spm_id_map() OWNER TO engine;

--
-- Name: getallfromvdsdynamic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvdsdynamic() RETURNS SETOF public.vds_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_dynamic.*
        FROM vds_dynamic;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getallfromvdsdynamic() OWNER TO engine;

--
-- Name: getallfromvdsstatic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvdsstatic() RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.*
    FROM vds_static;

    RETURN;
END;$$;


ALTER FUNCTION public.getallfromvdsstatic() OWNER TO engine;

--
-- Name: getallfromvdsstatistics(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvdsstatistics() RETURNS SETOF public.vds_statistics
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_statistics.*
        FROM vds_statistics;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getallfromvdsstatistics() OWNER TO engine;

--
-- Name: getallfromvm_pool_map(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvm_pool_map() RETURNS SETOF public.vm_pool_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_pool_map.*
    FROM vm_pool_map;
END;$$;


ALTER FUNCTION public.getallfromvm_pool_map() OWNER TO engine;

--
-- Name: getallfromvm_pools(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvm_pools() RETURNS SETOF public.getallfromvm_pools_rs
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- BEGIN TRAN
    BEGIN
        CREATE TEMPORARY TABLE tt_VM_POOL_GROUP (
            vm_pool_id UUID,
            assigned_vm_count INT
            ) ON COMMIT DROP;

        exception when others then

        TRUNCATE TABLE tt_VM_POOL_GROUP;
    END;

    INSERT INTO tt_VM_POOL_GROUP (
        vm_pool_id,
        assigned_vm_count
        )
    SELECT vm_pools_view.vm_pool_id,
        count(vm_pool_map.vm_pool_id)
    FROM vm_pools_view
    LEFT JOIN vm_pool_map
        ON vm_pools_view.vm_pool_id = vm_pool_map.vm_pool_id
    GROUP BY vm_pools_view.vm_pool_id,
        vm_pool_map.vm_pool_id;

    BEGIN
        CREATE TEMPORARY TABLE tt_VM_POOL_RUNNING (
            vm_pool_id UUID,
            vm_running_count INT
            ) ON COMMIT DROP;

        exception when others then

        TRUNCATE TABLE tt_VM_POOL_RUNNING;
    END;

    INSERT INTO tt_VM_POOL_RUNNING (
        vm_pool_id,
        vm_running_count
        )
    SELECT vm_pools_view.vm_pool_id,
        count(vm_pools_view.vm_pool_id)
    FROM vm_pools_view
    LEFT JOIN vm_pool_map
        ON vm_pools_view.vm_pool_id = vm_pool_map.vm_pool_id
    LEFT JOIN vm_dynamic
        ON vm_pool_map.vm_guid = vm_dynamic.vm_guid
    WHERE vm_dynamic.status > 0
    GROUP BY vm_pools_view.vm_pool_id;

    BEGIN
        CREATE TEMPORARY TABLE tt_VM_POOL_PRERESULT (
            vm_pool_id UUID,
            assigned_vm_count INT,
            vm_running_count INT
            ) ON COMMIT DROP;

        exception when others then

        TRUNCATE TABLE tt_VM_POOL_PRERESULT;
    END;

    INSERT INTO tt_VM_POOL_PRERESULT (
        vm_pool_id,
        assigned_vm_count,
        vm_running_count
        )
    SELECT pg.vm_pool_id,
        pg.assigned_vm_count,
        pr.vm_running_count
    FROM tt_VM_POOL_GROUP pg
    LEFT JOIN tt_VM_POOL_RUNNING pr
        ON pg.vm_pool_id = pr.vm_pool_id;

    UPDATE tt_VM_POOL_PRERESULT
    SET vm_running_count = 0
    WHERE vm_running_count IS NULL;

    BEGIN
        CREATE TEMPORARY TABLE tt_VM_POOL_RESULT (
            vm_pool_id UUID,
            assigned_vm_count INT,
            vm_running_count INT,
            vm_pool_description VARCHAR(4000),
            vm_pool_comment TEXT,
            vm_pool_name VARCHAR(255),
            vm_pool_type INT,
            stateful BOOLEAN,
            parameters VARCHAR(200),
            prestarted_vms INT,
            cluster_id UUID,
            cluster_name VARCHAR(40),
            max_assigned_vms_per_user SMALLINT,
            spice_proxy VARCHAR(255),
            is_being_destroyed BOOLEAN,
            is_auto_storage_select BOOLEAN
            ) ON COMMIT DROP;

        exception when others then

        TRUNCATE TABLE tt_VM_POOL_RESULT;
    END;

    INSERT INTO tt_VM_POOL_RESULT (
        vm_pool_id,
        assigned_vm_count,
        vm_running_count,
        vm_pool_description,
        vm_pool_comment,
        vm_pool_name,
        vm_pool_type,
        stateful,
        parameters,
        prestarted_vms,
        cluster_id,
        cluster_name,
        max_assigned_vms_per_user,
        spice_proxy,
        is_being_destroyed,
        is_auto_storage_select
        )
    SELECT ppr.vm_pool_id,
        ppr.assigned_vm_count,
        ppr.vm_running_count,
        p.vm_pool_description,
        p.vm_pool_comment,
        p.vm_pool_name,
        p.vm_pool_type,
        p.stateful,
        p.parameters,
        p.prestarted_vms,
        p.cluster_id,
        p.cluster_name,
        p.max_assigned_vms_per_user,
        p.spice_proxy,
        p.is_being_destroyed,
        p.is_auto_storage_select
    FROM tt_VM_POOL_PRERESULT ppr
    INNER JOIN vm_pools_view p
        ON ppr.vm_pool_id = p.vm_pool_id;

    RETURN QUERY

    SELECT *
    FROM tt_VM_POOL_RESULT;
END;$$;


ALTER FUNCTION public.getallfromvm_pools() OWNER TO engine;

--
-- Name: vm_backups; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_backups (
    backup_id uuid NOT NULL,
    from_checkpoint_id uuid,
    to_checkpoint_id uuid,
    vm_id uuid NOT NULL,
    phase character varying(32) NOT NULL,
    _create_date timestamp with time zone DEFAULT now(),
    host_id uuid,
    description character varying(1024) DEFAULT NULL::character varying,
    _update_date timestamp with time zone DEFAULT now() NOT NULL,
    backup_type character varying(50) DEFAULT 'hybrid'::character varying NOT NULL,
    snapshot_id uuid,
    is_stopped boolean DEFAULT false NOT NULL
);


ALTER TABLE public.vm_backups OWNER TO engine;

--
-- Name: getallfromvmbackups(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmbackups() RETURNS SETOF public.vm_backups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_backups;
END;$$;


ALTER FUNCTION public.getallfromvmbackups() OWNER TO engine;

--
-- Name: vm_checkpoints; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_checkpoints (
    checkpoint_id uuid NOT NULL,
    parent_id uuid,
    vm_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT now(),
    state character varying(15) DEFAULT 'Created'::character varying NOT NULL,
    description character varying(1024) DEFAULT NULL::character varying
);


ALTER TABLE public.vm_checkpoints OWNER TO engine;

--
-- Name: getallfromvmcheckpoints(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmcheckpoints() RETURNS SETOF public.vm_checkpoints
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_checkpoints;
END;$$;


ALTER FUNCTION public.getallfromvmcheckpoints() OWNER TO engine;

--
-- Name: vm_device_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_device_view AS
 SELECT vm_device.device_id,
    vm_device.vm_id,
    vm_device.type,
    vm_device.device,
    vm_device.address,
    vm_device.spec_params,
    vm_device.is_managed,
    vm_device.is_plugged,
    vm_device.is_readonly,
    vm_device.alias,
    vm_device.custom_properties,
    vm_device.snapshot_id,
    vm_device.logical_name,
    vm_device.host_device
   FROM public.vm_device;


ALTER TABLE public.vm_device_view OWNER TO engine;

--
-- Name: getallfromvmdevice(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmdevice() RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view;
END;$$;


ALTER FUNCTION public.getallfromvmdevice() OWNER TO engine;

--
-- Name: getallfromvmdynamic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmdynamic() RETURNS SETOF public.vm_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_dynamic.*
    FROM vm_dynamic;
END;$$;


ALTER FUNCTION public.getallfromvmdynamic() OWNER TO engine;

--
-- Name: vm_icon_defaults; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_icon_defaults (
    id uuid NOT NULL,
    os_id integer NOT NULL,
    small_icon_id uuid NOT NULL,
    large_icon_id uuid NOT NULL
);


ALTER TABLE public.vm_icon_defaults OWNER TO engine;

--
-- Name: getallfromvmicondefaults(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmicondefaults() RETURNS SETOF public.vm_icon_defaults
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icon_defaults;
END;$$;


ALTER FUNCTION public.getallfromvmicondefaults() OWNER TO engine;

--
-- Name: vm_icons; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_icons (
    id uuid NOT NULL,
    data_url character varying NOT NULL
);


ALTER TABLE public.vm_icons OWNER TO engine;

--
-- Name: getallfromvmicons(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmicons() RETURNS SETOF public.vm_icons
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icons;
END;$$;


ALTER FUNCTION public.getallfromvmicons() OWNER TO engine;

--
-- Name: getallfromvmiconsfiltered(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmiconsfiltered(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_icons
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    IF v_is_filtered THEN
        RETURN QUERY

    -- icons associated with owned vms and templates
    SELECT DISTINCT vm_icons.*
    FROM (
        SELECT *
        FROM user_vm_template_permissions_view

        UNION

        SELECT *
        FROM user_vm_permissions_view
        ) AS permissions,
        vm_static,
        vm_icons
    WHERE permissions.entity_id = vm_static.vm_guid
        AND vm_static.entity_type IN (
            'TEMPLATE',
            'VM'
            )
        AND (
            vm_icons.id = vm_static.small_icon_id
            OR vm_icons.id = vm_static.large_icon_id
            )
        AND permissions.user_id = v_user_id

    UNION

    -- predefined icons
    SELECT vm_icons.*
    FROM vm_icons,
        vm_icon_defaults
    WHERE vm_icon_defaults.small_icon_id = vm_icons.id
        OR vm_icon_defaults.large_icon_id = vm_icons.id;ELSE

    RETURN QUERY

    SELECT *
    FROM vm_icons;
    END IF;

END;$$;


ALTER FUNCTION public.getallfromvmiconsfiltered(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: vm_interface_filter_parameters; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_interface_filter_parameters (
    id uuid NOT NULL,
    name character varying(255),
    value character varying(255),
    vm_interface_id uuid NOT NULL
);


ALTER TABLE public.vm_interface_filter_parameters OWNER TO engine;

--
-- Name: getallfromvminterfacefilterparameters(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvminterfacefilterparameters() RETURNS SETOF public.vm_interface_filter_parameters
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface_filter_parameters.*
    FROM vm_interface_filter_parameters;
END;$$;


ALTER FUNCTION public.getallfromvminterfacefilterparameters() OWNER TO engine;

--
-- Name: getallfromvminterfaces(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvminterfaces() RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface;
END;$$;


ALTER FUNCTION public.getallfromvminterfaces() OWNER TO engine;

--
-- Name: vm_interface_statistics; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_interface_statistics (
    id uuid NOT NULL,
    vm_id uuid,
    rx_rate numeric(24,4),
    tx_rate numeric(24,4),
    rx_drop numeric(20,0),
    tx_drop numeric(20,0),
    iface_status integer,
    _update_date timestamp with time zone,
    rx_total numeric(20,0),
    rx_offset numeric(20,0),
    tx_total numeric(20,0),
    tx_offset numeric(20,0),
    sample_time double precision
);


ALTER TABLE public.vm_interface_statistics OWNER TO engine;

--
-- Name: vnic_profiles; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vnic_profiles (
    id uuid NOT NULL,
    name character varying(256) NOT NULL,
    network_id uuid NOT NULL,
    port_mirroring boolean NOT NULL,
    custom_properties text,
    description text,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone,
    network_qos_id uuid,
    passthrough boolean DEFAULT false NOT NULL,
    network_filter_id uuid,
    migratable boolean DEFAULT false NOT NULL,
    failover_vnic_profile_id uuid
);


ALTER TABLE public.vnic_profiles OWNER TO engine;

--
-- Name: vm_interface_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_interface_view AS
 SELECT vm_interface_statistics.rx_rate,
    vm_interface_statistics.tx_rate,
    vm_interface_statistics.rx_drop,
    vm_interface_statistics.tx_drop,
    vm_interface_statistics.rx_total,
    vm_interface_statistics.tx_total,
    vm_interface_statistics.rx_offset,
    vm_interface_statistics.tx_offset,
    vm_interface_statistics.iface_status,
    vm_interface_statistics.sample_time,
    vm_interface.type,
    vm_interface.speed,
    vm_interface.mac_addr,
    vm_interface.synced,
    network.name AS network_name,
    vm_interface.name,
    vm_interface.vnic_profile_id,
    vm_static.vm_guid,
    vm_static.vm_name,
    vm_interface.id,
    0 AS boot_protocol,
    0 AS is_vds,
    vm_device.is_plugged,
    vm_device.custom_properties,
    vnic_profiles.port_mirroring,
    vm_interface.linked,
    vm_static.cluster_id,
    vm_static.entity_type AS vm_entity_type,
    vnic_profiles.name AS vnic_profile_name,
    qos.name AS qos_name,
    failover_vnic_profile.name AS failover_vnic_profile_name
   FROM ((((public.vm_interface_statistics
     JOIN public.vm_interface ON ((vm_interface_statistics.id = vm_interface.id)))
     JOIN public.vm_static ON ((vm_interface.vm_guid = vm_static.vm_guid)))
     JOIN public.vm_device ON (((vm_interface.vm_guid = vm_device.vm_id) AND (vm_interface.id = vm_device.device_id))))
     LEFT JOIN (((public.vnic_profiles
     JOIN public.network ON ((network.id = vnic_profiles.network_id)))
     LEFT JOIN public.qos ON ((vnic_profiles.network_qos_id = qos.id)))
     LEFT JOIN public.vnic_profiles failover_vnic_profile ON ((vnic_profiles.failover_vnic_profile_id = failover_vnic_profile.id))) ON ((vnic_profiles.id = vm_interface.vnic_profile_id)))
  WHERE ((vm_static.entity_type)::text = 'VM'::text)
UNION
 SELECT vm_interface_statistics.rx_rate,
    vm_interface_statistics.tx_rate,
    vm_interface_statistics.rx_drop,
    vm_interface_statistics.tx_drop,
    vm_interface_statistics.rx_total,
    vm_interface_statistics.tx_total,
    vm_interface_statistics.rx_offset,
    vm_interface_statistics.tx_offset,
    vm_interface_statistics.iface_status,
    vm_interface_statistics.sample_time,
    vm_interface.type,
    vm_interface.speed,
    vm_interface.mac_addr,
    vm_interface.synced,
    network.name AS network_name,
    vm_interface.name,
    vm_interface.vnic_profile_id,
    vm_templates.vm_guid,
    vm_templates.vm_name,
    vm_interface.id,
    0 AS boot_protocol,
    0 AS is_vds,
    vm_device.is_plugged,
    vm_device.custom_properties,
    vnic_profiles.port_mirroring,
    vm_interface.linked,
    vm_templates.cluster_id,
    vm_templates.entity_type AS vm_entity_type,
    vnic_profiles.name AS vnic_profile_name,
    qos.name AS qos_name,
    failover_vnic_profile.name AS failover_vnic_profile_name
   FROM ((((public.vm_interface_statistics
     RIGHT JOIN public.vm_interface ON ((vm_interface_statistics.id = vm_interface.id)))
     JOIN public.vm_static vm_templates ON ((vm_interface.vm_guid = vm_templates.vm_guid)))
     JOIN public.vm_device ON (((vm_interface.vm_guid = vm_device.vm_id) AND (vm_interface.id = vm_device.device_id))))
     LEFT JOIN (((public.vnic_profiles
     JOIN public.network ON ((network.id = vnic_profiles.network_id)))
     LEFT JOIN public.qos ON ((vnic_profiles.network_qos_id = qos.id)))
     LEFT JOIN public.vnic_profiles failover_vnic_profile ON ((vnic_profiles.failover_vnic_profile_id = failover_vnic_profile.id))) ON ((vnic_profiles.id = vm_interface.vnic_profile_id)))
  WHERE ((vm_templates.entity_type)::text = 'TEMPLATE'::text);


ALTER TABLE public.vm_interface_view OWNER TO engine;

--
-- Name: getallfromvmnetworkinterfaceviews(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmnetworkinterfaceviews() RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_view;
END;$$;


ALTER FUNCTION public.getallfromvmnetworkinterfaceviews() OWNER TO engine;

--
-- Name: vm_pools_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_pools_view AS
 SELECT vm_pools.vm_pool_id,
    vm_pools.vm_pool_name,
    vm_pools.vm_pool_description,
    vm_pools.vm_pool_comment,
    vm_pools.vm_pool_type,
    vm_pools.stateful,
    vm_pools.parameters,
    vm_pools.prestarted_vms,
    vm_pools.cluster_id,
    cluster.name AS cluster_name,
    cluster.architecture,
    storage_pool.name AS storage_pool_name,
    storage_pool.id AS storage_pool_id,
    vm_pools.max_assigned_vms_per_user,
    vm_pools.spice_proxy,
    vm_pools.is_being_destroyed,
    vm_pools.is_auto_storage_select
   FROM ((public.vm_pools
     JOIN public.cluster ON ((vm_pools.cluster_id = cluster.cluster_id)))
     LEFT JOIN public.storage_pool ON ((storage_pool.id = cluster.storage_pool_id)));


ALTER TABLE public.vm_pools_view OWNER TO engine;

--
-- Name: getallfromvmpoolsfilteredandsorted(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmpoolsfilteredandsorted(v_user_id uuid, v_offset integer, v_limit integer) RETURNS SETOF public.vm_pools_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT pools.*
    FROM vm_pools_view pools
    INNER JOIN user_vm_pool_permissions_view
        ON user_id = v_user_id
            AND entity_id = pools.vm_pool_id
    ORDER BY pools.vm_pool_name ASC
    LIMIT v_limit OFFSET v_offset;
END;$$;


ALTER FUNCTION public.getallfromvmpoolsfilteredandsorted(v_user_id uuid, v_offset integer, v_limit integer) OWNER TO engine;

--
-- Name: getallfromvms(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvms(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
IF v_is_filtered THEN
   RETURN QUERY SELECT vms.*
      FROM vms INNER JOIN user_vm_permissions_view ON vms.vm_guid = user_vm_permissions_view.entity_id
      WHERE user_id = v_user_id
      ORDER BY vm_guid;
ELSE
   RETURN QUERY SELECT DISTINCT vms.*
      FROM vms
      ORDER BY vm_guid;
END IF;

END; $$;


ALTER FUNCTION public.getallfromvms(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallfromvmsfilteredandsorted(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmsfilteredandsorted(v_user_id uuid, v_offset integer, v_limit integer) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
      FROM (
          -- VMs that are not part of a pool that the user has direct or inherited permissions on
          SELECT vms.*
          FROM vms INNER JOIN user_vm_permissions_view ON vms.vm_guid = user_vm_permissions_view.entity_id
          WHERE vm_pool_id IS NULL
              AND user_id = v_user_id
          UNION
          -- VMs that are part of a pool that the user has direct permissions on
          SELECT vms.*
          FROM vms INNER JOIN permissions ON vms.vm_guid = permissions.object_id
          WHERE vm_pool_id IS NOT NULL
              AND ad_element_id = v_user_id
      ) result
      ORDER BY vm_name ASC
      LIMIT v_limit OFFSET v_offset;
END; $$;


ALTER FUNCTION public.getallfromvmsfilteredandsorted(v_user_id uuid, v_offset integer, v_limit integer) OWNER TO engine;

--
-- Name: vm_static_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_static_view AS
 SELECT vm_static.vm_guid,
    vm_static.vm_name,
    vm_static.mem_size_mb,
    vm_static.vmt_guid,
    vm_static.os,
    vm_static.description,
    vm_static.cluster_id,
    vm_static.creation_date,
    vm_static.num_of_monitors,
    vm_static.is_initialized,
    vm_static.is_auto_suspend,
    vm_static.num_of_sockets,
    vm_static.cpu_per_socket,
    vm_static.usb_policy,
    vm_static.time_zone,
    vm_static.is_stateless,
    vm_static._create_date,
    vm_static._update_date,
    vm_static.auto_startup,
    vm_static.vm_type,
    vm_static.nice_level,
    vm_static.default_boot_sequence,
    vm_static.default_display_type,
    vm_static.priority,
    vm_static.iso_path,
    vm_static.origin,
    vm_static.initrd_url,
    vm_static.kernel_url,
    vm_static.kernel_params,
    vm_static.migration_support,
    vm_static.userdefined_properties,
    vm_static.predefined_properties,
    vm_static.min_allocated_mem,
    vm_static.entity_type,
    vm_static.child_count,
    vm_static.template_status,
    vm_static.quota_id,
    vm_static.allow_console_reconnect,
    vm_static.cpu_pinning,
    vm_static.is_smartcard_enabled,
    vm_static.host_cpu_flags,
    vm_static.db_generation,
    vm_static.is_delete_protected,
    vm_static.is_disabled,
    vm_static.is_run_and_pause,
    vm_static.created_by_user_id,
    vm_static.tunnel_migration,
    vm_static.free_text_comment,
    vm_static.cpu_shares,
    vm_static.vnc_keyboard_layout,
    vm_static.instance_type_id,
    vm_static.image_type_id,
    vm_static.sso_method,
    vm_static.original_template_id,
    vm_static.original_template_name,
    vm_static.migration_downtime,
    vm_static.template_version_number,
    vm_static.template_version_name,
    vm_static.serial_number_policy,
    vm_static.custom_serial_number,
    vm_static.is_boot_menu_enabled,
    vm_static.is_spice_file_transfer_enabled,
    vm_static.is_spice_copy_paste_enabled,
    vm_static.cpu_profile_id,
    vm_static.is_auto_converge,
    vm_static.is_migrate_compressed,
    vm_static.custom_emulated_machine,
    vm_static.custom_cpu_name,
    vm_static.small_icon_id,
    vm_static.large_icon_id,
    vm_static.provider_id,
    vm_static.num_of_io_threads,
    vm_static.console_disconnect_action,
    vm_static.threads_per_cpu,
    vm_static.custom_compatibility_version,
    vm_static.migration_policy_id,
    vm_static.max_memory_size_mb,
    vm_static.lease_sd_id,
    vm_static.resume_behavior,
    vm_static.multi_queues_enabled,
    vm_static.is_migrate_encrypted,
    vm_static.use_tsc_frequency,
    vm_static.namespace,
    vm_static.is_template_sealed,
    vm_static.bios_type,
    vm_static.balloon_enabled,
    vm_static.virtio_scsi_multi_queues,
    vm_static.console_disconnect_action_delay,
    vm_static.cpu_pinning_policy,
    vm_static.parallel_migrations,
    public.fn_get_dedicated_hosts_ids_by_vm_id(vm_static.vm_guid) AS dedicated_vm_for_vds
   FROM public.vm_static;


ALTER TABLE public.vm_static_view OWNER TO engine;

--
-- Name: getallfromvmstatic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmstatic() RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE entity_type = 'VM';
END; $$;


ALTER FUNCTION public.getallfromvmstatic() OWNER TO engine;

--
-- Name: getallfromvmstaticbystoragepoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmstaticbystoragepoolid(v_sp_id uuid) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view INNER JOIN
        cluster ON vm_static_view.cluster_id = cluster.cluster_id LEFT OUTER JOIN
        storage_pool ON vm_static_view.cluster_id = cluster.cluster_id
        AND cluster.storage_pool_id = storage_pool.id
   WHERE v_sp_id = storage_pool.id
       AND entity_type = 'VM';

END; $$;


ALTER FUNCTION public.getallfromvmstaticbystoragepoolid(v_sp_id uuid) OWNER TO engine;

--
-- Name: getallfromvmstatistics(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmstatistics() RETURNS SETOF public.vm_statistics
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_statistics.*
    FROM vm_statistics;
END;$$;


ALTER FUNCTION public.getallfromvmstatistics() OWNER TO engine;

--
-- Name: getallfromvmtemplates(uuid, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvmtemplates(v_user_id uuid, v_is_filtered boolean, v_entity_type character varying) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE entity_type = v_entity_type
          AND (NOT v_is_filtered OR EXISTS (SELECT 1
              FROM   user_vm_template_permissions_view
              WHERE  user_id = v_user_id
                  AND entity_id = vmt_guid))
      ORDER BY name;
END; $$;


ALTER FUNCTION public.getallfromvmtemplates(v_user_id uuid, v_is_filtered boolean, v_entity_type character varying) OWNER TO engine;

--
-- Name: getallfromvnicprofiles(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvnicprofiles() RETURNS SETOF public.vnic_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles;
END;$$;


ALTER FUNCTION public.getallfromvnicprofiles() OWNER TO engine;

--
-- Name: network_filter; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.network_filter (
    filter_id uuid NOT NULL,
    filter_name character varying(50) NOT NULL,
    version character varying(40) NOT NULL
);


ALTER TABLE public.network_filter OWNER TO engine;

--
-- Name: vnic_profiles_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vnic_profiles_view AS
 SELECT vnic_profiles.id,
    vnic_profiles.name,
    vnic_profiles.network_id,
    vnic_profiles.network_qos_id,
    vnic_profiles.port_mirroring,
    vnic_profiles.passthrough,
    vnic_profiles.migratable,
    vnic_profiles.custom_properties,
    vnic_profiles.description,
    vnic_profiles.network_filter_id,
    vnic_profiles.failover_vnic_profile_id,
    network_filter.filter_name AS network_filter_name,
    network.name AS network_name,
    qos.name AS network_qos_name,
    storage_pool.name AS data_center_name,
    storage_pool.compatibility_version,
    storage_pool.id AS data_center_id,
    failover_vnic_profiles.name AS failover_vnic_profile_name
   FROM (((((public.vnic_profiles
     JOIN public.network ON ((vnic_profiles.network_id = network.id)))
     LEFT JOIN public.qos ON ((vnic_profiles.network_qos_id = qos.id)))
     JOIN public.storage_pool ON ((network.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.network_filter ON ((vnic_profiles.network_filter_id = network_filter.filter_id)))
     LEFT JOIN public.vnic_profiles failover_vnic_profiles ON ((vnic_profiles.failover_vnic_profile_id = failover_vnic_profiles.id)));


ALTER TABLE public.vnic_profiles_view OWNER TO engine;

--
-- Name: getallfromvnicprofileviews(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallfromvnicprofileviews(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE NOT v_is_filtered
        OR EXISTS (
            SELECT 1
            FROM user_vnic_profile_permissions_view
            WHERE user_id = v_user_id
                AND entity_id = vnic_profiles_view.id
            );
END;$$;


ALTER FUNCTION public.getallfromvnicprofileviews(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: gluster_georep_session; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_georep_session (
    session_id uuid NOT NULL,
    master_volume_id uuid NOT NULL,
    session_key character varying(150) NOT NULL,
    slave_host_uuid uuid,
    slave_host_name character varying(50),
    slave_volume_id uuid,
    slave_volume_name character varying(50),
    status character varying,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    user_name character varying(255)
);


ALTER TABLE public.gluster_georep_session OWNER TO engine;

--
-- Name: gluster_volumes; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volumes (
    id uuid NOT NULL,
    cluster_id uuid NOT NULL,
    vol_name character varying(1000) NOT NULL,
    vol_type character varying(32) NOT NULL,
    status character varying(32) NOT NULL,
    replica_count integer DEFAULT 0 NOT NULL,
    stripe_count integer DEFAULT 0 NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone,
    task_id uuid,
    snapshot_count integer DEFAULT 0 NOT NULL,
    snapshot_scheduled boolean DEFAULT false,
    disperse_count integer DEFAULT 0 NOT NULL,
    redundancy_count integer DEFAULT 0 NOT NULL,
    is_arbiter boolean DEFAULT false
);


ALTER TABLE public.gluster_volumes OWNER TO engine;

--
-- Name: gluster_georep_sessions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_georep_sessions_view AS
 SELECT georep.session_id,
    georep.master_volume_id,
    georep.session_key,
    georep.slave_host_uuid,
    georep.slave_host_name,
    georep.slave_volume_id,
    georep.slave_volume_name,
    georep.status,
    georep._create_date,
    georep._update_date,
    gluster_volumes.vol_name AS master_volume_name,
    gluster_volumes.cluster_id,
    georep.user_name
   FROM (public.gluster_georep_session georep
     JOIN public.gluster_volumes ON ((gluster_volumes.id = georep.master_volume_id)));


ALTER TABLE public.gluster_georep_sessions_view OWNER TO engine;

--
-- Name: getallglustergeorepsessions(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallglustergeorepsessions() RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view;
END;$$;


ALTER FUNCTION public.getallglustergeorepsessions() OWNER TO engine;

--
-- Name: gluster_scheduler_job_details; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_scheduler_job_details (
    job_id uuid NOT NULL,
    job_name character varying(300) NOT NULL,
    job_class_name character varying(300) NOT NULL,
    cron_schedule character varying(300) NOT NULL,
    start_date date,
    end_date date,
    timezone character varying(300)
);


ALTER TABLE public.gluster_scheduler_job_details OWNER TO engine;

--
-- Name: getallglusterschedulerjobs(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallglusterschedulerjobs() RETURNS SETOF public.gluster_scheduler_job_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_scheduler_job_details;
END;$$;


ALTER FUNCTION public.getallglusterschedulerjobs() OWNER TO engine;

--
-- Name: ad_groups; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.ad_groups (
    id uuid NOT NULL,
    name character varying(256) DEFAULT ''::character varying NOT NULL,
    domain character varying(100) DEFAULT ''::character varying NOT NULL,
    distinguishedname character varying(4000) DEFAULT ''::character varying NOT NULL,
    external_id text NOT NULL,
    namespace character varying(2048) DEFAULT '*'::character varying
);


ALTER TABLE public.ad_groups OWNER TO engine;

--
-- Name: getallgroups(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallgroups() RETURNS SETOF public.ad_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM ad_groups;
END;$$;


ALTER FUNCTION public.getallgroups() OWNER TO engine;

--
-- Name: getallhashesfromvmdynamic(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallhashesfromvmdynamic() RETURNS SETOF public.getallhashesfromvmdynamic_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_guid, hash
    FROM vm_dynamic;
END; $$;


ALTER FUNCTION public.getallhashesfromvmdynamic() OWNER TO engine;

--
-- Name: getallhostnetworkqos(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallhostnetworkqos() RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
      FROM qos WHERE
        qos_type = 4 AND
        EXISTS (
            SELECT 1
            FROM user_network_permissions_view
            INNER JOIN network_view
                ON network_view.id = user_network_permissions_view.entity_id
            WHERE network_view.qos_id = qos.id
                AND user_network_permissions_view.user_id = v_user_id
        );

END;$$;


ALTER FUNCTION public.getallhostnetworkqos() OWNER TO engine;

--
-- Name: getalljobidsbyentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalljobidsbyentityid(v_entity_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT job_subject_entity.job_id
    FROM job_subject_entity
    WHERE entity_id = v_entity_id;
END;$$;


ALTER FUNCTION public.getalljobidsbyentityid(v_entity_id uuid) OWNER TO engine;

--
-- Name: getalljobs(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalljobs() RETURNS SETOF public.job
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT job.*
    FROM JOB
    WHERE status != 'UNKNOWN'
    ORDER BY start_time DESC;
END;$$;


ALTER FUNCTION public.getalljobs() OWNER TO engine;

--
-- Name: labels_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.labels_map_view AS
SELECT
    NULL::uuid AS label_id,
    NULL::character varying(50) AS label_name,
    NULL::boolean AS read_only,
    NULL::boolean AS has_implicit_affinity_group,
    NULL::text[] AS vm_ids,
    NULL::text[] AS vds_ids;


ALTER TABLE public.labels_map_view OWNER TO engine;

--
-- Name: getalllabels(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalllabels() RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view;
END;$$;


ALTER FUNCTION public.getalllabels() OWNER TO engine;

--
-- Name: getalllabelsforcluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalllabelsforcluster(v_cluster_id uuid) RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view
    WHERE label_id IN (
        SELECT DISTINCT label_id
        FROM labels_map
            LEFT JOIN vds_static ON vds_static.vds_id = labels_map.vds_id
            LEFT JOIN vm_static ON vm_static.vm_guid = labels_map.vm_id
        WHERE vds_static.cluster_id = v_cluster_id OR
            vm_static.cluster_id = v_cluster_id
    );
END;$$;


ALTER FUNCTION public.getalllabelsforcluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getalllibvirtsecretsbyproviderid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalllibvirtsecretsbyproviderid(v_provider_id uuid) RETURNS SETOF public.libvirt_secrets
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM libvirt_secrets
    WHERE provider_id = v_provider_id;
END;$$;


ALTER FUNCTION public.getalllibvirtsecretsbyproviderid(v_provider_id uuid) OWNER TO engine;

--
-- Name: mac_pool_ranges; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.mac_pool_ranges (
    mac_pool_id uuid NOT NULL,
    from_mac character varying(17) NOT NULL,
    to_mac character varying(17) NOT NULL
);


ALTER TABLE public.mac_pool_ranges OWNER TO engine;

--
-- Name: getallmacpoolrangesbymacpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallmacpoolrangesbymacpoolid(v_id uuid) RETURNS SETOF public.mac_pool_ranges
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM mac_pool_ranges
    WHERE mac_pool_id = v_id;
END;$$;


ALTER FUNCTION public.getallmacpoolrangesbymacpoolid(v_id uuid) OWNER TO engine;

--
-- Name: getallmacsbymacpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallmacsbymacpoolid(v_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT mac_addr
    FROM vm_interface
    WHERE EXISTS (
            SELECT 1
            FROM vm_static
            INNER JOIN cluster c
                ON vm_static.cluster_id = c.cluster_id
            WHERE c.mac_pool_id = v_id
                AND vm_static.vm_guid = vm_interface.vm_guid
            );
END;$$;


ALTER FUNCTION public.getallmacsbymacpoolid(v_id uuid) OWNER TO engine;

--
-- Name: getallmanagementnetworksbydatacenterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallmanagementnetworksbydatacenterid(v_data_center_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    INNER JOIN network_cluster
        ON network.id = network_cluster.network_id
    INNER JOIN cluster
        ON network_cluster.cluster_id = cluster.cluster_id
    WHERE cluster.storage_pool_id = v_data_center_id
        AND network_cluster.management;
END;$$;


ALTER FUNCTION public.getallmanagementnetworksbydatacenterid(v_data_center_id uuid) OWNER TO engine;

--
-- Name: getallmetadataandmemorydisksforstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallmetadataandmemorydisksforstoragedomain(v_storage_domain_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY SELECT isdv.disk_id
    FROM images_storage_domain_view isdv
    INNER JOIN snapshots s
    ON (s.memory_dump_disk_id = isdv.disk_id OR s.memory_metadata_disk_id = isdv.disk_id)
    AND isdv.storage_id = v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getallmetadataandmemorydisksforstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getallnetworkbyclusterid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworkbyclusterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.networkviewclustertype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT network.id,
        network.name,
        network.vdsm_name,
        network.description,
        network.free_text_comment,
        network.type,
        network.addr,
        network.subnet,
        network.gateway,
        network.vlan_id,
        network.stp,
        network.storage_pool_id,
        network.mtu,
        network.vm_network,
        network.label,
        network.provider_network_provider_id,
        network.provider_network_external_id,
        network.provider_physical_network_id,
        network.qos_id,
        network.dns_resolver_configuration_id,
        network.port_isolation,
        network_cluster.network_id,
        network_cluster.cluster_id,
        network_cluster.status,
        network_cluster.is_display,
        network_cluster.required,
        network_cluster.migration,
        network_cluster.management,
        network_cluster.is_gluster,
        network_cluster.default_route
    FROM network
    INNER JOIN network_cluster
        ON network.id = network_cluster.network_id
    WHERE network_cluster.cluster_id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_network_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = network.id
                )
            )
    ORDER BY network.name;
END;$$;


ALTER FUNCTION public.getallnetworkbyclusterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallnetworkbystoragepoolid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworkbystoragepoolid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network
    WHERE storage_pool_id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_network_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = network.id
                )
            );
END;$$;


ALTER FUNCTION public.getallnetworkbystoragepoolid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallnetworkfilters(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworkfilters() RETURNS SETOF public.network_filter
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_filter;
END;$$;


ALTER FUNCTION public.getallnetworkfilters() OWNER TO engine;

--
-- Name: getallnetworklabelsbydatacenterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworklabelsbydatacenterid(v_id uuid) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT label
    FROM network
    WHERE network.storage_pool_id = v_id
        AND label IS NOT NULL;
END;$$;


ALTER FUNCTION public.getallnetworklabelsbydatacenterid(v_id uuid) OWNER TO engine;

--
-- Name: getallnetworkqos(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworkqos(v_user_id uuid) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
      FROM qos WHERE
        qos_type = 3 AND
        EXISTS (
            SELECT 1
            FROM user_vnic_profile_permissions_view
            INNER JOIN vnic_profiles_view
                ON vnic_profiles_view.id = user_vnic_profile_permissions_view.entity_id
            WHERE vnic_profiles_view.network_qos_id = qos.id
                AND user_vnic_profile_permissions_view.user_id = v_user_id
        );

END;$$;


ALTER FUNCTION public.getallnetworkqos(v_user_id uuid) OWNER TO engine;

--
-- Name: getallnetworksbynetworkproviderid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworksbynetworkproviderid(v_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network
    WHERE provider_network_provider_id = v_id;
END;$$;


ALTER FUNCTION public.getallnetworksbynetworkproviderid(v_id uuid) OWNER TO engine;

--
-- Name: getallnetworksbyproviderphysicalnetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworksbyproviderphysicalnetworkid(v_network_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    WHERE provider_physical_network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getallnetworksbyproviderphysicalnetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getallnetworksbyqosid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworksbyqosid(v_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network
    WHERE qos_id = v_id;
END;$$;


ALTER FUNCTION public.getallnetworksbyqosid(v_id uuid) OWNER TO engine;

--
-- Name: network_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.network_view AS
 SELECT network.id,
    network.name,
    network.vdsm_name,
    network.description,
    network.free_text_comment,
    network.type,
    network.addr,
    network.subnet,
    network.gateway,
    network.vlan_id,
    network.stp,
    network.mtu,
    network.vm_network,
    network.storage_pool_id,
    network.provider_network_provider_id,
    network.provider_network_external_id,
    network.provider_physical_network_id,
    network.qos_id,
    network.dns_resolver_configuration_id,
    network.label,
    network.port_isolation,
    storage_pool.name AS storage_pool_name,
    storage_pool.compatibility_version,
    providers.name AS provider_name,
    qos.name AS qos_name
   FROM (((public.network
     JOIN public.storage_pool ON ((network.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.providers ON ((network.provider_network_provider_id = providers.id)))
     LEFT JOIN public.qos ON ((qos.id = network.qos_id)));


ALTER TABLE public.network_view OWNER TO engine;

--
-- Name: getallnetworkviewsbynetworkproviderid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnetworkviewsbynetworkproviderid(v_id uuid) RETURNS SETOF public.network_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_view
    WHERE provider_network_provider_id = v_id;
END;$$;


ALTER FUNCTION public.getallnetworkviewsbynetworkproviderid(v_id uuid) OWNER TO engine;

--
-- Name: getallnonadminroles(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallnonadminroles(v_app_mode integer) RETURNS SETOF public.roles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM roles
   WHERE (roles.app_mode & v_app_mode) > 0
      AND role_type != 1;

END; $$;


ALTER FUNCTION public.getallnonadminroles(v_app_mode integer) OWNER TO engine;

--
-- Name: getallovfentitiesforstoragedomainbyentitytype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallovfentitiesforstoragedomainbyentitytype(v_storage_domain_id uuid, v_entity_type character varying) RETURNS SETOF public.unregistered_ovf_of_entities
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM unregistered_ovf_of_entities
    WHERE storage_domain_id = v_storage_domain_id
        AND (
            entity_type = v_entity_type
            OR v_entity_type IS NULL
            );
END;$$;


ALTER FUNCTION public.getallovfentitiesforstoragedomainbyentitytype(v_storage_domain_id uuid, v_entity_type character varying) OWNER TO engine;

--
-- Name: user_profiles; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.user_profiles (
    user_id uuid NOT NULL,
    property_id uuid NOT NULL,
    property_type text DEFAULT 'UNKNOWN'::text NOT NULL,
    property_name text DEFAULT 'UNKNOWN'::text NOT NULL,
    property_content jsonb
);


ALTER TABLE public.user_profiles OWNER TO engine;

--
-- Name: user_profiles_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_profiles_view AS
 SELECT user_profiles.user_id,
    user_profiles.property_id,
    user_profiles.property_type,
    user_profiles.property_name,
    user_profiles.property_content,
    (((users.username)::text || '@'::text) || (users.domain)::text) AS login_name
   FROM (public.user_profiles
     JOIN public.users ON ((user_profiles.user_id = users.user_id)));


ALTER TABLE public.user_profiles_view OWNER TO engine;

--
-- Name: getallpublicsshkeysfromuserprofiles(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallpublicsshkeysfromuserprofiles() RETURNS SETOF public.user_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT user_profiles_view.*
    FROM user_profiles_view
    WHERE user_profiles_view.property_type = 'SSH_PUBLIC_KEY';
END;$$;


ALTER FUNCTION public.getallpublicsshkeysfromuserprofiles() OWNER TO engine;

--
-- Name: getallqosbyqostype(smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallqosbyqostype(v_qos_type smallint) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos
    WHERE qos_type = v_qos_type;

END;$$;


ALTER FUNCTION public.getallqosbyqostype(v_qos_type smallint) OWNER TO engine;

--
-- Name: getallqosforstoragepool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallqosforstoragepool(v_storage_pool_id uuid) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos
    WHERE storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getallqosforstoragepool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getallqosforstoragepoolbyqostype(uuid, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallqosforstoragepoolbyqostype(v_storage_pool_id uuid, v_qos_type smallint) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos
    WHERE storage_pool_id = v_storage_pool_id
        AND qos_type = v_qos_type;
END;$$;


ALTER FUNCTION public.getallqosforstoragepoolbyqostype(v_storage_pool_id uuid, v_qos_type smallint) OWNER TO engine;

--
-- Name: getallrunningvmsforuserandactiongroup(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallrunningvmsforuserandactiongroup(v_user_id uuid, v_action_group_id integer) RETURNS SETOF public.vm_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vm_dynamic.*
      FROM vm_dynamic, vm_permissions_view, permissions_view, engine_session_user_flat_groups
      WHERE vm_dynamic.run_on_vds IS NOT NULL
          AND   vm_dynamic.vm_guid = vm_permissions_view.entity_id
          AND   vm_permissions_view.user_id = v_user_id
          AND   engine_session_user_flat_groups.user_id = vm_permissions_view.user_id
          -- check the user has permission on any parent for this vm id and Object type 2 (vm)
          AND   permissions_view.object_id IN (SELECT id FROM fn_get_entity_parents(vm_dynamic.vm_guid, 2))
          AND   permissions_view.ad_element_id = engine_session_user_flat_groups.granted_id
          AND   permissions_view.role_id IN (SELECT role_id FROM roles_groups WHERE action_group_id = v_action_group_id)
      ORDER BY vm_guid;
END; $$;


ALTER FUNCTION public.getallrunningvmsforuserandactiongroup(v_user_id uuid, v_action_group_id integer) OWNER TO engine;

--
-- Name: getallsnapshotsbymemorydisk(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallsnapshotsbymemorydisk(v_memory_disk_id uuid) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots
    WHERE v_memory_disk_id IN (memory_dump_disk_id, memory_metadata_disk_id);
END; $$;


ALTER FUNCTION public.getallsnapshotsbymemorydisk(v_memory_disk_id uuid) OWNER TO engine;

--
-- Name: getallsnapshotsbystoragedomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallsnapshotsbystoragedomainid(v_storage_id uuid) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT snapshots.*
    FROM snapshots
    INNER JOIN images
        ON snapshots.snapshot_id = images.vm_snapshot_id
    INNER JOIN image_storage_domain_map
        ON image_storage_domain_map.storage_domain_id = v_storage_id
            AND image_storage_domain_map.image_id = images.image_guid;
END;$$;


ALTER FUNCTION public.getallsnapshotsbystoragedomainid(v_storage_id uuid) OWNER TO engine;

--
-- Name: getallsteps(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallsteps() RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.*
    FROM step;
END;$$;


ALTER FUNCTION public.getallsteps() OWNER TO engine;

--
-- Name: storage_server_connections; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_server_connections (
    id character varying(50) NOT NULL,
    connection character varying(250) NOT NULL,
    user_name text,
    password text,
    iqn character varying(128),
    port character varying(50),
    portal character varying(50),
    storage_type integer NOT NULL,
    mount_options character varying(500),
    vfs_type character varying(128),
    nfs_version character varying(4),
    nfs_timeo smallint,
    nfs_retrans smallint,
    gluster_volume_id uuid
);


ALTER TABLE public.storage_server_connections OWNER TO engine;

--
-- Name: getallstorage_server_connections(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallstorage_server_connections() RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections;
END;$$;


ALTER FUNCTION public.getallstorage_server_connections() OWNER TO engine;

--
-- Name: getallstorageqos(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallstorageqos(v_user_id uuid) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
      FROM qos WHERE
        qos_type = 1 AND
        EXISTS (
            SELECT 1
            FROM user_storage_domain_permissions_view
            INNER JOIN storage_pool
                ON storage_pool.id = user_storage_domain_permissions_view.entity_id
            WHERE storage_pool.id = qos.storage_pool_id
                AND user_storage_domain_permissions_view.user_id = v_user_id
        );

END;$$;


ALTER FUNCTION public.getallstorageqos(v_user_id uuid) OWNER TO engine;

--
-- Name: cluster_features; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cluster_features (
    feature_id uuid NOT NULL,
    feature_name character varying(256) NOT NULL,
    version character varying(40),
    category integer NOT NULL,
    description text
);


ALTER TABLE public.cluster_features OWNER TO engine;

--
-- Name: supported_cluster_features; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.supported_cluster_features (
    cluster_id uuid NOT NULL,
    feature_id uuid NOT NULL,
    is_enabled boolean
);


ALTER TABLE public.supported_cluster_features OWNER TO engine;

--
-- Name: supported_cluster_features_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.supported_cluster_features_view AS
 SELECT cluster_features.feature_id,
    cluster_features.feature_name,
    cluster_features.version,
    cluster_features.category,
    cluster_features.description,
    supported_cluster_features.cluster_id,
    supported_cluster_features.is_enabled
   FROM (public.cluster_features
     JOIN public.supported_cluster_features ON ((supported_cluster_features.feature_id = cluster_features.feature_id)));


ALTER TABLE public.supported_cluster_features_view OWNER TO engine;

--
-- Name: getallsupportedclusterfeatures(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallsupportedclusterfeatures() RETURNS SETOF public.supported_cluster_features_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM supported_cluster_features_view;
END;$$;


ALTER FUNCTION public.getallsupportedclusterfeatures() OWNER TO engine;

--
-- Name: getallsupportednetworkfiltersbyversion(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallsupportednetworkfiltersbyversion(v_version character varying) RETURNS SETOF public.network_filter
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_filter
    WHERE v_version >= version;
END;$$;


ALTER FUNCTION public.getallsupportednetworkfiltersbyversion(v_version character varying) OWNER TO engine;

--
-- Name: quota_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.quota_view AS
 SELECT q.id AS quota_id,
    q.storage_pool_id,
    storage_pool.name AS storage_pool_name,
    q.quota_name,
    q.description,
    q.threshold_cluster_percentage,
    q.threshold_storage_percentage,
    q.grace_cluster_percentage,
    q.grace_storage_percentage,
    storage_pool.quota_enforcement_type,
    q.is_default
   FROM public.storage_pool,
    public.quota q
  WHERE (storage_pool.id = q.storage_pool_id);


ALTER TABLE public.quota_view OWNER TO engine;

--
-- Name: getallthinquota(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallthinquota() RETURNS SETOF public.quota_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_view;
END;$$;


ALTER FUNCTION public.getallthinquota() OWNER TO engine;

--
-- Name: getallthinquotasbyclusterid(uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallthinquotasbyclusterid(v_cluster_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) RETURNS SETOF public.quota_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT quota_id,
        storage_pool_id,
        storage_pool_name,
        quota_name,
        description,
        threshold_cluster_percentage,
        threshold_storage_percentage,
        grace_cluster_percentage,
        grace_storage_percentage,
        quota_enforcement_type,
        is_default
    FROM quota_limitations_view
    WHERE (
            cluster_id = v_cluster_id
            OR (
                is_global
                AND NOT is_empty
                AND virtual_cpu IS NOT NULL
                AND storage_pool_id IN (
                    SELECT storage_pool_id
                    FROM cluster
                    WHERE cluster_id = v_cluster_id
                    )
                )
            )
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM permissions p
                INNER JOIN engine_session_user_flat_groups u
                    ON u.granted_id = p.ad_element_id
                WHERE u.engine_session_seq_id = v_engine_session_seq_id
                    AND p.object_type_id = 17
                    AND -- quota object
                    p.role_id = 'def0000a-0000-0000-0000-def00000000a'
                    AND -- consume quota
                    quota_id = p.object_id
                )
            );
END;$$;


ALTER FUNCTION public.getallthinquotasbyclusterid(v_cluster_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getallthinquotasbystorageid(uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallthinquotasbystorageid(v_storage_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) RETURNS SETOF public.quota_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT quota_id,
        storage_pool_id,
        storage_pool_name,
        quota_name,
        description,
        threshold_cluster_percentage,
        threshold_storage_percentage,
        grace_cluster_percentage,
        grace_storage_percentage,
        quota_enforcement_type,
        is_default
    FROM quota_limitations_view
    WHERE (
            storage_id = v_storage_id
            OR (
                is_global
                AND NOT is_empty
                AND storage_size_gb IS NOT NULL
                AND storage_pool_id IN (
                    SELECT storage_pool_id
                    FROM storage_pool_iso_map
                    WHERE storage_id = v_storage_id
                    )
                )
            )
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM permissions p
                INNER JOIN engine_session_user_flat_groups u
                    ON u.granted_id = p.ad_element_id
                WHERE u.engine_session_seq_id = v_engine_session_seq_id
                    AND p.object_type_id = 17
                    AND -- quota object
                    p.role_id = 'def0000a-0000-0000-0000-def00000000a'
                    AND -- consume quota
                    quota_id = p.object_id
                )
            );
END;$$;


ALTER FUNCTION public.getallthinquotasbystorageid(v_storage_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) OWNER TO engine;

--
-- Name: vds_kdump_status; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vds_kdump_status (
    vds_id uuid NOT NULL,
    status character varying(20) NOT NULL,
    address character varying(255) NOT NULL
);


ALTER TABLE public.vds_kdump_status OWNER TO engine;

--
-- Name: getallunfinishedvdskdumpstatus(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallunfinishedvdskdumpstatus() RETURNS SETOF public.vds_kdump_status
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds_kdump_status
    WHERE status <> 'finished';
END;$$;


ALTER FUNCTION public.getallunfinishedvdskdumpstatus() OWNER TO engine;

--
-- Name: getalluserswithpermissionsbyentityid(uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalluserswithpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    r_type int4;
BEGIN
    FOR r_type IN (
        SELECT DISTINCT role_type
        FROM permissions_view p
        WHERE object_id = v_id)
    LOOP
        RETURN QUERY SELECT *
        FROM permissions_view p
        WHERE object_id in (select id from fn_get_entity_parents(v_id, r_type))
            AND (NOT v_is_filtered OR EXISTS (
                SELECT 1
                FROM   engine_session_user_flat_groups u
                WHERE  p.ad_element_id = u.granted_id
                    AND u.engine_session_seq_id = v_engine_session_seq_id));
    END LOOP;
    RETURN;
END; $$;


ALTER FUNCTION public.getalluserswithpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getalluserswithpermissionsonentitybyentityid(uuid, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getalluserswithpermissionsonentitybyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM permissions_view
    WHERE (permissions_view.app_mode & v_app_mode) > 0
        AND object_id = v_id
        AND (NOT v_is_filtered OR EXISTS (
            SELECT 1
            FROM GetAllUsersWithPermissionsByEntityId(
                v_id,
                v_engine_session_seq_id,
                v_is_filtered)
        )
    );
END; $$;


ALTER FUNCTION public.getalluserswithpermissionsonentitybyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: getallvfsconfigbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvfsconfigbyhostid(v_host_id uuid) RETURNS SETOF public.host_nic_vfs_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT host_nic_vfs_config.*
    FROM host_nic_vfs_config
    INNER JOIN vds_interface
        ON host_nic_vfs_config.nic_id = vds_interface.id
    WHERE vds_interface.vds_id = v_host_id;
END;$$;


ALTER FUNCTION public.getallvfsconfigbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: getallvm_poolsbyuser_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvm_poolsbyuser_id(v_user_id uuid) RETURNS SETOF public.vm_pools_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT vm_pools_view.*
    FROM users_and_groups_to_vm_pool_map_view
    INNER JOIN vm_pools_view
        ON users_and_groups_to_vm_pool_map_view.vm_pool_id = vm_pools_view.vm_pool_id
    WHERE (users_and_groups_to_vm_pool_map_view.user_id = v_user_id);
END;$$;


ALTER FUNCTION public.getallvm_poolsbyuser_id(v_user_id uuid) OWNER TO engine;

--
-- Name: getallvm_poolsbyuser_id_with_groups_and_userroles(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvm_poolsbyuser_id_with_groups_and_userroles(v_user_id uuid) RETURNS SETOF public.vm_pools_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT pools.*
    FROM vm_pools_view pools
    INNER JOIN user_vm_pool_permissions_view
        ON user_id = v_user_id
            AND entity_id = pools.vm_pool_id;
END;$$;


ALTER FUNCTION public.getallvm_poolsbyuser_id_with_groups_and_userroles(v_user_id uuid) OWNER TO engine;

--
-- Name: vm_jobs; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_jobs (
    vm_job_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    job_state integer DEFAULT 0 NOT NULL,
    job_type integer NOT NULL,
    block_job_type integer,
    bandwidth integer,
    cursor_cur bigint,
    cursor_end bigint,
    image_group_id uuid
);


ALTER TABLE public.vm_jobs OWNER TO engine;

--
-- Name: getallvmjobs(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmjobs() RETURNS SETOF public.vm_jobs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_jobs.*
    FROM vm_jobs;
END;$$;


ALTER FUNCTION public.getallvmjobs() OWNER TO engine;

--
-- Name: getallvmsrelatedtodiskprofiles(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmsrelatedtodiskprofiles(v_disk_profile_ids uuid[]) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY SELECT vms.*
      FROM vms
          INNER JOIN vm_device vd ON vd.vm_id = vms.vm_guid
          INNER JOIN images ON images.image_group_id = vd.device_id
              AND images.active = TRUE
          INNER JOIN image_storage_domain_map ON image_storage_domain_map.image_id = images.image_guid
          WHERE image_storage_domain_map.disk_profile_id = ANY(v_disk_profile_ids);
END; $$;


ALTER FUNCTION public.getallvmsrelatedtodiskprofiles(v_disk_profile_ids uuid[]) OWNER TO engine;

--
-- Name: getallvmsrelatedtoquotaid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmsrelatedtoquotaid(v_quota_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vms.*
      FROM vms
      WHERE quota_id = v_quota_id
      UNION
      SELECT DISTINCT vms.*
      FROM vms
      INNER JOIN vm_device vd ON vd.vm_id = vms.vm_guid
      INNER JOIN images ON images.image_group_id = vd.device_id
          AND images.active = TRUE
      INNER JOIN image_storage_domain_map ON image_storage_domain_map.image_id = images.image_guid
      WHERE image_storage_domain_map.quota_id = v_quota_id;
END; $$;


ALTER FUNCTION public.getallvmsrelatedtoquotaid(v_quota_id uuid) OWNER TO engine;

--
-- Name: getallvmswithdisksonotherstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmswithdisksonotherstoragedomain(v_storage_domain_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT DISTINCT vms.*
      FROM vms
      INNER JOIN (SELECT vm_static.vm_guid
                  FROM vm_static
                  INNER JOIN vm_device vd ON vd.vm_id = vm_static.vm_guid
                  INNER JOIN images i ON i.image_group_id = vd.device_id
                  INNER JOIN (SELECT image_id
                              FROM image_storage_domain_map
                              WHERE image_storage_domain_map.storage_domain_id = v_storage_domain_id) isd_map
                              ON i.image_guid = isd_map.image_id WHERE entity_type = 'VM') vms_with_disks_on_storage_domain ON vms.vm_guid = vms_with_disks_on_storage_domain.vm_guid
      INNER JOIN vm_device vd ON vd.vm_id = vms.vm_guid
      INNER JOIN images i ON i.image_group_id = vd.device_id
      INNER JOIN image_storage_domain_map on i.image_guid = image_storage_domain_map.image_id
      WHERE image_storage_domain_map.storage_domain_id != v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getallvmswithdisksonotherstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getallvmtemplatesrelatedtodiskprofile(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmtemplatesrelatedtodiskprofile(v_disk_profile_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vm_templates.*
        FROM vm_templates_based_view vm_templates
        INNER JOIN vm_device vd ON vd.vm_id = vm_templates.vmt_guid
        INNER JOIN images ON images.image_group_id = vd.device_id
            AND images.active = TRUE
        INNER JOIN image_storage_domain_map ON image_storage_domain_map.image_id = images.image_guid
        WHERE image_storage_domain_map.disk_profile_id = v_disk_profile_id;
END; $$;


ALTER FUNCTION public.getallvmtemplatesrelatedtodiskprofile(v_disk_profile_id uuid) OWNER TO engine;

--
-- Name: getallvmtemplatesrelatedtoquotaid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmtemplatesrelatedtoquotaid(v_quota_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE quota_id = v_quota_id
      UNION
      SELECT DISTINCT vm_templates.*
      FROM vm_templates_based_view vm_templates
      INNER JOIN vm_device vd ON vd.vm_id = vm_templates.vmt_guid
      INNER JOIN images ON images.image_group_id = vd.device_id AND images.active = TRUE
      INNER JOIN image_storage_domain_map ON image_storage_domain_map.image_id = images.image_guid
      WHERE image_storage_domain_map.quota_id = v_quota_id;
END; $$;


ALTER FUNCTION public.getallvmtemplatesrelatedtoquotaid(v_quota_id uuid) OWNER TO engine;

--
-- Name: getallvmtemplateswithdisksonotherstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getallvmtemplateswithdisksonotherstoragedomain(v_storage_domain_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT templates.*
      FROM vm_templates_based_view templates
      INNER JOIN (SELECT vm_static.vm_guid
                  FROM vm_static
                  INNER JOIN vm_device vd ON vd.vm_id = vm_static.vm_guid
                  INNER JOIN images i ON i.image_group_id = vd.device_id
                  INNER JOIN (SELECT image_id
                              FROM image_storage_domain_map
                              WHERE image_storage_domain_map.storage_domain_id = v_storage_domain_id) isd_map
                              ON i.image_guid = isd_map.image_id WHERE entity_type = 'TEMPLATE') vms_with_disks_on_storage_domain ON templates.vmt_guid = vms_with_disks_on_storage_domain.vm_guid
      INNER JOIN vm_device vd ON vd.vm_id = templates.vmt_guid
      INNER JOIN images i ON i.image_group_id = vd.device_id
      INNER JOIN image_storage_domain_map on i.image_guid = image_storage_domain_map.image_id
      WHERE image_storage_domain_map.storage_domain_id != v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getallvmtemplateswithdisksonotherstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getancestralimagebyimageguid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getancestralimagebyimageguid(v_image_guid uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY WITH RECURSIVE ancestor_image(image_guid, parentid) AS (
         SELECT image_guid, parentid
         FROM images
         WHERE image_guid = v_image_guid
         UNION ALL
         SELECT i.image_guid, i.parentid
         FROM images i, ancestor_image ai
         WHERE i.image_guid = ai.parentid
     )
     SELECT i.*
     FROM ancestor_image ai, images_storage_domain_view i
     WHERE ai.parentid = '00000000-0000-0000-0000-000000000000'
         AND ai.image_guid = i.image_guid
         AND (NOT v_is_filtered OR EXISTS (
             SELECT 1
             FROM   user_disk_permissions_view
             WHERE  user_disk_permissions_view.user_id = v_user_id
             AND    user_disk_permissions_view.entity_id = i.image_group_id));
END; $$;


ALTER FUNCTION public.getancestralimagebyimageguid(v_image_guid uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getanyadminrolebyuseridandgroupids(uuid, text, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getanyadminrolebyuseridandgroupids(v_user_id uuid, v_group_ids text, v_app_mode integer) RETURNS SETOF public.roles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT roles.*
   FROM roles INNER JOIN
   permissions ON permissions.role_id = roles.id
   WHERE (roles.app_mode & v_app_mode) > 0
       AND role_type = 1 -- admin
       AND (permissions.ad_element_id = v_user_id
           OR permissions.ad_element_id in(
               SELECT id
               FROM getElementIdsByIdAndGroups(v_user_id, v_group_ids))
       ) LIMIT 1;

END; $$;


ALTER FUNCTION public.getanyadminrolebyuseridandgroupids(v_user_id uuid, v_group_ids text, v_app_mode integer) OWNER TO engine;

--
-- Name: getasync_tasksbytask_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasync_tasksbytask_id(v_task_id uuid) RETURNS SETOF public.async_tasks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM async_tasks
    WHERE task_id = v_task_id;
END;$$;


ALTER FUNCTION public.getasync_tasksbytask_id(v_task_id uuid) OWNER TO engine;

--
-- Name: async_tasks_entities; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.async_tasks_entities (
    async_task_id uuid NOT NULL,
    entity_id uuid NOT NULL,
    entity_type character varying(128)
);


ALTER TABLE public.async_tasks_entities OWNER TO engine;

--
-- Name: getasynctaskentitiesbytaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasynctaskentitiesbytaskid(v_task_id uuid) RETURNS SETOF public.async_tasks_entities
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM async_tasks_entities
    WHERE async_task_id = v_task_id;
END;$$;


ALTER FUNCTION public.getasynctaskentitiesbytaskid(v_task_id uuid) OWNER TO engine;

--
-- Name: getasynctasksbyentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasynctasksbyentityid(v_entity_id uuid) RETURNS SETOF public.async_tasks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT async_tasks.*
    FROM async_tasks
    INNER JOIN async_tasks_entities
        ON async_task_id = task_id
    WHERE entity_id = v_entity_id;
END;$$;


ALTER FUNCTION public.getasynctasksbyentityid(v_entity_id uuid) OWNER TO engine;

--
-- Name: getasynctasksbystoragepoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasynctasksbystoragepoolid(v_storage_pool_id uuid) RETURNS SETOF public.async_tasks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM async_tasks
    WHERE storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getasynctasksbystoragepoolid(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getasynctasksbyvdsmtaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasynctasksbyvdsmtaskid(v_vdsm_task_id uuid) RETURNS SETOF public.async_tasks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM async_tasks
    WHERE vdsm_task_id = v_vdsm_task_id;
END;$$;


ALTER FUNCTION public.getasynctasksbyvdsmtaskid(v_vdsm_task_id uuid) OWNER TO engine;

--
-- Name: getasynctasksidsbyentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getasynctasksidsbyentityid(v_entity_id uuid) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT async_task_id
    FROM async_tasks_entities
    WHERE entity_id = v_entity_id;
END;$$;


ALTER FUNCTION public.getasynctasksidsbyentityid(v_entity_id uuid) OWNER TO engine;

--
-- Name: getattacheddisksnapshotstovm(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getattacheddisksnapshotstovm(v_vm_guid uuid, v_is_plugged boolean) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql
    AS $$
BEGIN
     RETURN QUERY SELECT images_storage_domain_view.*
     FROM images_storage_domain_view
     JOIN vm_device ON vm_device.device_id = images_storage_domain_view.disk_id
     WHERE vm_device.vm_id = v_vm_guid AND (v_is_plugged IS NULL OR vm_device.is_plugged = v_is_plugged)
          AND vm_device.snapshot_id IS NOT NULL
          AND vm_device.snapshot_id = images_storage_domain_view.vm_snapshot_id;
END; $$;


ALTER FUNCTION public.getattacheddisksnapshotstovm(v_vm_guid uuid, v_is_plugged boolean) OWNER TO engine;

--
-- Name: getauditlogbyauditlogid(bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditlogbyauditlogid(v_audit_log_id bigint) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE audit_log_id = v_audit_log_id;
END;$$;


ALTER FUNCTION public.getauditlogbyauditlogid(v_audit_log_id bigint) OWNER TO engine;

--
-- Name: getauditlogbyoriginandcustomeventid(character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditlogbyoriginandcustomeventid(v_origin character varying, v_custom_event_id integer) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE origin = v_origin
        AND custom_event_id = v_custom_event_id;
END;$$;


ALTER FUNCTION public.getauditlogbyoriginandcustomeventid(v_origin character varying, v_custom_event_id integer) OWNER TO engine;

--
-- Name: getauditlogbyvmid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditlogbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE NOT deleted
        AND vm_id = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vm_id
                )
            );
END;$$;


ALTER FUNCTION public.getauditlogbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getauditlogbyvmtemplateid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditlogbyvmtemplateid(v_vm_template_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE NOT deleted
        AND vm_template_id = v_vm_template_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_template_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vm_template_id
                )
            );
END;$$;


ALTER FUNCTION public.getauditlogbyvmtemplateid(v_vm_template_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getauditlogbyvolumeidandtype(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditlogbyvolumeidandtype(v_gluster_volume_id uuid, v_log_type integer) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE gluster_volume_id = v_gluster_volume_id
        AND log_type = v_log_type;
END;$$;


ALTER FUNCTION public.getauditlogbyvolumeidandtype(v_gluster_volume_id uuid, v_log_type integer) OWNER TO engine;

--
-- Name: getauditloglaterthendate(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getauditloglaterthendate(v_date timestamp with time zone) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM audit_log
    WHERE NOT deleted
        AND LOG_TIME >= v_date;
END;$$;


ALTER FUNCTION public.getauditloglaterthendate(v_date timestamp with time zone) OWNER TO engine;

--
-- Name: getbackupurlfordiskid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbackupurlfordiskid(v_backup_id uuid, v_disk_id uuid) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN
    (
        SELECT backup_url
        FROM vm_backup_disk_map
        WHERE backup_id = v_backup_id AND disk_id = v_disk_id
    );
END;$$;


ALTER FUNCTION public.getbackupurlfordiskid(v_backup_id uuid, v_disk_id uuid) OWNER TO engine;

--
-- Name: getbasediskbybasediskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbasediskbybasediskid(v_disk_id uuid) RETURNS SETOF public.base_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM base_disks
    WHERE disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.getbasediskbybasediskid(v_disk_id uuid) OWNER TO engine;

--
-- Name: getbasedisksbyalias(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbasedisksbyalias(v_disk_alias character varying) RETURNS SETOF public.base_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM   base_disks
    WHERE  disk_alias = v_disk_alias;
END; $$;


ALTER FUNCTION public.getbasedisksbyalias(v_disk_alias character varying) OWNER TO engine;

--
-- Name: getbookmarkbybookmark_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbookmarkbybookmark_id(v_bookmark_id uuid) RETURNS SETOF public.bookmarks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM bookmarks
    WHERE bookmark_Id = v_bookmark_id;
END;$$;


ALTER FUNCTION public.getbookmarkbybookmark_id(v_bookmark_id uuid) OWNER TO engine;

--
-- Name: getbookmarkbybookmark_name(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbookmarkbybookmark_name(v_bookmark_name character varying) RETURNS SETOF public.bookmarks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM bookmarks
    WHERE bookmark_name = v_bookmark_name;
END;$$;


ALTER FUNCTION public.getbookmarkbybookmark_name(v_bookmark_name character varying) OWNER TO engine;

--
-- Name: gluster_volume_bricks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_bricks (
    volume_id uuid NOT NULL,
    server_id uuid NOT NULL,
    brick_dir character varying(4096) NOT NULL,
    status character varying(32) NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone,
    id uuid NOT NULL,
    brick_order integer DEFAULT 0,
    task_id uuid,
    network_id uuid,
    unsynced_entries integer,
    unsynced_entries_history text,
    is_arbiter boolean DEFAULT false
);


ALTER TABLE public.gluster_volume_bricks OWNER TO engine;

--
-- Name: gluster_volume_bricks_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_volume_bricks_view AS
 SELECT gluster_volume_bricks.volume_id,
    gluster_volume_bricks.server_id,
    gluster_volume_bricks.brick_dir,
    gluster_volume_bricks.status,
    gluster_volume_bricks._create_date,
    gluster_volume_bricks._update_date,
    gluster_volume_bricks.id,
    gluster_volume_bricks.brick_order,
    gluster_volume_bricks.task_id,
    gluster_volume_bricks.network_id,
    gluster_volume_bricks.unsynced_entries,
    gluster_volume_bricks.unsynced_entries_history,
    gluster_volume_bricks.is_arbiter,
    vds_static.host_name AS vds_name,
    gluster_volumes.vol_name AS volume_name,
    vds_interface.addr AS interface_address,
    gluster_volumes.cluster_id
   FROM ((((public.gluster_volume_bricks
     JOIN public.vds_static ON ((vds_static.vds_id = gluster_volume_bricks.server_id)))
     JOIN public.gluster_volumes ON ((gluster_volumes.id = gluster_volume_bricks.volume_id)))
     LEFT JOIN public.network ON ((network.id = gluster_volume_bricks.network_id)))
     LEFT JOIN public.vds_interface ON (((vds_interface.vds_id = gluster_volume_bricks.server_id) AND ((vds_interface.network_name)::text = (network.name)::text))));


ALTER TABLE public.gluster_volume_bricks_view OWNER TO engine;

--
-- Name: getbrickbyserveridanddirectory(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbrickbyserveridanddirectory(v_server_id uuid, v_brick_dir character varying) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE server_id = v_server_id
        AND brick_dir = v_brick_dir;
END;$$;


ALTER FUNCTION public.getbrickbyserveridanddirectory(v_server_id uuid, v_brick_dir character varying) OWNER TO engine;

--
-- Name: gluster_volume_brick_details; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_brick_details (
    brick_id uuid NOT NULL,
    total_space bigint,
    used_space bigint,
    free_space bigint,
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    confirmed_free_space bigint,
    confirmed_total_space bigint,
    vdo_savings integer
);


ALTER TABLE public.gluster_volume_brick_details OWNER TO engine;

--
-- Name: getbrickdetailsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbrickdetailsbyid(v_brick_id uuid) RETURNS SETOF public.gluster_volume_brick_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_brick_details
    WHERE brick_id = v_brick_id;
END;$$;


ALTER FUNCTION public.getbrickdetailsbyid(v_brick_id uuid) OWNER TO engine;

--
-- Name: getbricksbyclusteridandnetworkid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbricksbyclusteridandnetworkid(v_cluster_id uuid, v_network_id uuid) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE network_id = v_network_id
        AND cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getbricksbyclusteridandnetworkid(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: getbricksbyglustervolumeguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbricksbyglustervolumeguid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE volume_id = v_volume_id
    ORDER BY brick_order;
END;$$;


ALTER FUNCTION public.getbricksbyglustervolumeguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getbricksbytaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbricksbytaskid(v_task_id uuid) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE task_id = v_task_id
    ORDER BY brick_order;
END;$$;


ALTER FUNCTION public.getbricksbytaskid(v_task_id uuid) OWNER TO engine;

--
-- Name: getbynameandnamespaceforcluster(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getbynameandnamespaceforcluster(v_cluster_id uuid, v_vm_name character varying, v_namespace character varying) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE vm_name = v_vm_name
       AND namespace = v_namespace
       AND cluster_id = v_cluster_id;
END; $$;


ALTER FUNCTION public.getbynameandnamespaceforcluster(v_cluster_id uuid, v_vm_name character varying, v_namespace character varying) OWNER TO engine;

--
-- Name: cinder_storage; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.cinder_storage (
    storage_domain_id uuid NOT NULL,
    driver_options jsonb NOT NULL,
    driver_sensitive_options text
);


ALTER TABLE public.cinder_storage OWNER TO engine;

--
-- Name: getcinderstorage(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcinderstorage(v_storage_domain_id uuid) RETURNS SETOF public.cinder_storage
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cinder_storage
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.getcinderstorage(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getcinderstoragebydrivers(jsonb); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcinderstoragebydrivers(v_driver_options jsonb) RETURNS SETOF public.cinder_storage
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cinder_storage
    WHERE driver_options = v_driver_options;
END;$$;


ALTER FUNCTION public.getcinderstoragebydrivers(v_driver_options jsonb) OWNER TO engine;

--
-- Name: getclusterbyclusterid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE cluster_id = v_cluster_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_cluster_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_cluster_id
                )
            );
END;$$;


ALTER FUNCTION public.getclusterbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getclusterbyclustername(character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterbyclustername(v_cluster_name character varying, v_is_case_sensitive boolean) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE name = v_cluster_name
        OR (
            NOT v_is_case_sensitive
            AND name ilike v_cluster_name
            );
END;$$;


ALTER FUNCTION public.getclusterbyclustername(v_cluster_name character varying, v_is_case_sensitive boolean) OWNER TO engine;

--
-- Name: getclusterfeaturesbyversionandcategory(character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterfeaturesbyversionandcategory(v_version character varying, v_category integer) RETURNS SETOF public.cluster_features
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cluster_features
    WHERE cluster_features.version = v_version
        AND (cluster_features.category & v_category) > 0;
END;$$;


ALTER FUNCTION public.getclusterfeaturesbyversionandcategory(v_version character varying, v_category integer) OWNER TO engine;

--
-- Name: getclusterforuserbyclustername(character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterforuserbyclustername(v_cluster_name character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE name = v_cluster_name
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_cluster_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = cluster_id
                )
            );
END;$$;


ALTER FUNCTION public.getclusterforuserbyclustername(v_cluster_name character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getclusteridforhostbynameoraddress(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusteridforhostbynameoraddress(v_vds_name character varying, v_host_address character varying) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

        SELECT vds_static.cluster_id
        FROM vds_static
        JOIN vds_interface ON vds_static.vds_id = vds_interface.vds_id
        WHERE vds_static.vds_name = v_vds_name
            OR vds_interface.addr = v_host_address
            OR vds_interface.ipv6_address = v_host_address
        LIMIT 1;
END;$$;


ALTER FUNCTION public.getclusteridforhostbynameoraddress(v_vds_name character varying, v_host_address character varying) OWNER TO engine;

--
-- Name: getclusterpolicybyclusterpolicyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterpolicybyclusterpolicyid(v_id uuid) RETURNS SETOF public.cluster_policies
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cluster_policies
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getclusterpolicybyclusterpolicyid(v_id uuid) OWNER TO engine;

--
-- Name: getclusterpolicyunitsbyclusterpolicyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterpolicyunitsbyclusterpolicyid(v_id uuid) RETURNS SETOF public.cluster_policy_units
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cluster_policy_units
    WHERE cluster_policy_id = v_id;
END;$$;


ALTER FUNCTION public.getclusterpolicyunitsbyclusterpolicyid(v_id uuid) OWNER TO engine;

--
-- Name: getclustersbyclusterpolicyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclustersbyclusterpolicyid(v_cluster_policy_id uuid) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE cluster_policy_id = v_cluster_policy_id;
END;$$;


ALTER FUNCTION public.getclustersbyclusterpolicyid(v_cluster_policy_id uuid) OWNER TO engine;

--
-- Name: getclustersbyserviceandcompatibilityversion(boolean, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclustersbyserviceandcompatibilityversion(v_gluster_service boolean, v_virt_service boolean, v_compatibility_version character varying) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE virt_service = v_virt_service
        AND gluster_service = v_gluster_service
        AND compatibility_version = v_compatibility_version;
END;$$;


ALTER FUNCTION public.getclustersbyserviceandcompatibilityversion(v_gluster_service boolean, v_virt_service boolean, v_compatibility_version character varying) OWNER TO engine;

--
-- Name: getclustersbystoragepoolid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclustersbystoragepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE storage_pool_id = v_storage_pool_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_cluster_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = cluster_id
                )
            );
END;$$;


ALTER FUNCTION public.getclustersbystoragepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getclustershavinghosts(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclustershavinghosts() RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE EXISTS (
            SELECT 1
            FROM vds_static
            WHERE cluster_id = cluster_view.cluster_id
            );
END;$$;


ALTER FUNCTION public.getclustershavinghosts() OWNER TO engine;

--
-- Name: getclusterswithoutmigratingvms(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterswithoutmigratingvms() RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE cluster_id NOT IN (
            SELECT s.cluster_id
            FROM vm_static s
            INNER JOIN vm_dynamic d
                ON s.vm_guid = d.vm_guid
            WHERE d.status IN (
                    5,
                    6
                    )
            );
END;$$;


ALTER FUNCTION public.getclusterswithoutmigratingvms() OWNER TO engine;

--
-- Name: getclusterwithrunningvms(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getclusterwithrunningvms(v_cluster_id uuid) RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE cluster_id = v_cluster_id
        AND cluster_id IN (
            SELECT cluster_id
            FROM vms
            WHERE vms.status NOT IN (
                    0,
                    13,
                    14
                    )
            );
END;$$;


ALTER FUNCTION public.getclusterwithrunningvms(v_cluster_id uuid) OWNER TO engine;

--
-- Name: command_assoc_entities; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.command_assoc_entities (
    command_id uuid NOT NULL,
    entity_id uuid NOT NULL,
    entity_type character varying(128)
);


ALTER TABLE public.command_assoc_entities OWNER TO engine;

--
-- Name: getcommandassociatedentities(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcommandassociatedentities(v_command_id uuid) RETURNS SETOF public.command_assoc_entities
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT *
    FROM command_assoc_entities
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.getcommandassociatedentities(v_command_id uuid) OWNER TO engine;

--
-- Name: getcommandentitiesbyparentcmdid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcommandentitiesbyparentcmdid(v_root_command_id uuid) RETURNS SETOF public.command_entities
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT command_entities.*
    FROM command_entities
    WHERE root_command_id = v_root_command_id;
END;$$;


ALTER FUNCTION public.getcommandentitiesbyparentcmdid(v_root_command_id uuid) OWNER TO engine;

--
-- Name: getcommandentitybycommandentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcommandentitybycommandentityid(v_command_id uuid) RETURNS SETOF public.command_entities
    LANGUAGE plpgsql
    AS $$

BEGIN
    RETURN QUERY

    SELECT command_entities.*
    FROM command_entities
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.getcommandentitybycommandentityid(v_command_id uuid) OWNER TO engine;

--
-- Name: getcommandidsbyentityid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcommandidsbyentityid(v_entity_id uuid) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT command_id
    FROM command_assoc_entities
    WHERE entity_id = v_entity_id;
END;$$;


ALTER FUNCTION public.getcommandidsbyentityid(v_entity_id uuid) OWNER TO engine;

--
-- Name: getconnectionsbyiscsibondid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getconnectionsbyiscsibondid(v_iscsi_bond_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds_storage_connections_map.connection_id
    FROM iscsi_bonds_storage_connections_map
    WHERE iscsi_bond_id = v_iscsi_bond_id;
END;$$;


ALTER FUNCTION public.getconnectionsbyiscsibondid(v_iscsi_bond_id uuid) OWNER TO engine;

--
-- Name: getconsumedpermissionsforquotaid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getconsumedpermissionsforquotaid(v_quota_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE role_id IN (
            SELECT role_id
            FROM ROLES_groups
            WHERE action_group_id = 901
            )
        AND object_id IN (
            SELECT id
            FROM fn_get_entity_parents(v_quota_id, 17)
            );
END;$$;


ALTER FUNCTION public.getconsumedpermissionsforquotaid(v_quota_id uuid) OWNER TO engine;

--
-- Name: getcpuprofilebycpuprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcpuprofilebycpuprofileid(v_id uuid) RETURNS SETOF public.cpu_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cpu_profiles
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getcpuprofilebycpuprofileid(v_id uuid) OWNER TO engine;

--
-- Name: getcpuprofilesbyclusterid(uuid, uuid, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcpuprofilesbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean, v_action_group_id integer) RETURNS SETOF public.cpu_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    IF v_is_filtered
    THEN
        RETURN QUERY
        SELECT *
        FROM cpu_profiles
        WHERE cluster_id = v_cluster_id
            AND EXISTS (
                SELECT 1
                FROM get_entity_permissions(v_user_id, v_action_group_id, cpu_profiles.id, 30)
            )
        ORDER BY _create_date;

    ELSE
        RETURN QUERY
        SELECT *
        FROM cpu_profiles
        WHERE cluster_id = v_cluster_id
        ORDER BY _create_date;
    END IF;
END;$$;


ALTER FUNCTION public.getcpuprofilesbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean, v_action_group_id integer) OWNER TO engine;

--
-- Name: getcpuprofilesbyqosid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcpuprofilesbyqosid(v_qos_id uuid) RETURNS SETOF public.cpu_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM cpu_profiles
    WHERE qos_id = v_qos_id;
END;$$;


ALTER FUNCTION public.getcpuprofilesbyqosid(v_qos_id uuid) OWNER TO engine;

--
-- Name: getcustom_actionsbyaction_id(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcustom_actionsbyaction_id(v_action_id integer) RETURNS SETOF public.custom_actions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM custom_actions
    WHERE action_id = v_action_id;
END;$$;


ALTER FUNCTION public.getcustom_actionsbyaction_id(v_action_id integer) OWNER TO engine;

--
-- Name: getcustom_actionsbynameandtab(character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcustom_actionsbynameandtab(v_action_name character varying, v_tab integer) RETURNS SETOF public.custom_actions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM custom_actions
    WHERE tab = v_tab
        AND action_name = v_action_name;
END;$$;


ALTER FUNCTION public.getcustom_actionsbynameandtab(v_action_name character varying, v_tab integer) OWNER TO engine;

--
-- Name: getcustom_actionsbytab_id(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getcustom_actionsbytab_id(v_tab integer) RETURNS SETOF public.custom_actions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM custom_actions
    WHERE tab = v_tab;
END;$$;


ALTER FUNCTION public.getcustom_actionsbytab_id(v_tab integer) OWNER TO engine;

--
-- Name: getdbgeneration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdbgeneration(v_vm_guid uuid) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT db_generation
      FROM vm_static
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.getdbgeneration(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getdcidbyexternalnetworkid(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdcidbyexternalnetworkid(v_external_id text) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_pool_id
    FROM network
    WHERE provider_network_external_id = v_external_id;
END;$$;


ALTER FUNCTION public.getdcidbyexternalnetworkid(v_external_id text) OWNER TO engine;

--
-- Name: getdefaultmacpool(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdefaultmacpool() RETURNS SETOF public.mac_pools
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM mac_pools
    WHERE default_pool IS true;
END;$$;


ALTER FUNCTION public.getdefaultmacpool() OWNER TO engine;

--
-- Name: quota_limitation; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.quota_limitation (
    id uuid NOT NULL,
    quota_id uuid NOT NULL,
    storage_id uuid,
    cluster_id uuid,
    virtual_cpu integer,
    mem_size_mb bigint,
    storage_size_gb bigint
);


ALTER TABLE public.quota_limitation OWNER TO engine;

--
-- Name: quota_global_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.quota_global_view AS
 SELECT q_limit.quota_id,
    q.storage_pool_id,
    storage_pool.name AS storage_pool_name,
    q.quota_name,
    q.description,
    q.threshold_cluster_percentage,
    q.threshold_storage_percentage,
    q.grace_cluster_percentage,
    q.grace_storage_percentage,
    q_limit.virtual_cpu,
    (public.calculateclusterusage(q_limit.quota_id, NULL::uuid)).virtual_cpu_usage AS virtual_cpu_usage,
    q_limit.mem_size_mb,
    (public.calculateclusterusage(q_limit.quota_id, NULL::uuid)).mem_size_mb_usage AS mem_size_mb_usage,
    q_limit.storage_size_gb,
    public.calculatestorageusage(q_limit.quota_id, NULL::uuid) AS storage_size_gb_usage,
    storage_pool.quota_enforcement_type,
    q.is_default
   FROM public.storage_pool,
    (public.quota q
     LEFT JOIN public.quota_limitation q_limit ON ((q_limit.quota_id = q.id)))
  WHERE ((storage_pool.id = q.storage_pool_id) AND (q_limit.cluster_id IS NULL) AND (q_limit.storage_id IS NULL));


ALTER TABLE public.quota_global_view OWNER TO engine;

--
-- Name: getdefaultquotaforstoragepool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdefaultquotaforstoragepool(v_storage_pool_id uuid) RETURNS SETOF public.quota_global_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_global_view
    WHERE is_default = TRUE
          AND storage_pool_id = v_storage_pool_id;
END;
$$;


ALTER FUNCTION public.getdefaultquotaforstoragepool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getdirectpermissionsbyadelementid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdirectpermissionsbyadelementid(v_ad_element_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE permissions_view.ad_element_id = v_ad_element_id;
END;$$;


ALTER FUNCTION public.getdirectpermissionsbyadelementid(v_ad_element_id uuid) OWNER TO engine;

--
-- Name: getdisk_image_dynamicbyimage_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisk_image_dynamicbyimage_id(v_image_id uuid) RETURNS SETOF public.disk_image_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_image_dynamic
    WHERE image_id = v_image_id;
END;$$;


ALTER FUNCTION public.getdisk_image_dynamicbyimage_id(v_image_id uuid) OWNER TO engine;

--
-- Name: getdiskandsnapshotsbydiskid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskandsnapshotsbydiskid(v_disk_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks_including_snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks_including_snapshots
    WHERE image_group_id = v_disk_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getdiskandsnapshotsbydiskid(v_disk_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdiskbydiskid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskbydiskid(v_disk_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks
    WHERE image_group_id = v_disk_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getdiskbydiskid(v_disk_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdiskbydiskidandstoragedomainid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskbydiskidandstoragedomainid(v_disk_id uuid, v_storage_domain_id uuid) RETURNS SETOF public.unregistered_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM unregistered_disks
    WHERE (disk_id = v_disk_id
        OR v_disk_id IS NULL)
        AND (
            storage_domain_id = v_storage_domain_id
            OR v_storage_domain_id IS NULL
            );
END;$$;


ALTER FUNCTION public.getdiskbydiskidandstoragedomainid(v_disk_id uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getdiskimagebydiskandimageids(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskimagebydiskandimageids(v_disk_id uuid, v_image_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view
     WHERE image_group_id = v_disk_id
         AND image_guid = v_image_id
         AND (NOT v_is_filtered OR EXISTS (
             SELECT 1
             FROM   user_disk_permissions_view
             WHERE  user_id = v_user_id
             AND    entity_id = images_storage_domain_view.image_group_id));
END; $$;


ALTER FUNCTION public.getdiskimagebydiskandimageids(v_disk_id uuid, v_image_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdisklunmapbydiskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisklunmapbydiskid(v_disk_id uuid) RETURNS SETOF public.disk_lun_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_lun_map
    WHERE disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.getdisklunmapbydiskid(v_disk_id uuid) OWNER TO engine;

--
-- Name: getdisklunmapbydisklunmapid(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisklunmapbydisklunmapid(v_disk_id uuid, v_lun_id character varying) RETURNS SETOF public.disk_lun_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_lun_map
    WHERE disk_id = v_disk_id
        AND lun_id = v_lun_id;
END;$$;


ALTER FUNCTION public.getdisklunmapbydisklunmapid(v_disk_id uuid, v_lun_id character varying) OWNER TO engine;

--
-- Name: getdisklunmapbylunid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisklunmapbylunid(v_lun_id character varying) RETURNS SETOF public.disk_lun_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_lun_map
    WHERE lun_id = v_lun_id;
END;$$;


ALTER FUNCTION public.getdisklunmapbylunid(v_lun_id character varying) OWNER TO engine;

--
-- Name: getdisklunmapsforvmsinpool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisklunmapsforvmsinpool(v_storage_pool_id uuid) RETURNS SETOF public.disk_lun_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_lun_map
    WHERE EXISTS (
        SELECT *
        FROM disk_vm_element
        INNER JOIN vm_static
            ON disk_vm_element.vm_id = vm_static.vm_guid
        INNER JOIN cluster
            ON vm_static.cluster_id = cluster.cluster_id
        INNER JOIN storage_pool
            ON cluster.storage_pool_id = storage_pool.id
        WHERE disk_lun_map.disk_id = disk_vm_element.disk_id
            AND storage_pool.id = v_storage_pool_id);
END;$$;


ALTER FUNCTION public.getdisklunmapsforvmsinpool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getdiskprofilebydiskprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskprofilebydiskprofileid(v_id uuid) RETURNS SETOF public.disk_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_profiles
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getdiskprofilebydiskprofileid(v_id uuid) OWNER TO engine;

--
-- Name: getdiskprofilesbyqosid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskprofilesbyqosid(v_qos_id uuid) RETURNS SETOF public.disk_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_profiles
    WHERE qos_id = v_qos_id;
END;$$;


ALTER FUNCTION public.getdiskprofilesbyqosid(v_qos_id uuid) OWNER TO engine;

--
-- Name: getdiskprofilesbystoragedomainid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskprofilesbystoragedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.disk_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM disk_profiles
    WHERE storage_domain_id = v_storage_domain_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_profile_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_profiles.id
                )
            );
END;$$;


ALTER FUNCTION public.getdiskprofilesbystoragedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdisksbyvmbackupid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksbyvmbackupid(v_backup_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT images_storage_domain_view.*
    FROM   images_storage_domain_view
    JOIN   vm_backup_disk_map on vm_backup_disk_map.disk_id = images_storage_domain_view.image_group_id
    WHERE  images_storage_domain_view.active AND vm_backup_disk_map.backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.getdisksbyvmbackupid(v_backup_id uuid) OWNER TO engine;

--
-- Name: getdisksbyvmcheckpointid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksbyvmcheckpointid(v_checkpoint_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT images_storage_domain_view.*
    FROM   images_storage_domain_view
    JOIN   vm_checkpoint_disk_map on vm_checkpoint_disk_map.disk_id = images_storage_domain_view.image_group_id
    WHERE  images_storage_domain_view.active AND vm_checkpoint_disk_map.checkpoint_id = v_checkpoint_id;
END;$$;


ALTER FUNCTION public.getdisksbyvmcheckpointid(v_checkpoint_id uuid) OWNER TO engine;

--
-- Name: getdisksnapshotforvmsnapshot(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksnapshotforvmsnapshot(v_image_group_id uuid, v_vm_snapshot_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view
     WHERE image_group_id = v_image_group_id
         AND vm_snapshot_id = v_vm_snapshot_id;
END; $$;


ALTER FUNCTION public.getdisksnapshotforvmsnapshot(v_image_group_id uuid, v_vm_snapshot_id uuid) OWNER TO engine;

--
-- Name: getdisksnapshotidforbackup(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksnapshotidforbackup(v_backup_id uuid, v_disk_id uuid) RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
    SELECT disk_snapshot_id
    FROM vm_backup_disk_map
    WHERE backup_id = v_backup_id AND disk_id = v_disk_id;
$$;


ALTER FUNCTION public.getdisksnapshotidforbackup(v_backup_id uuid, v_disk_id uuid) OWNER TO engine;

--
-- Name: all_disks_for_vms; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.all_disks_for_vms AS
 SELECT all_disks_including_snapshots_and_memory.storage_id,
    all_disks_including_snapshots_and_memory.storage_name,
    all_disks_including_snapshots_and_memory.storage_type,
    all_disks_including_snapshots_and_memory.storage_pool_id,
    all_disks_including_snapshots_and_memory.image_guid,
    all_disks_including_snapshots_and_memory.creation_date,
    all_disks_including_snapshots_and_memory.actual_size,
    all_disks_including_snapshots_and_memory.read_rate,
    all_disks_including_snapshots_and_memory.read_ops,
    all_disks_including_snapshots_and_memory.write_rate,
    all_disks_including_snapshots_and_memory.write_ops,
    all_disks_including_snapshots_and_memory.read_latency_seconds,
    all_disks_including_snapshots_and_memory.write_latency_seconds,
    all_disks_including_snapshots_and_memory.flush_latency_seconds,
    all_disks_including_snapshots_and_memory.size,
    all_disks_including_snapshots_and_memory.it_guid,
    all_disks_including_snapshots_and_memory.imagestatus,
    all_disks_including_snapshots_and_memory.lastmodified,
    all_disks_including_snapshots_and_memory.volume_type,
    all_disks_including_snapshots_and_memory.volume_format,
    all_disks_including_snapshots_and_memory.qcow_compat,
    all_disks_including_snapshots_and_memory.image_group_id,
    all_disks_including_snapshots_and_memory.description,
    all_disks_including_snapshots_and_memory.parentid,
    all_disks_including_snapshots_and_memory.app_list,
    all_disks_including_snapshots_and_memory.vm_snapshot_id,
    all_disks_including_snapshots_and_memory.active,
    all_disks_including_snapshots_and_memory.volume_classification,
    all_disks_including_snapshots_and_memory.sequence_number,
    all_disks_including_snapshots_and_memory.entity_type,
    all_disks_including_snapshots_and_memory.number_of_vms,
    all_disks_including_snapshots_and_memory.vm_names,
    all_disks_including_snapshots_and_memory.template_version_names,
    all_disks_including_snapshots_and_memory.quota_id,
    all_disks_including_snapshots_and_memory.quota_name,
    all_disks_including_snapshots_and_memory.quota_enforcement_type,
    all_disks_including_snapshots_and_memory.image_transfer_phase,
    all_disks_including_snapshots_and_memory.image_transfer_type,
    all_disks_including_snapshots_and_memory.image_transfer_bytes_sent,
    all_disks_including_snapshots_and_memory.image_transfer_bytes_total,
    all_disks_including_snapshots_and_memory.progress,
    all_disks_including_snapshots_and_memory.disk_profile_id,
    all_disks_including_snapshots_and_memory.disk_profile_name,
    all_disks_including_snapshots_and_memory.lun_id,
    all_disks_including_snapshots_and_memory.physical_volume_id,
    all_disks_including_snapshots_and_memory.volume_group_id,
    all_disks_including_snapshots_and_memory.serial,
    all_disks_including_snapshots_and_memory.lun_mapping,
    all_disks_including_snapshots_and_memory.vendor_id,
    all_disks_including_snapshots_and_memory.product_id,
    all_disks_including_snapshots_and_memory.device_size,
    all_disks_including_snapshots_and_memory.discard_max_size,
    all_disks_including_snapshots_and_memory.disk_id,
    all_disks_including_snapshots_and_memory.wipe_after_delete,
    all_disks_including_snapshots_and_memory.propagate_errors,
    all_disks_including_snapshots_and_memory.disk_alias,
    all_disks_including_snapshots_and_memory.disk_description,
    all_disks_including_snapshots_and_memory.shareable,
    all_disks_including_snapshots_and_memory.sgio,
    all_disks_including_snapshots_and_memory.disk_storage_type,
    all_disks_including_snapshots_and_memory.cinder_volume_type,
    all_disks_including_snapshots_and_memory.disk_content_type,
    all_disks_including_snapshots_and_memory.backup,
    all_disks_including_snapshots_and_memory.backup_mode,
    vm_device.is_plugged,
    vm_device.logical_name,
    vm_device.vm_id
   FROM (public.all_disks_including_snapshots_and_memory
     JOIN public.vm_device ON ((vm_device.device_id = all_disks_including_snapshots_and_memory.image_group_id)))
  WHERE (((vm_device.snapshot_id IS NULL) AND (all_disks_including_snapshots_and_memory.active IS NOT FALSE)) OR (vm_device.snapshot_id = all_disks_including_snapshots_and_memory.vm_snapshot_id));


ALTER TABLE public.all_disks_for_vms OWNER TO engine;

--
-- Name: getdisksvmguid(uuid, boolean, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksvmguid(v_vm_guid uuid, v_only_plugged boolean, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.all_disks_for_vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM all_disks_for_vms
    WHERE vm_id = v_vm_guid
        AND (
            NOT v_only_plugged
            OR is_plugged
            )
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getdisksvmguid(v_vm_guid uuid, v_only_plugged boolean, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdisksvmguidbasicview(uuid, boolean, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksvmguidbasicview(v_vm_guid uuid, v_only_plugged boolean, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.disks_basic_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT disk_id,
        disk_alias,
        size
    FROM images
    LEFT JOIN base_disks
        ON images.image_group_id = base_disks.disk_id
    LEFT JOIN vm_device
        ON vm_device.device_id = image_group_id
            AND (
                NOT v_only_plugged
                OR is_plugged
                )
    WHERE vm_device.vm_id = v_vm_guid
        AND images.active = true
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_disk_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = disk_id
                )
            );
END;$$;


ALTER FUNCTION public.getdisksvmguidbasicview(v_vm_guid uuid, v_only_plugged boolean, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdisksvmguids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdisksvmguids(v_vm_guids uuid[]) RETURNS SETOF public.all_disks_for_vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM all_disks_for_vms
  WHERE vm_id = ANY(v_vm_guids);
END;$$;


ALTER FUNCTION public.getdisksvmguids(v_vm_guids uuid[]) OWNER TO engine;

--
-- Name: getdiskvmelementbydiskvmelementid(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskvmelementbydiskvmelementid(v_disk_id uuid, v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.disk_vm_element_extended
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM disk_vm_element_extended
    WHERE disk_id = v_disk_id
        AND vm_id = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            );
END;$$;


ALTER FUNCTION public.getdiskvmelementbydiskvmelementid(v_disk_id uuid, v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdiskvmelementsbydiskvmelementsids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskvmelementsbydiskvmelementsids(v_disks_ids uuid[]) RETURNS SETOF public.disk_vm_element_extended
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM disk_vm_element_extended
    WHERE disk_id = ANY(v_disks_ids);
END;$$;


ALTER FUNCTION public.getdiskvmelementsbydiskvmelementsids(v_disks_ids uuid[]) OWNER TO engine;

--
-- Name: getdiskvmelementsforvm(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskvmelementsforvm(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.disk_vm_element_extended
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM disk_vm_element_extended
    WHERE vm_id = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            );
END;$$;


ALTER FUNCTION public.getdiskvmelementsforvm(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getdiskvmelementspluggedtovm(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdiskvmelementspluggedtovm(v_vm_id uuid) RETURNS SETOF public.disk_vm_element_extended
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM disk_vm_element_extended
    WHERE vm_id = v_vm_id AND is_plugged = true;
END;$$;


ALTER FUNCTION public.getdiskvmelementspluggedtovm(v_vm_id uuid) OWNER TO engine;

--
-- Name: getdnsresolverconfigurationbydnsresolverconfigurationid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdnsresolverconfigurationbydnsresolverconfigurationid(v_id uuid) RETURNS SETOF public.dns_resolver_configuration
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM dns_resolver_configuration
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getdnsresolverconfigurationbydnsresolverconfigurationid(v_id uuid) OWNER TO engine;

--
-- Name: dwh_history_timekeeping; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.dwh_history_timekeeping (
    var_name character varying(50) NOT NULL,
    var_value character varying(255),
    var_datetime timestamp with time zone
);


ALTER TABLE public.dwh_history_timekeeping OWNER TO engine;

--
-- Name: getdwhhistorytimekeepingbyvarname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getdwhhistorytimekeepingbyvarname(v_var_name character varying) RETURNS SETOF public.dwh_history_timekeeping
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM dwh_history_timekeeping
    WHERE var_name = v_var_name;
END;$$;


ALTER FUNCTION public.getdwhhistorytimekeepingbyvarname(v_var_name character varying) OWNER TO engine;

--
-- Name: getelementidsbyidandgroups(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getelementidsbyidandgroups(v_id uuid, v_group_ids text) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN QUERY
        SELECT *
        FROM fnsplitteruuid(v_group_ids)

        UNION

        SELECT v_id

        UNION

        -- user is also member of 'Everyone'
        SELECT 'EEE00000-0000-0000-0000-123456789EEE';
END;$$;


ALTER FUNCTION public.getelementidsbyidandgroups(v_id uuid, v_group_ids text) OWNER TO engine;

--
-- Name: engine_session_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.engine_session_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_session_seq OWNER TO engine;

--
-- Name: engine_sessions; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.engine_sessions (
    id bigint DEFAULT nextval('public.engine_session_seq'::regclass) NOT NULL,
    engine_session_id text NOT NULL,
    user_id uuid NOT NULL,
    user_name character varying(255) NOT NULL,
    group_ids text,
    role_ids text,
    source_ip character varying(50),
    authz_name character varying(255) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE public.engine_sessions OWNER TO engine;

--
-- Name: getenginesession(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getenginesession(v_id integer) RETURNS SETOF public.engine_sessions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM engine_sessions
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getenginesession(v_id integer) OWNER TO engine;

--
-- Name: getenginesessionbysessionid(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getenginesessionbysessionid(v_engine_session_id text) RETURNS SETOF public.engine_sessions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM engine_sessions
    WHERE engine_session_id = v_engine_session_id;
END;$$;


ALTER FUNCTION public.getenginesessionbysessionid(v_engine_session_id text) OWNER TO engine;

--
-- Name: unregistered_disks_to_vms; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.unregistered_disks_to_vms (
    disk_id uuid NOT NULL,
    entity_id uuid NOT NULL,
    entity_name character varying(255),
    storage_domain_id uuid NOT NULL
);


ALTER TABLE public.unregistered_disks_to_vms OWNER TO engine;

--
-- Name: getentitiesbydiskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getentitiesbydiskid(v_disk_id uuid) RETURNS SETOF public.unregistered_disks_to_vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM unregistered_disks_to_vms
    WHERE disk_id = v_disk_id
       OR v_disk_id IS NULL;
END;$$;


ALTER FUNCTION public.getentitiesbydiskid(v_disk_id uuid) OWNER TO engine;

--
-- Name: getentitiesnamemap(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getentitiesnamemap() RETURNS SETOF public.entity_name_map_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT concat(labels_map.vm_id, vds_static.vds_id)::UUID AS entity_id,
                    concat(vm_static.vm_name, vds_static.vds_name)::TEXT AS entity_name
    FROM labels_map
        LEFT JOIN vm_static
            ON vm_static.vm_guid = labels_map.vm_id
        LEFT JOIN vds_static
            ON vds_static.vds_id = labels_map.vds_id;
END;$$;


ALTER FUNCTION public.getentitiesnamemap() OWNER TO engine;

--
-- Name: event_subscriber; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.event_subscriber (
    subscriber_id uuid NOT NULL,
    event_up_name character varying(100) NOT NULL,
    method_address character varying(255),
    tag_name character varying(50) DEFAULT ''::character varying NOT NULL,
    notification_method character varying(32),
    CONSTRAINT event_subscriber_method_check CHECK (((notification_method)::text = ANY (ARRAY[('smtp'::character varying)::text, ('snmp'::character varying)::text])))
);


ALTER TABLE public.event_subscriber OWNER TO engine;

--
-- Name: getevent_subscriberbysubscriber_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getevent_subscriberbysubscriber_id(v_subscriber_id uuid) RETURNS SETOF public.event_subscriber
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM event_subscriber
    WHERE subscriber_id = v_subscriber_id;
END;$$;


ALTER FUNCTION public.getevent_subscriberbysubscriber_id(v_subscriber_id uuid) OWNER TO engine;

--
-- Name: getevent_subscription(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getevent_subscription(v_subscriber_id uuid, v_event_up_name character varying) RETURNS SETOF public.event_subscriber
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM event_subscriber
    WHERE subscriber_id = v_subscriber_id
        AND event_up_name = v_event_up_name;
END;$$;


ALTER FUNCTION public.getevent_subscription(v_subscriber_id uuid, v_event_up_name character varying) OWNER TO engine;

--
-- Name: vm_host_pinning_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_host_pinning_map (
    vm_id uuid NOT NULL,
    vds_id uuid NOT NULL
);


ALTER TABLE public.vm_host_pinning_map OWNER TO engine;

--
-- Name: vm_host_pinning_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_host_pinning_view AS
 SELECT host.vds_name,
    vm.vm_name,
    vm_vds.vm_id,
    vm_vds.vds_id
   FROM ((public.vm_host_pinning_map vm_vds
     JOIN public.vm_static vm ON ((vm_vds.vm_id = vm.vm_guid)))
     JOIN public.vds_static host ON ((vm_vds.vds_id = host.vds_id)));


ALTER TABLE public.vm_host_pinning_view OWNER TO engine;

--
-- Name: host_device_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.host_device_view AS
 SELECT host_device.host_id,
    host_device.device_name,
    host_device.parent_device_name,
    host_device.capability,
    host_device.iommu_group,
    host_device.product_name,
    host_device.product_id,
    host_device.vendor_name,
    host_device.vendor_id,
    host_device.physfn,
    host_device.total_vfs,
    host_device.vm_id,
    host_device.net_iface_name,
    host_device.driver,
    host_device.is_assignable,
    host_device.address,
    host_device.mdev_types,
    host_device.block_path,
    host_device.hostdev_spec_params,
    NULL::uuid AS configured_vm_id,
    NULL::character varying AS spec_params,
    ( SELECT array_to_string(array_agg(vm_host_pinning_view.vm_name), ','::text) AS array_to_string
           FROM (public.vm_device
             JOIN public.vm_host_pinning_view ON ((vm_device.vm_id = vm_host_pinning_view.vm_id)))
          WHERE (((vm_device.device)::text = (host_device.device_name)::text) AND (vm_host_pinning_view.vds_id = host_device.host_id))) AS attached_vm_names,
    ( SELECT vm_static.vm_name
           FROM public.vm_static
          WHERE (vm_static.vm_guid = host_device.vm_id)) AS running_vm_name
   FROM public.host_device;


ALTER TABLE public.host_device_view OWNER TO engine;

--
-- Name: getextendedhostdevicesbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getextendedhostdevicesbyhostid(v_host_id uuid) RETURNS SETOF public.host_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT host_device_view.*
    FROM host_device_view
    WHERE host_device_view.host_id = v_host_id;
END;$$;


ALTER FUNCTION public.getextendedhostdevicesbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: getexternalidsfromsteps(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getexternalidsfromsteps(v_status character varying, v_external_system_type character varying) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.external_id
    FROM step
    INNER JOIN job
        ON step.job_id = job.job_id
    WHERE job.status = v_status
        AND step.external_system_type = v_external_system_type;
END;$$;


ALTER FUNCTION public.getexternalidsfromsteps(v_status character varying, v_external_system_type character varying) OWNER TO engine;

--
-- Name: external_leases; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.external_leases (
    lease_id uuid NOT NULL,
    storage_domain_id uuid NOT NULL
);


ALTER TABLE public.external_leases OWNER TO engine;

--
-- Name: getexternallease(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getexternallease(v_lease_id uuid) RETURNS SETOF public.external_leases
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM external_leases
    WHERE lease_id = v_lease_id;
END;$$;


ALTER FUNCTION public.getexternallease(v_lease_id uuid) OWNER TO engine;

--
-- Name: external_variable; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.external_variable (
    var_name character varying(100) NOT NULL,
    var_value character varying(4000),
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL
);


ALTER TABLE public.external_variable OWNER TO engine;

--
-- Name: getexternalvariablebyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getexternalvariablebyname(v_var_name character varying) RETURNS SETOF public.external_variable
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT external_variable.*
    FROM external_variable
    WHERE var_name = v_var_name;
END;$$;


ALTER FUNCTION public.getexternalvariablebyname(v_var_name character varying) OWNER TO engine;

--
-- Name: getfailedautostartvms(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfailedautostartvms() RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vms.*
      FROM vms
      WHERE auto_startup = TRUE
          AND status = 0
          AND exit_status = 1;
END; $$;


ALTER FUNCTION public.getfailedautostartvms() OWNER TO engine;

--
-- Name: getfailingstorage_domains(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfailingstorage_domains() RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE recoverable
        AND status = 4;--inactive
END;$$;


ALTER FUNCTION public.getfailingstorage_domains() OWNER TO engine;

--
-- Name: getfailingvdss(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfailingvdss() RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds
    WHERE recoverable
        AND status = 10;--non operational
END;$$;


ALTER FUNCTION public.getfailingvdss() OWNER TO engine;

--
-- Name: fence_agents; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.fence_agents (
    id uuid NOT NULL,
    vds_id uuid NOT NULL,
    agent_order integer NOT NULL,
    ip character varying(255) NOT NULL,
    type character varying(255) NOT NULL,
    agent_user character varying(255) NOT NULL,
    agent_password text NOT NULL,
    port integer,
    options text DEFAULT ''::character varying NOT NULL,
    encrypt_options boolean DEFAULT false NOT NULL
);


ALTER TABLE public.fence_agents OWNER TO engine;

--
-- Name: getfenceagentbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfenceagentbyid(v_guid uuid) RETURNS SETOF public.fence_agents
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT fence_agents.*
    FROM fence_agents
    WHERE id = v_guid;
END;$$;


ALTER FUNCTION public.getfenceagentbyid(v_guid uuid) OWNER TO engine;

--
-- Name: getfenceagentsbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfenceagentsbyvdsid(v_vds_guid uuid) RETURNS SETOF public.fence_agents
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT fence_agents.*
    FROM fence_agents
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.getfenceagentsbyvdsid(v_vds_guid uuid) OWNER TO engine;

--
-- Name: getfirstuprhelforclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getfirstuprhelforclusterid(v_cluster_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        -- both centos and RHEL return RHEL as host_os
        RETURN QUERY

        SELECT *
        FROM vds
        WHERE (
                host_os LIKE 'RHEL%'
                OR host_os LIKE 'oVirt Node%'
                OR host_os LIKE 'RHEV Hypervisor%'
                )
            AND status = 3
            AND cluster_id = v_cluster_id LIMIT 1;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getfirstuprhelforclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getforroleandadelementandobject_wgroupcheck(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getforroleandadelementandobject_wgroupcheck(v_role_id uuid, v_ad_element_id uuid, v_object_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM permissions_view
   WHERE role_id = v_role_id
       AND object_id = v_object_id
       AND ad_element_id IN (
           SELECT *
           FROM getUserAndGroupsById(v_ad_element_id)
       );
END; $$;


ALTER FUNCTION public.getforroleandadelementandobject_wgroupcheck(v_role_id uuid, v_ad_element_id uuid, v_object_id uuid) OWNER TO engine;

--
-- Name: getgeorepsessionbyslavevolume(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getgeorepsessionbyslavevolume(v_slave_volume_id uuid) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE slave_volume_id = v_slave_volume_id;
END;$$;


ALTER FUNCTION public.getgeorepsessionbyslavevolume(v_slave_volume_id uuid) OWNER TO engine;

--
-- Name: getglobalids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglobalids(v_name character varying) RETURNS uuid
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$

DECLARE v_id UUID;

BEGIN
    IF (v_name = 'system') THEN
        v_id := 'AAA00000-0000-0000-0000-123456789AAA';
    ELSIF(v_name = 'everyone') THEN
        v_id := 'EEE00000-0000-0000-0000-123456789EEE';

    -- bottom is an object which all the objects in the system are its parents
    -- useful to denote we want all objects when checking for permissions
    ELSIF(v_name = 'bottom') THEN
        v_id := 'BBB00000-0000-0000-0000-123456789BBB';
    END IF;

    RETURN v_id;
END;$$;


ALTER FUNCTION public.getglobalids(v_name character varying) OWNER TO engine;

--
-- Name: gluster_global_volume_options; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_global_volume_options (
    id uuid NOT NULL,
    cluster_id uuid NOT NULL,
    option_key character varying(8192) NOT NULL,
    option_val character varying(8192) NOT NULL
);


ALTER TABLE public.gluster_global_volume_options OWNER TO engine;

--
-- Name: getglobaloptionsbyglusterclusterguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglobaloptionsbyglusterclusterguid(v_cluster_id uuid) RETURNS SETOF public.gluster_global_volume_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_global_volume_options
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglobaloptionsbyglusterclusterguid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglusterbrickbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterbrickbyid(v_id uuid) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusterbrickbyid(v_id uuid) OWNER TO engine;

--
-- Name: gluster_cluster_services; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_cluster_services (
    cluster_id uuid NOT NULL,
    service_type character varying(100) NOT NULL,
    status character varying(32) NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_cluster_services OWNER TO engine;

--
-- Name: getglusterclusterservicesbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterclusterservicesbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_cluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_cluster_services
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglusterclusterservicesbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglusterclusterservicesbyclusteridandservicetype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterclusterservicesbyclusteridandservicetype(v_cluster_id uuid, v_service_type character varying) RETURNS SETOF public.gluster_cluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_cluster_services
    WHERE cluster_id = v_cluster_id
        AND service_type = v_service_type;
END;$$;


ALTER FUNCTION public.getglusterclusterservicesbyclusteridandservicetype(v_cluster_id uuid, v_service_type character varying) OWNER TO engine;

--
-- Name: getglustergeorepsessionbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionbyid(v_session_id uuid) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE session_id = v_session_id;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionbyid(v_session_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessionbykey(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionbykey(v_session_key character varying) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE session_key = v_session_key;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionbykey(v_session_key character varying) OWNER TO engine;

--
-- Name: getglustergeorepsessionbyslavehostandvolume(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionbyslavehostandvolume(v_master_volume_id uuid, v_slave_host_uuid uuid, v_slave_volume_name character varying) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE master_volume_id = v_master_volume_id
        AND slave_host_uuid = v_slave_host_uuid
        AND slave_volume_name = v_slave_volume_name;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionbyslavehostandvolume(v_master_volume_id uuid, v_slave_host_uuid uuid, v_slave_volume_name character varying) OWNER TO engine;

--
-- Name: getglustergeorepsessionbyslavehostnameandvolume(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionbyslavehostnameandvolume(v_master_volume_id uuid, v_slave_host_name character varying, v_slave_volume_name character varying) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE master_volume_id = v_master_volume_id
        AND slave_host_name = v_slave_host_name
        AND slave_volume_name = v_slave_volume_name;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionbyslavehostnameandvolume(v_master_volume_id uuid, v_slave_host_name character varying, v_slave_volume_name character varying) OWNER TO engine;

--
-- Name: gluster_config_master; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_config_master (
    config_key character varying(50) NOT NULL,
    config_description character varying(300),
    minimum_supported_cluster character varying(50),
    config_possible_values character varying(50),
    config_feature character varying(50)
);


ALTER TABLE public.gluster_config_master OWNER TO engine;

--
-- Name: gluster_georep_config; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_georep_config (
    session_id uuid NOT NULL,
    config_key character varying(50) NOT NULL,
    config_value text,
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL
);


ALTER TABLE public.gluster_georep_config OWNER TO engine;

--
-- Name: gluster_geo_rep_config_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_geo_rep_config_view AS
 SELECT georepconfig.session_id,
    georepconfig.config_key,
    georepconfig.config_value,
    gluster_config_master.config_description,
    gluster_config_master.config_possible_values,
    georepconfig._update_date
   FROM (public.gluster_georep_config georepconfig
     LEFT JOIN public.gluster_config_master ON ((((gluster_config_master.config_key)::text = (georepconfig.config_key)::text) AND ((gluster_config_master.config_feature)::text = 'geo_replication'::text))));


ALTER TABLE public.gluster_geo_rep_config_view OWNER TO engine;

--
-- Name: getglustergeorepsessionconfig(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionconfig(v_session_id uuid) RETURNS SETOF public.gluster_geo_rep_config_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_geo_rep_config_view
    WHERE session_id = v_session_id
    ORDER BY config_key ASC;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionconfig(v_session_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessionconfigbykey(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionconfigbykey(v_session_id uuid, v_config_key character varying) RETURNS SETOF public.gluster_geo_rep_config_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_geo_rep_config_view
    WHERE session_id = v_session_id
        AND config_key = v_config_key;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionconfigbykey(v_session_id uuid, v_config_key character varying) OWNER TO engine;

--
-- Name: gluster_georep_session_details; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_georep_session_details (
    session_id uuid NOT NULL,
    master_brick_id uuid NOT NULL,
    slave_host_uuid uuid,
    slave_host_name character varying(50) NOT NULL,
    status character varying(20),
    checkpoint_status character varying(20),
    crawl_status character varying(20),
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    data_pending bigint,
    entry_pending bigint,
    meta_pending bigint,
    failures bigint,
    last_synced_at timestamp with time zone,
    checkpoint_time timestamp with time zone,
    checkpoint_completed_time timestamp with time zone,
    is_checkpoint_completed boolean DEFAULT false
);


ALTER TABLE public.gluster_georep_session_details OWNER TO engine;

--
-- Name: getglustergeorepsessiondetails(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessiondetails(v_session_id uuid) RETURNS SETOF public.gluster_georep_session_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_session_details
    WHERE session_id = v_session_id
    ORDER BY slave_host_name ASC;
END;$$;


ALTER FUNCTION public.getglustergeorepsessiondetails(v_session_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessiondetailsforbrick(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessiondetailsforbrick(v_session_id uuid, v_master_brick_id uuid) RETURNS SETOF public.gluster_georep_session_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_session_details
    WHERE session_id = v_session_id
        AND master_brick_id = v_master_brick_id;
END;$$;


ALTER FUNCTION public.getglustergeorepsessiondetailsforbrick(v_session_id uuid, v_master_brick_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessionsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE cluster_id = v_cluster_id
    ORDER BY slave_volume_name ASC;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessionsbyvolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionsbyvolumeid(v_master_volume_id uuid) RETURNS SETOF public.gluster_georep_sessions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_georep_sessions_view
    WHERE master_volume_id = v_master_volume_id
    ORDER BY slave_volume_name ASC;
END;$$;


ALTER FUNCTION public.getglustergeorepsessionsbyvolumeid(v_master_volume_id uuid) OWNER TO engine;

--
-- Name: getglustergeorepsessionunsetconfig(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustergeorepsessionunsetconfig(v_session_id uuid) RETURNS SETOF public.gluster_config_master
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_config_master
    WHERE gluster_config_master.config_feature = 'geo_replication'
        AND gluster_config_master.config_key NOT IN (
            SELECT config_key
            FROM gluster_georep_config
            WHERE gluster_georep_config.session_id = v_session_id
            );
END;$$;


ALTER FUNCTION public.getglustergeorepsessionunsetconfig(v_session_id uuid) OWNER TO engine;

--
-- Name: gluster_hooks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_hooks (
    id uuid NOT NULL,
    cluster_id uuid NOT NULL,
    gluster_command character varying(128) NOT NULL,
    stage character varying(50) NOT NULL,
    name character varying(256) NOT NULL,
    hook_status character varying(50),
    content_type character varying(50),
    checksum character varying(256),
    content text,
    conflict_status integer DEFAULT 0 NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_hooks OWNER TO engine;

--
-- Name: getglusterhook(uuid, character varying, character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterhook(v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying, v_includecontent boolean DEFAULT false) RETURNS SETOF public.gluster_hooks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT id,
        cluster_id,
        gluster_command,
        stage,
        name,
        hook_status,
        content_type,
        checksum,
        CASE v_includeContent
            WHEN true
                THEN content
            ELSE NULL::TEXT
            END AS content,
        conflict_status,
        _create_date,
        _update_date
    FROM gluster_hooks
    WHERE cluster_id = v_cluster_id
        AND gluster_command = v_gluster_command
        AND stage = v_stage
        AND name = v_name;
END;$$;


ALTER FUNCTION public.getglusterhook(v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying, v_includecontent boolean) OWNER TO engine;

--
-- Name: getglusterhookbyid(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterhookbyid(v_id uuid, v_includecontent boolean DEFAULT false) RETURNS SETOF public.gluster_hooks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT id,
        cluster_id,
        gluster_command,
        stage,
        name,
        hook_status,
        content_type,
        checksum,
        CASE v_includeContent
            WHEN true
                THEN content
            ELSE NULL::TEXT
            END AS content,
        conflict_status,
        _create_date,
        _update_date
    FROM gluster_hooks
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusterhookbyid(v_id uuid, v_includecontent boolean) OWNER TO engine;

--
-- Name: getglusterhookcontentbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterhookcontentbyid(v_id uuid) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT content
    FROM gluster_hooks
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusterhookcontentbyid(v_id uuid) OWNER TO engine;

--
-- Name: getglusterhooksbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterhooksbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_hooks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT id,
        cluster_id,
        gluster_command,
        stage,
        name,
        hook_status,
        content_type,
        checksum,
        NULL::TEXT AS content,
        conflict_status,
        _create_date,
        _update_date
    FROM gluster_hooks
    WHERE cluster_id = v_cluster_id
    ORDER BY gluster_command ASC,
        stage ASC;
END;$$;


ALTER FUNCTION public.getglusterhooksbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglusterjobbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterjobbyid(v_job_id uuid) RETURNS SETOF public.gluster_scheduler_job_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_scheduler_job_details
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.getglusterjobbyid(v_job_id uuid) OWNER TO engine;

--
-- Name: gluster_scheduler_job_params; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_scheduler_job_params (
    id uuid NOT NULL,
    job_id uuid NOT NULL,
    params_class_name character varying(300) NOT NULL,
    params_class_value character varying(300)
);


ALTER TABLE public.gluster_scheduler_job_params OWNER TO engine;

--
-- Name: getglusterjobparamsbyjobid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterjobparamsbyjobid(v_job_id uuid) RETURNS SETOF public.gluster_scheduler_job_params
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_scheduler_job_params
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.getglusterjobparamsbyjobid(v_job_id uuid) OWNER TO engine;

--
-- Name: gluster_volume_options; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_options (
    volume_id uuid NOT NULL,
    option_key character varying(8192) NOT NULL,
    option_val character varying(8192) NOT NULL,
    id uuid NOT NULL
);


ALTER TABLE public.gluster_volume_options OWNER TO engine;

--
-- Name: getglusteroptionbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusteroptionbyid(v_id uuid) RETURNS SETOF public.gluster_volume_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_options
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusteroptionbyid(v_id uuid) OWNER TO engine;

--
-- Name: getglusterserverbyglusterserveruuid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverbyglusterserveruuid(v_gluster_server_uuid uuid) RETURNS SETOF public.gluster_server
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server
    WHERE gluster_server_uuid = v_gluster_server_uuid;
END;$$;


ALTER FUNCTION public.getglusterserverbyglusterserveruuid(v_gluster_server_uuid uuid) OWNER TO engine;

--
-- Name: getglusterserverbyserverid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverbyserverid(v_server_id uuid) RETURNS SETOF public.gluster_server
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.getglusterserverbyserverid(v_server_id uuid) OWNER TO engine;

--
-- Name: gluster_server_hooks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_server_hooks (
    hook_id uuid NOT NULL,
    server_id uuid NOT NULL,
    hook_status character varying(50),
    content_type character varying(50),
    checksum character varying(256),
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_server_hooks OWNER TO engine;

--
-- Name: gluster_server_hooks_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_server_hooks_view AS
 SELECT gluster_server_hooks.hook_id,
    gluster_server_hooks.server_id,
    gluster_server_hooks.hook_status,
    gluster_server_hooks.content_type,
    gluster_server_hooks.checksum,
    gluster_server_hooks._create_date,
    gluster_server_hooks._update_date,
    vds_static.vds_name AS server_name
   FROM (public.gluster_server_hooks
     JOIN public.vds_static ON ((gluster_server_hooks.server_id = vds_static.vds_id)));


ALTER TABLE public.gluster_server_hooks_view OWNER TO engine;

--
-- Name: getglusterserverhook(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverhook(v_hook_id uuid, v_server_id uuid) RETURNS SETOF public.gluster_server_hooks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_hooks_view
    WHERE hook_id = v_hook_id
        AND server_id = v_server_id;
END;$$;


ALTER FUNCTION public.getglusterserverhook(v_hook_id uuid, v_server_id uuid) OWNER TO engine;

--
-- Name: getglusterserverhooksbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverhooksbyid(v_id uuid) RETURNS SETOF public.gluster_server_hooks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_hooks_view
    WHERE hook_id = v_id;
END;$$;


ALTER FUNCTION public.getglusterserverhooksbyid(v_id uuid) OWNER TO engine;

--
-- Name: getglusterserverservicebyglusterserverserviceid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverservicebyglusterserverserviceid(v_id uuid) RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_services_view
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusterserverservicebyglusterserverserviceid(v_id uuid) OWNER TO engine;

--
-- Name: getglusterserverservicesbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverservicesbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT s.*
    FROM gluster_server_services_view s,
        vds_static v
    WHERE s.server_id = v.vds_id
        AND v.cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglusterserverservicesbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglusterserverservicesbyclusteridandservicetype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverservicesbyclusteridandservicetype(v_cluster_id uuid, v_service_type character varying) RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT s.*
    FROM gluster_server_services_view s,
        vds_static v
    WHERE s.server_id = v.vds_id
        AND v.cluster_id = v_cluster_id
        AND s.service_type = v_service_type;
END;$$;


ALTER FUNCTION public.getglusterserverservicesbyclusteridandservicetype(v_cluster_id uuid, v_service_type character varying) OWNER TO engine;

--
-- Name: getglusterserverservicesbyserverid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverservicesbyserverid(v_server_id uuid) RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_services_view
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.getglusterserverservicesbyserverid(v_server_id uuid) OWNER TO engine;

--
-- Name: getglusterserverservicesbyserveridandservicetype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterserverservicesbyserveridandservicetype(v_server_id uuid, v_service_type character varying) RETURNS SETOF public.gluster_server_services_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_server_services_view
    WHERE server_id = v_server_id
        AND service_type = v_service_type;
END;$$;


ALTER FUNCTION public.getglusterserverservicesbyserveridandservicetype(v_server_id uuid, v_service_type character varying) OWNER TO engine;

--
-- Name: getglusterservicebyglusterserviceid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterservicebyglusterserviceid(v_id uuid) RETURNS SETOF public.gluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_services
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getglusterservicebyglusterserviceid(v_id uuid) OWNER TO engine;

--
-- Name: getglusterservicebytypeandname(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterservicebytypeandname(v_service_type character varying, v_service_name character varying) RETURNS SETOF public.gluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_services
    WHERE service_type = v_service_type
        AND service_name = v_service_name;
END;$$;


ALTER FUNCTION public.getglusterservicebytypeandname(v_service_type character varying, v_service_name character varying) OWNER TO engine;

--
-- Name: getglusterservicesbytype(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterservicesbytype(v_service_type character varying) RETURNS SETOF public.gluster_services
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_services
    WHERE service_type = v_service_type;
END;$$;


ALTER FUNCTION public.getglusterservicesbytype(v_service_type character varying) OWNER TO engine;

--
-- Name: gluster_service_types; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_service_types (
    service_type character varying(100) NOT NULL
);


ALTER TABLE public.gluster_service_types OWNER TO engine;

--
-- Name: getglusterservicetypes(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglusterservicetypes() RETURNS SETOF public.gluster_service_types
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_service_types;
END;$$;


ALTER FUNCTION public.getglusterservicetypes() OWNER TO engine;

--
-- Name: job_subject_entity; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.job_subject_entity (
    job_id uuid NOT NULL,
    entity_id uuid NOT NULL,
    entity_type character varying(32) NOT NULL
);


ALTER TABLE public.job_subject_entity OWNER TO engine;

--
-- Name: gluster_volume_task_steps; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_volume_task_steps AS
 SELECT step.step_id,
    step.parent_step_id,
    step.job_id,
    step.step_type,
    step.description,
    step.step_number,
    step.status,
    step.start_time,
    step.end_time,
    step.correlation_id,
    step.external_id,
    step.external_system_type,
    step.is_external,
    step.progress,
    gluster_volumes.id AS volume_id,
    job.job_id AS job_job_id,
    job.action_type,
    job.description AS job_description,
    job.status AS job_status,
    job.start_time AS job_start_time,
    job.end_time AS job_end_time
   FROM (((public.gluster_volumes
     JOIN public.job_subject_entity js ON ((js.entity_id = gluster_volumes.id)))
     JOIN public.job ON (((job.job_id = js.job_id) AND ((job.action_type)::text = ANY ((ARRAY['StartRebalanceGlusterVolume'::character varying, 'StartRemoveGlusterVolumeBricks'::character varying])::text[])))))
     LEFT JOIN public.step ON (((step.external_id = gluster_volumes.task_id) AND ((step.external_system_type)::text = 'GLUSTER'::text) AND (step.job_id = js.job_id))));


ALTER TABLE public.gluster_volume_task_steps OWNER TO engine;

--
-- Name: getglustertaskbyglustervolumeguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustertaskbyglustervolumeguid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_task_steps
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT gluster_volume_task_steps.*
    FROM gluster_volume_task_steps,
        gluster_volumes vol
    WHERE volume_id = v_volume_id
        AND vol.id = volume_id
        AND (
            job_status = 'STARTED'
            OR (
                job_status != 'STARTED'
                AND external_id = vol.task_id
                )
            )
    ORDER BY job_start_time DESC LIMIT 1;
END;$$;


ALTER FUNCTION public.getglustertaskbyglustervolumeguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getglustervolumebricksbyserverguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumebricksbyserverguid(v_server_id uuid) RETURNS SETOF public.gluster_volume_bricks_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_bricks_view
    WHERE server_id = v_server_id
    ORDER BY brick_order;
END;$$;


ALTER FUNCTION public.getglustervolumebricksbyserverguid(v_server_id uuid) OWNER TO engine;

--
-- Name: gluster_volumes_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_volumes_view AS
 SELECT gluster_volumes.id,
    gluster_volumes.cluster_id,
    gluster_volumes.vol_name,
    gluster_volumes.vol_type,
    gluster_volumes.status,
    gluster_volumes.replica_count,
    gluster_volumes.stripe_count,
    gluster_volumes._create_date,
    gluster_volumes._update_date,
    gluster_volumes.task_id,
    gluster_volumes.snapshot_count,
    gluster_volumes.snapshot_scheduled,
    gluster_volumes.disperse_count,
    gluster_volumes.redundancy_count,
    gluster_volumes.is_arbiter,
    cluster.name AS cluster_name,
        CASE
            WHEN (EXISTS ( SELECT gluster_georep_session.session_id
               FROM public.gluster_georep_session
              WHERE (gluster_georep_session.master_volume_id = gluster_volumes.id))) THEN true
            ELSE false
        END AS is_master,
    ( SELECT (((vol.vol_name)::text || '|'::text) || (cluster_1.name)::text)
           FROM ((public.gluster_georep_session
             JOIN public.gluster_volumes vol ON ((gluster_georep_session.master_volume_id = vol.id)))
             JOIN public.cluster cluster_1 ON ((cluster_1.cluster_id = vol.cluster_id)))
          WHERE (gluster_georep_session.slave_volume_id = gluster_volumes.id)) AS master_vol_cluster
   FROM (public.gluster_volumes
     JOIN public.cluster ON ((gluster_volumes.cluster_id = cluster.cluster_id)));


ALTER TABLE public.gluster_volumes_view OWNER TO engine;

--
-- Name: getglustervolumebyglustertaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumebyglustertaskid(v_task_id uuid) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE task_id = v_task_id;
END;$$;


ALTER FUNCTION public.getglustervolumebyglustertaskid(v_task_id uuid) OWNER TO engine;

--
-- Name: getglustervolumebyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumebyid(v_volume_id uuid) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.getglustervolumebyid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getglustervolumebyname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumebyname(v_cluster_id uuid, v_vol_name character varying) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE cluster_id = v_cluster_id
        AND vol_name = v_vol_name;
END;$$;


ALTER FUNCTION public.getglustervolumebyname(v_cluster_id uuid, v_vol_name character varying) OWNER TO engine;

--
-- Name: gluster_volume_details; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_details (
    volume_id uuid NOT NULL,
    total_space bigint,
    used_space bigint,
    free_space bigint,
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    confirmed_free_space bigint,
    vdo_savings integer
);


ALTER TABLE public.gluster_volume_details OWNER TO engine;

--
-- Name: getglustervolumedetailsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumedetailsbyid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_details
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_details
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getglustervolumedetailsbyid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesbyclusterguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesbyclusterguid(v_cluster_id uuid) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglustervolumesbyclusterguid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesbyoption(uuid, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesbyoption(v_cluster_id uuid, v_status character varying, v_option_key character varying, v_option_val character varying) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE cluster_id = v_cluster_id
        AND status = v_status
        AND id IN (
            SELECT volume_id
            FROM gluster_volume_options
            WHERE option_key = v_option_key
                AND option_val = v_option_val
            );
END;$$;


ALTER FUNCTION public.getglustervolumesbyoption(v_cluster_id uuid, v_status character varying, v_option_key character varying, v_option_val character varying) OWNER TO engine;

--
-- Name: getglustervolumesbystatusandtypes(uuid, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesbystatusandtypes(v_cluster_id uuid, v_status character varying, v_vol_types text) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE cluster_id = v_cluster_id
        AND status = v_status
        AND vol_type IN (
            SELECT ID
            FROM fnSplitter(v_vol_types)
            );
END;$$;


ALTER FUNCTION public.getglustervolumesbystatusandtypes(v_cluster_id uuid, v_status character varying, v_vol_types text) OWNER TO engine;

--
-- Name: getglustervolumesbystatustypesandoption(uuid, character varying, text, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesbystatustypesandoption(v_cluster_id uuid, v_status character varying, v_vol_types text, v_option_key character varying, v_option_val character varying) RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volumes_view
    WHERE cluster_id = v_cluster_id
        AND status = v_status
        AND vol_type IN (
            SELECT ID
            FROM fnSplitter(v_vol_types)
            )
        AND id IN (
            SELECT volume_id
            FROM gluster_volume_options
            WHERE option_key = v_option_key
                AND option_val = v_option_val
            );
END;$$;


ALTER FUNCTION public.getglustervolumesbystatustypesandoption(v_cluster_id uuid, v_status character varying, v_vol_types text, v_option_key character varying, v_option_val character varying) OWNER TO engine;

--
-- Name: gluster_volume_snapshots; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_snapshots (
    snapshot_id uuid NOT NULL,
    volume_id uuid NOT NULL,
    snapshot_name character varying(1000) NOT NULL,
    description character varying(1024),
    status character varying(32),
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_volume_snapshots OWNER TO engine;

--
-- Name: gluster_volume_snapshots_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_volume_snapshots_view AS
 SELECT gluster_volume_snapshots.snapshot_id,
    gluster_volume_snapshots.volume_id,
    gluster_volume_snapshots.snapshot_name,
    gluster_volume_snapshots.description,
    gluster_volume_snapshots.status,
    gluster_volume_snapshots._create_date,
    gluster_volume_snapshots._update_date,
    gluster_volumes.cluster_id,
    gluster_volumes.vol_name AS volume_name
   FROM (public.gluster_volume_snapshots
     JOIN public.gluster_volumes ON ((gluster_volume_snapshots.volume_id = gluster_volumes.id)));


ALTER TABLE public.gluster_volume_snapshots_view OWNER TO engine;

--
-- Name: getglustervolumesnapshotbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotbyid(v_snapshot_id uuid) RETURNS SETOF public.gluster_volume_snapshots_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshots_view
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotbyid(v_snapshot_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesnapshotbyname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotbyname(v_volume_id uuid, v_snapshot_name character varying) RETURNS SETOF public.gluster_volume_snapshots_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshots_view
    WHERE volume_id = v_volume_id
        AND snapshot_name = v_snapshot_name;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotbyname(v_volume_id uuid, v_snapshot_name character varying) OWNER TO engine;

--
-- Name: gluster_volume_snapshot_config; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_snapshot_config (
    cluster_id uuid NOT NULL,
    volume_id uuid,
    param_name character varying(128) NOT NULL,
    param_value character varying(128),
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_volume_snapshot_config OWNER TO engine;

--
-- Name: getglustervolumesnapshotconfigbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotconfigbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_volume_snapshot_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshot_config
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotconfigbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesnapshotconfigbyclusteridandname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotconfigbyclusteridandname(v_cluster_id uuid, v_param_name character varying) RETURNS SETOF public.gluster_volume_snapshot_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshot_config
    WHERE cluster_id = v_cluster_id
        AND volume_id IS NULL
        AND param_name = v_param_name;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotconfigbyclusteridandname(v_cluster_id uuid, v_param_name character varying) OWNER TO engine;

--
-- Name: getglustervolumesnapshotconfigbyvolumeid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotconfigbyvolumeid(v_cluster_id uuid, v_volume_id uuid) RETURNS SETOF public.gluster_volume_snapshot_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshot_config
    WHERE cluster_id = v_cluster_id
        AND volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotconfigbyvolumeid(v_cluster_id uuid, v_volume_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesnapshotconfigbyvolumeidandname(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotconfigbyvolumeidandname(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying) RETURNS SETOF public.gluster_volume_snapshot_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshot_config
    WHERE cluster_id = v_cluster_id
        AND volume_id = v_volume_id
        AND param_name = v_param_name;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotconfigbyvolumeidandname(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying) OWNER TO engine;

--
-- Name: getglustervolumesnapshotsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.gluster_volume_snapshots_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshots_view
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getglustervolumesnapshotsbyvolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotsbyvolumeid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_snapshots_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshots_view
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotsbyvolumeid(v_volume_id uuid) OWNER TO engine;

--
-- Name: gluster_volume_snapshot_schedules; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_snapshot_schedules (
    volume_id uuid NOT NULL,
    job_id character varying(256) NOT NULL,
    snapshot_name_prefix character varying(128),
    snapshot_description character varying(1024),
    recurrence character varying(128) NOT NULL,
    time_zone character varying(128),
    "interval" integer,
    start_date timestamp with time zone,
    execution_time time without time zone,
    days character varying(256),
    end_by timestamp with time zone,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone
);


ALTER TABLE public.gluster_volume_snapshot_schedules OWNER TO engine;

--
-- Name: gluster_volume_snapshot_schedules_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.gluster_volume_snapshot_schedules_view AS
 SELECT gluster_volume_snapshot_schedules.volume_id,
    gluster_volume_snapshot_schedules.job_id,
    gluster_volume_snapshot_schedules.snapshot_name_prefix,
    gluster_volume_snapshot_schedules.snapshot_description,
    gluster_volume_snapshot_schedules.recurrence,
    gluster_volume_snapshot_schedules.time_zone,
    gluster_volume_snapshot_schedules."interval",
    gluster_volume_snapshot_schedules.start_date,
    gluster_volume_snapshot_schedules.execution_time,
    gluster_volume_snapshot_schedules.days,
    gluster_volume_snapshot_schedules.end_by,
    gluster_volume_snapshot_schedules._create_date,
    gluster_volume_snapshot_schedules._update_date,
    gluster_volumes.cluster_id
   FROM (public.gluster_volume_snapshot_schedules
     JOIN public.gluster_volumes ON ((gluster_volume_snapshot_schedules.volume_id = gluster_volumes.id)));


ALTER TABLE public.gluster_volume_snapshot_schedules_view OWNER TO engine;

--
-- Name: getglustervolumesnapshotschedulebyvolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_snapshot_schedules_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_snapshot_schedules_view
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getglustervolumessupportedasstoragedomain(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getglustervolumessupportedasstoragedomain() RETURNS SETOF public.gluster_volumes_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM gluster_volumes_view
    WHERE vol_type IN ('REPLICATE', 'DISTRIBUTE', 'DISTRIBUTED_REPLICATE')
    AND replica_count IN (0, 3);
END;$$;


ALTER FUNCTION public.getglustervolumessupportedasstoragedomain() OWNER TO engine;

--
-- Name: getgroupbyexternalid(character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getgroupbyexternalid(v_domain character varying, v_external_id text) RETURNS SETOF public.ad_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM ad_groups
    WHERE domain = v_domain
        AND external_id = v_external_id;
END;$$;


ALTER FUNCTION public.getgroupbyexternalid(v_domain character varying, v_external_id text) OWNER TO engine;

--
-- Name: getgroupbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getgroupbyid(v_id uuid) RETURNS SETOF public.ad_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM ad_groups
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getgroupbyid(v_id uuid) OWNER TO engine;

--
-- Name: getgroupbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getgroupbyname(v_name character varying) RETURNS SETOF public.ad_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM ad_groups
    WHERE name = v_name;
END;$$;


ALTER FUNCTION public.getgroupbyname(v_name character varying) OWNER TO engine;

--
-- Name: getgroupbynameanddomain(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getgroupbynameanddomain(v_name character varying, v_domain character varying) RETURNS SETOF public.ad_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM ad_groups
    WHERE name = v_name
      AND domain = v_domain;
END;$$;


ALTER FUNCTION public.getgroupbynameanddomain(v_name character varying, v_domain character varying) OWNER TO engine;

--
-- Name: gethostdevicebyhostidanddevicename(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostdevicebyhostidanddevicename(v_host_id uuid, v_device_name character varying) RETURNS SETOF public.host_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_device
    WHERE host_id = v_host_id
        AND device_name = v_device_name;
END;$$;


ALTER FUNCTION public.gethostdevicebyhostidanddevicename(v_host_id uuid, v_device_name character varying) OWNER TO engine;

--
-- Name: gethostdevicesbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostdevicesbyhostid(v_host_id uuid) RETURNS SETOF public.host_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_device
    WHERE host_id = v_host_id;
END;$$;


ALTER FUNCTION public.gethostdevicesbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: gethostdevicesbyhostidandiommugroup(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostdevicesbyhostidandiommugroup(v_host_id uuid, v_iommu_group integer) RETURNS SETOF public.host_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_device
    WHERE host_id = v_host_id
        AND iommu_group = v_iommu_group;
END;$$;


ALTER FUNCTION public.gethostdevicesbyhostidandiommugroup(v_host_id uuid, v_iommu_group integer) OWNER TO engine;

--
-- Name: gethostedenginestoragedomainids(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostedenginestoragedomainids() RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT id
    FROM hosted_engine_storage_domains_ids_view;
END;$$;


ALTER FUNCTION public.gethostedenginestoragedomainids() OWNER TO engine;

--
-- Name: gethostedenginevm(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostedenginevm() RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE origin = 5 OR origin = 6;
END; $$;


ALTER FUNCTION public.gethostedenginevm() OWNER TO engine;

--
-- Name: host_network_qos_of_migration_network_by_cluster; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.host_network_qos_of_migration_network_by_cluster AS
 SELECT network_cluster.cluster_id,
    qos.id,
    qos.qos_type,
    qos.name,
    qos.description,
    qos.storage_pool_id,
    qos.max_throughput,
    qos.max_read_throughput,
    qos.max_write_throughput,
    qos.max_iops,
    qos.max_read_iops,
    qos.max_write_iops,
    qos._create_date,
    qos._update_date,
    qos.cpu_limit,
    qos.inbound_average,
    qos.inbound_peak,
    qos.inbound_burst,
    qos.outbound_average,
    qos.outbound_peak,
    qos.outbound_burst,
    qos.out_average_linkshare,
    qos.out_average_upperlimit,
    qos.out_average_realtime
   FROM public.qos,
    public.network_cluster,
    public.network
  WHERE ((network_cluster.network_id = network.id) AND network_cluster.migration AND (network.qos_id = qos.id));


ALTER TABLE public.host_network_qos_of_migration_network_by_cluster OWNER TO engine;

--
-- Name: gethostnetworkqosofmigrationnetworkbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostnetworkqosofmigrationnetworkbyclusterid(v_cluster_id uuid) RETURNS SETOF public.host_network_qos_of_migration_network_by_cluster
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_network_qos_of_migration_network_by_cluster
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.gethostnetworkqosofmigrationnetworkbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: gethostnetworksbycluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostnetworksbycluster(v_cluster_id uuid) RETURNS SETOF public.host_networks_by_cluster_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.vds_id,
        vds_interface.network_name
    FROM vds_static
    INNER JOIN vds_interface
        ON vds_interface.vds_id = vds_static.vds_id
            AND vds_static.cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.gethostnetworksbycluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: gethostnicvfsconfigbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostnicvfsconfigbyid(v_id uuid) RETURNS SETOF public.host_nic_vfs_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_nic_vfs_config
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.gethostnicvfsconfigbyid(v_id uuid) OWNER TO engine;

--
-- Name: gethostproviderbinding(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostproviderbinding(v_vds_id uuid, v_plugin_type character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT binding_host_id
    FROM provider_binding_host_id
    WHERE vds_id = v_vds_id
        AND plugin_type = v_plugin_type;
END;$$;


ALTER FUNCTION public.gethostproviderbinding(v_vds_id uuid, v_plugin_type character varying) OWNER TO engine;

--
-- Name: gethostsandvmsforclusters(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostsandvmsforclusters(v_cluster_ids uuid[]) RETURNS SETOF public.host_vm_cluster_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT groups.cluster_id,
        (
            SELECT COUNT(DISTINCT vds.vds_id)
            FROM vds_static vds
            WHERE vds.cluster_id = groups.cluster_id
            ) AS host_count,
        (
            SELECT COUNT(DISTINCT vms.vm_guid)
            FROM vm_static vms
            WHERE vms.cluster_id = groups.cluster_id
                AND vms.entity_type::TEXT = 'VM'::TEXT
            ) AS vm_count,
        (
            SELECT COUNT(DISTINCT vds_dynamic.vds_id)
            FROM vds_dynamic JOIN vds_static ON vds_static.vds_id = vds_dynamic.vds_id
            WHERE vds_static.cluster_id = groups.cluster_id
                AND vds_dynamic.is_update_available
            ) AS hosts_with_update_available
    FROM cluster groups
    WHERE groups.cluster_id = ANY (v_cluster_ids)
    GROUP BY groups.cluster_id;
END;$$;


ALTER FUNCTION public.gethostsandvmsforclusters(v_cluster_ids uuid[]) OWNER TO engine;

--
-- Name: gethostsforstorageoperation(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gethostsforstorageoperation(v_storage_pool_id uuid, v_local_fs_only boolean) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds.*
        FROM vds
        LEFT JOIN cluster vg
            ON vds.cluster_id = vg.cluster_id
        LEFT JOIN storage_pool sp
            ON vds.storage_pool_id = sp.id
        WHERE (
                v_storage_pool_id IS NULL
                OR vds.storage_pool_id = v_storage_pool_id
                )
            AND (vg.virt_service = true)
            AND (
                NOT v_local_fs_only
                OR sp.is_local = true
                )
            AND (
                v_storage_pool_id IS NOT NULL
                OR vds.status = 3
                )-- if DC is unspecified return only hosts with status = UP
       ORDER BY vds.vds_name;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.gethostsforstorageoperation(v_storage_pool_id uuid, v_local_fs_only boolean) OWNER TO engine;

--
-- Name: getidsforovfdeletion(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getidsforovfdeletion(v_storage_pool_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT ovf.vm_guid AS vm_guid
    FROM vm_ovf_generations ovf
    WHERE ovf.storage_pool_id = v_storage_pool_id
        AND ovf.vm_guid NOT IN (
            SELECT vm_guid
            FROM vm_static
            );
END;$$;


ALTER FUNCTION public.getidsforovfdeletion(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getidsofhostswithstatus(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getidsofhostswithstatus(v_status integer) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_id
    FROM vds_dynamic
    WHERE status = v_status;
END;$$;


ALTER FUNCTION public.getidsofhostswithstatus(v_status integer) OWNER TO engine;

--
-- Name: getimage_storage_domain_mapbyimage_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimage_storage_domain_mapbyimage_id(v_image_id uuid) RETURNS SETOF public.image_storage_domain_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM image_storage_domain_map
    WHERE image_id = v_image_id;
END;$$;


ALTER FUNCTION public.getimage_storage_domain_mapbyimage_id(v_image_id uuid) OWNER TO engine;

--
-- Name: getimage_storage_domain_mapbystorage_domain_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimage_storage_domain_mapbystorage_domain_id(v_storage_domain_id uuid) RETURNS SETOF public.image_storage_domain_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM image_storage_domain_map
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.getimage_storage_domain_mapbystorage_domain_id(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: vm_images_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_images_view AS
 SELECT storage_for_image_view.storage_id,
    storage_for_image_view.storage_name,
    storage_for_image_view.storage_type,
    images_storage_domain_view.storage_pool_id,
    images_storage_domain_view.image_guid,
    images_storage_domain_view.creation_date,
    disk_image_dynamic.actual_size,
    disk_image_dynamic.read_rate,
    disk_image_dynamic.read_ops,
    disk_image_dynamic.read_latency_seconds,
    disk_image_dynamic.write_latency_seconds,
    disk_image_dynamic.flush_latency_seconds,
    disk_image_dynamic.write_rate,
    disk_image_dynamic.write_ops,
    images_storage_domain_view.size,
    images_storage_domain_view.it_guid,
    images_storage_domain_view.description,
    images_storage_domain_view.parentid,
    images_storage_domain_view.imagestatus,
    images_storage_domain_view.lastmodified,
    images_storage_domain_view.app_list,
    images_storage_domain_view.vm_snapshot_id,
    images_storage_domain_view.volume_type,
    images_storage_domain_view.image_group_id,
    images_storage_domain_view.active,
    images_storage_domain_view.volume_classification,
    images_storage_domain_view.volume_format,
    images_storage_domain_view.qcow_compat,
    images_storage_domain_view.wipe_after_delete,
    images_storage_domain_view.propagate_errors,
    images_storage_domain_view.sgio,
    images_storage_domain_view.disk_content_type,
    images_storage_domain_view.backup,
    images_storage_domain_view.backup_mode,
    images_storage_domain_view.sequence_number,
    images_storage_domain_view.entity_type,
    images_storage_domain_view.number_of_vms,
    images_storage_domain_view.vm_names,
    images_storage_domain_view.template_version_names,
    storage_for_image_view.quota_id,
    storage_for_image_view.quota_name,
    images_storage_domain_view.quota_enforcement_type,
    storage_for_image_view.disk_profile_id,
    storage_for_image_view.disk_profile_name,
    images_storage_domain_view.disk_id,
    images_storage_domain_view.disk_alias,
    images_storage_domain_view.disk_description,
    images_storage_domain_view.shareable,
    images_storage_domain_view.image_transfer_phase,
    images_storage_domain_view.image_transfer_type,
    images_storage_domain_view.image_transfer_bytes_sent,
    images_storage_domain_view.image_transfer_bytes_total,
    images_storage_domain_view.progress,
    images_storage_domain_view.disk_storage_type,
    images_storage_domain_view.cinder_volume_type
   FROM ((public.images_storage_domain_view
     JOIN public.disk_image_dynamic ON ((images_storage_domain_view.image_guid = disk_image_dynamic.image_id)))
     JOIN public.storage_for_image_view ON ((images_storage_domain_view.image_guid = storage_for_image_view.image_id)))
  WHERE (images_storage_domain_view.active = true);


ALTER TABLE public.vm_images_view OWNER TO engine;

--
-- Name: getimagebyimageguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimagebyimageguid(v_image_guid uuid) RETURNS SETOF public.vm_images_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM vm_images_view
     WHERE image_guid = v_image_guid;
END; $$;


ALTER FUNCTION public.getimagebyimageguid(v_image_guid uuid) OWNER TO engine;

--
-- Name: getimagebyimageid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimagebyimageid(v_image_guid uuid) RETURNS SETOF public.images
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM images
    WHERE image_guid = v_image_guid;
END;$$;


ALTER FUNCTION public.getimagebyimageid(v_image_guid uuid) OWNER TO engine;

--
-- Name: getimageswhichhavenodisk(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimageswhichhavenodisk(v_vm_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT i.*
     FROM   images_storage_domain_view i
     JOIN   snapshots s ON (i.vm_snapshot_id = s.snapshot_id)
     WHERE  s.vm_id = v_vm_id
     AND NOT EXISTS (
         SELECT 1
         FROM   base_disks d
         WHERE  d.disk_id = i.image_group_id);
END; $$;


ALTER FUNCTION public.getimageswhichhavenodisk(v_vm_id uuid) OWNER TO engine;

--
-- Name: getimageswithdamagedsnapshotforvm(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimageswithdamagedsnapshotforvm(v_vm_guid uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT device_id
    FROM vm_device
    WHERE vm_id = v_vm_guid
        AND device_id IN (
            SELECT image_group_id
            FROM images i
            WHERE i.image_group_id = image_group_id
            GROUP BY image_group_id
            HAVING COALESCE(sum(CASE WHEN active THEN 1 ELSE 0 END),0) <> 1
            UNION
            SELECT image_group_id
            FROM images i
            WHERE NOT EXISTS (
                SELECT *
                FROM snapshots
                WHERE i.vm_snapshot_id = snapshots.snapshot_id)
                    AND i.vm_snapshot_id is not null
                    AND i.vm_snapshot_id != '00000000-0000-0000-0000-000000000000'::uuid
        );
END;$$;


ALTER FUNCTION public.getimageswithdamagedsnapshotforvm(v_vm_guid uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getimagetransfersbybackupid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimagetransfersbybackupid(v_backup_id uuid) RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers
    WHERE image_transfers.backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.getimagetransfersbybackupid(v_backup_id uuid) OWNER TO engine;

--
-- Name: getimagetransfersbystorageid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimagetransfersbystorageid(v_storage_id uuid) RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers
    INNER JOIN images ON images.image_group_id = image_transfers.disk_id
    INNER JOIN image_storage_domain_map ON image_storage_domain_map.image_id = images.image_guid
    WHERE image_storage_domain_map.storage_domain_id = v_storage_id;
END;$$;


ALTER FUNCTION public.getimagetransfersbystorageid(v_storage_id uuid) OWNER TO engine;

--
-- Name: getimagetransfersbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimagetransfersbyvdsid(v_vds_id uuid) RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers
    WHERE image_transfers.vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.getimagetransfersbyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getimageuploadsbycommandid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimageuploadsbycommandid(v_command_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers
    WHERE image_transfers.command_id = v_command_id AND
    (NOT v_is_filtered OR EXISTS (SELECT    1
                                  FROM      user_disk_permissions_view
                                  WHERE     user_disk_permissions_view.user_id = v_user_id AND
                                            user_disk_permissions_view.entity_id = image_transfers.disk_id ));
END;$$;


ALTER FUNCTION public.getimageuploadsbycommandid(v_command_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getimageuploadsbydiskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getimageuploadsbydiskid(v_disk_id uuid) RETURNS SETOF public.image_transfers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT image_transfers.*
    FROM image_transfers
    WHERE image_transfers.disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.getimageuploadsbydiskid(v_disk_id uuid) OWNER TO engine;

--
-- Name: getinterface_viewbyaddr(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getinterface_viewbyaddr(v_cluster_id uuid, v_addr character varying) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_interface_view.*
    FROM vds_interface_view
    INNER JOIN vds_static
        ON vds_interface_view.vds_id = vds_static.vds_id
    WHERE (vds_interface_view.addr = v_addr
        OR vds_interface_view.ipv6_address = v_addr)
        AND vds_static.cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getinterface_viewbyaddr(v_cluster_id uuid, v_addr character varying) OWNER TO engine;

--
-- Name: getinterfacesbydatacenterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getinterfacesbydatacenterid(v_data_center_id uuid) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_interface_view.*
    FROM vds_interface_view
    INNER JOIN vds_static
        ON vds_interface_view.vds_id = vds_static.vds_id
    INNER JOIN cluster
        ON vds_static.cluster_id = cluster.cluster_id
    WHERE cluster.storage_pool_id = v_data_center_id;
END;$$;


ALTER FUNCTION public.getinterfacesbydatacenterid(v_data_center_id uuid) OWNER TO engine;

--
-- Name: getinterfaceswithqosbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getinterfaceswithqosbyclusterid(v_cluster_id uuid) RETURNS SETOF public.vds_interface_view_qos_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT
        s1.rx_rate,
        s1.tx_rate,
        s1.rx_drop,
        s1.tx_drop,
        s1.rx_total,
        s1.tx_total,
        s1.rx_offset,
        s1.tx_offset,
        s1.iface_status,
        s1.sample_time,
        s1.type,
        s1.gateway,
        s1.ipv4_default_route,
        s1.ipv6_gateway,
        s1.subnet,
        s1.ipv6_prefix,
        s1.addr,
        s1.ipv6_address,
        s1.speed,
        s1.base_interface,
        s1.vlan_id,
        s1.bond_type,
        s1.bond_name,
        s1.is_bond,
        s1.bond_opts,
        s1.mac_addr,
        s1.network_name,
        s1.name,
        s1.vds_id,
        s1.vds_name,
        s1.id,
        s1.boot_protocol,
        s1.ipv6_boot_protocol,
        s1.mtu,
        s1.bridged,
        s1.reported_switch_type,
        s1.is_vds,
        s1.qos_overridden,
        s1.labels,
        s1.cluster_id,
        s1.ad_partner_mac,
        s1.ad_aggregator_id,
        s1.bond_active_slave,
        s2.id AS qos_id,
        s2.name AS qos_name,
        s2.qos_type,
        s2.out_average_linkshare,
        s2.out_average_upperlimit,
        s2.out_average_realtime
    FROM (
        SELECT vds_interface_view.*
        FROM vds_interface_view
        INNER JOIN vds_static
            ON vds_interface_view.vds_id = vds_static.vds_id
        WHERE vds_static.cluster_id = v_cluster_id
        ) s1
    LEFT JOIN (
            SELECT *
            FROM qos
            WHERE qos.qos_type = 4
        ) s2
        ON s1.id = s2.id
    ;
END;$$;


ALTER FUNCTION public.getinterfaceswithqosbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getinterfaceviewwithqosbyvdsid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getinterfaceviewwithqosbyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds_interface_view_qos_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT
        s1.rx_rate,
        s1.tx_rate,
        s1.rx_drop,
        s1.tx_drop,
        s1.rx_total,
        s1.tx_total,
        s1.rx_offset,
        s1.tx_offset,
        s1.iface_status,
        s1.sample_time,
        s1.type,
        s1.gateway,
        s1.ipv4_default_route,
        s1.ipv6_gateway,
        s1.subnet,
        s1.ipv6_prefix,
        s1.addr,
        s1.ipv6_address,
        s1.speed,
        s1.base_interface,
        s1.vlan_id,
        s1.bond_type,
        s1.bond_name,
        s1.is_bond,
        s1.bond_opts,
        s1.mac_addr,
        s1.network_name,
        s1.name,
        s1.vds_id,
        s1.vds_name,
        s1.id,
        s1.boot_protocol,
        s1.ipv6_boot_protocol,
        s1.mtu,
        s1.bridged,
        s1.reported_switch_type,
        s1.is_vds,
        s1.qos_overridden,
        s1.labels,
        s1.cluster_id,
        s1.ad_partner_mac,
        s1.ad_aggregator_id,
        s1.bond_active_slave,
        s2.id AS qos_id,
        s2.name AS qos_name,
        s2.qos_type,
        s2.out_average_linkshare,
        s2.out_average_upperlimit,
        s2.out_average_realtime
    FROM (
        SELECT *
        FROM vds_interface_view
        WHERE vds_id = v_vds_id
            AND (
                NOT v_is_filtered
                OR EXISTS (
                    SELECT 1
                    FROM user_vds_permissions_view
                    WHERE user_id = v_user_id
                        AND entity_id = v_vds_id
                    )
                )
        ) s1
    LEFT JOIN (
            SELECT *
            FROM qos
            WHERE qos.qos_type = 4
        ) s2
        ON s1.id = s2.id
    ;
END;$$;


ALTER FUNCTION public.getinterfaceviewwithqosbyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getisclusterempty(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getisclusterempty(v_cluster_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN NOT EXISTS (
            SELECT 1
            FROM vm_static
            WHERE cluster_id = v_cluster_id
                AND vm_guid != '00000000-0000-0000-0000-000000000000'
            )
        AND NOT EXISTS (
            SELECT 1
            FROM vds_static
            WHERE cluster_id = v_cluster_id
            );
END;$$;


ALTER FUNCTION public.getisclusterempty(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getiscsibondbyiscsibondid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getiscsibondbyiscsibondid(v_id uuid) RETURNS SETOF public.iscsi_bonds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds.*
    FROM iscsi_bonds
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getiscsibondbyiscsibondid(v_id uuid) OWNER TO engine;

--
-- Name: getiscsibondsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getiscsibondsbynetworkid(v_network_id uuid) RETURNS SETOF public.iscsi_bonds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds.*
    FROM iscsi_bonds_networks_map,
        iscsi_bonds
    WHERE iscsi_bonds.id = iscsi_bonds_networks_map.iscsi_bond_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getiscsibondsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getiscsibondsbystoragepoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getiscsibondsbystoragepoolid(v_storage_pool_id uuid) RETURNS SETOF public.iscsi_bonds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds.*
    FROM iscsi_bonds
    WHERE storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getiscsibondsbystoragepoolid(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getiscsiifacesbyhostidandstoragetargetid(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getiscsiifacesbyhostidandstoragetargetid(v_host_id uuid, v_target_id character varying) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_interface_view.*
    FROM vds_interface_view,
        network_cluster,
        network,
        iscsi_bonds_networks_map,
        iscsi_bonds_storage_connections_map
    WHERE iscsi_bonds_storage_connections_map.connection_id = v_target_id
        AND iscsi_bonds_storage_connections_map.iscsi_bond_id = iscsi_bonds_networks_map.iscsi_bond_id
        AND iscsi_bonds_networks_map.network_id = network.id
        AND network.id = network_cluster.network_id
        AND network.name = vds_interface_view.network_name
        AND network_cluster.cluster_id = vds_interface_view.cluster_id
        AND vds_interface_view.vds_id = v_host_id;
END;$$;


ALTER FUNCTION public.getiscsiifacesbyhostidandstoragetargetid(v_host_id uuid, v_target_id character varying) OWNER TO engine;

--
-- Name: repo_file_meta_data; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.repo_file_meta_data (
    repo_domain_id uuid NOT NULL,
    repo_image_id character varying(256) NOT NULL,
    size bigint,
    date_created timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    last_refreshed bigint DEFAULT 0,
    file_type integer DEFAULT 0 NOT NULL,
    repo_image_name character varying(256)
);


ALTER TABLE public.repo_file_meta_data OWNER TO engine;

--
-- Name: getisodisksbystoragepool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getisodisksbystoragepool(v_storage_pool_id uuid) RETURNS SETOF public.repo_file_meta_data
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT repo_domain_id,
           repo_image_id,
           size,
           date_created,
           last_refreshed,
           file_type,
           repo_image_name
    FROM iso_disks_as_repo_images
    WHERE storage_pool_id = v_storage_pool_id
        AND status = 3  -- The status of an active storage domain is 3
    ORDER BY repo_image_name;
END;$$;


ALTER FUNCTION public.getisodisksbystoragepool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getjobbyjobid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getjobbyjobid(v_job_id uuid) RETURNS SETOF public.job
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT job.*
    FROM JOB
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.getjobbyjobid(v_job_id uuid) OWNER TO engine;

--
-- Name: getjobsbycorrelationid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getjobsbycorrelationid(v_correlation_id character varying) RETURNS SETOF public.job
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT job.*
    FROM JOB
    WHERE correlation_id = v_correlation_id;
END;$$;


ALTER FUNCTION public.getjobsbycorrelationid(v_correlation_id character varying) OWNER TO engine;

--
-- Name: getjobsbyenginesessionseqidandstatus(bigint, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getjobsbyenginesessionseqidandstatus(v_engine_session_seq_id bigint, v_status character varying) RETURNS SETOF public.job
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT job.*
    FROM JOB
    WHERE engine_session_seq_id = v_engine_session_seq_id
        AND status = v_status;
END;$$;


ALTER FUNCTION public.getjobsbyenginesessionseqidandstatus(v_engine_session_seq_id bigint, v_status character varying) OWNER TO engine;

--
-- Name: getjobsbyoffsetandpagesize(integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getjobsbyoffsetandpagesize(v_position integer, v_page_size integer) RETURNS SETOF public.job
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY(SELECT job.* FROM JOB WHERE status = 'STARTED' ORDER BY last_update_time DESC)

    UNION ALL

    (
        SELECT job.*
        FROM JOB
        WHERE status NOT IN (
                'STARTED',
                'UNKNOWN'
                )
        ORDER BY last_update_time DESC
        ) OFFSET v_position LIMIT v_page_size;
END;$$;


ALTER FUNCTION public.getjobsbyoffsetandpagesize(v_position integer, v_page_size integer) OWNER TO engine;

--
-- Name: getjobsubjectentitybyjobid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getjobsubjectentitybyjobid(v_job_id uuid) RETURNS SETOF public.job_subject_entity
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT job_subject_entity.*
    FROM job_subject_entity
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.getjobsubjectentitybyjobid(v_job_id uuid) OWNER TO engine;

--
-- Name: getkdumpstatusforvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getkdumpstatusforvds(v_vds_id uuid) RETURNS SETOF public.vds_kdump_status
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds_kdump_status
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.getkdumpstatusforvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getlabelbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlabelbyid(v_label_id uuid) RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view
    WHERE label_id = v_label_id;
END;$$;


ALTER FUNCTION public.getlabelbyid(v_label_id uuid) OWNER TO engine;

--
-- Name: getlabelbyids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlabelbyids(v_label_ids uuid[]) RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view
    WHERE label_id = ANY(v_label_ids);
END;$$;


ALTER FUNCTION public.getlabelbyids(v_label_ids uuid[]) OWNER TO engine;

--
-- Name: getlabelbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlabelbyname(v_label_name character varying) RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view
    WHERE label_name = v_label_name;
END;$$;


ALTER FUNCTION public.getlabelbyname(v_label_name character varying) OWNER TO engine;

--
-- Name: getlabelsbyreferencedids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlabelsbyreferencedids(v_entity_ids uuid[]) RETURNS SETOF public.labels_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT labels_map_view.*
    FROM labels_map_view
    WHERE vm_ids::uuid[] && v_entity_ids
        OR vds_ids::uuid[] && v_entity_ids;
END;$$;


ALTER FUNCTION public.getlabelsbyreferencedids(v_entity_ids uuid[]) OWNER TO engine;

--
-- Name: getlabelsbyvfsconfigid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlabelsbyvfsconfigid(v_vfs_config_id uuid) RETURNS SETOF text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT label
    FROM vfs_config_labels
    WHERE vfs_config_id = v_vfs_config_id;
END;$$;


ALTER FUNCTION public.getlabelsbyvfsconfigid(v_vfs_config_id uuid) OWNER TO engine;

--
-- Name: engine_backup_log; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.engine_backup_log (
    scope character varying(64) NOT NULL,
    done_at timestamp with time zone NOT NULL,
    is_passed boolean,
    output_message text,
    fqdn character varying(255),
    log_path text
);


ALTER TABLE public.engine_backup_log OWNER TO engine;

--
-- Name: getlastsuccessfulenginebackup(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlastsuccessfulenginebackup(v_scope character varying) RETURNS SETOF public.engine_backup_log
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM engine_backup_log
    WHERE scope = v_scope
        AND is_passed
    ORDER BY scope,
        done_at DESC LIMIT 1;
END;$$;


ALTER FUNCTION public.getlastsuccessfulenginebackup(v_scope character varying) OWNER TO engine;

--
-- Name: getlibvirtsecretbylibvirtsecretid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlibvirtsecretbylibvirtsecretid(v_secret_id uuid) RETURNS SETOF public.libvirt_secrets
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM libvirt_secrets
    WHERE secret_id = v_secret_id;
END;$$;


ALTER FUNCTION public.getlibvirtsecretbylibvirtsecretid(v_secret_id uuid) OWNER TO engine;

--
-- Name: getlibvirtsecretsbypoolidonactivedomains(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlibvirtsecretsbypoolidonactivedomains(v_storage_pool_id uuid) RETURNS SETOF public.libvirt_secrets
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT libvirt_secrets.*
    FROM libvirt_secrets
    INNER JOIN storage_domain_static
        ON CAST(libvirt_secrets.provider_id AS VARCHAR) = storage_domain_static.storage
    INNER JOIN storage_pool_iso_map
        ON storage_domain_static.id = storage_pool_iso_map.storage_id
    WHERE storage_pool_iso_map.storage_pool_id = v_storage_pool_id
        AND storage_pool_iso_map.status = 3;-- Active
END;$$;


ALTER FUNCTION public.getlibvirtsecretsbypoolidonactivedomains(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getlun_storage_server_connection_mapbylun(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlun_storage_server_connection_mapbylun(v_lun_id character varying) RETURNS SETOF public.lun_storage_server_connection_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM LUN_storage_server_connection_map lUN_storage_server_connection_map
    WHERE LUN_id = v_LUN_id;
END;$$;


ALTER FUNCTION public.getlun_storage_server_connection_mapbylun(v_lun_id character varying) OWNER TO engine;

--
-- Name: getlun_storage_server_connection_mapbylunbystorage_server_conn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlun_storage_server_connection_mapbylunbystorage_server_conn(v_lun_id character varying, v_storage_server_connection character varying) RETURNS SETOF public.lun_storage_server_connection_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM LUN_storage_server_connection_map lUN_storage_server_connection_map
    WHERE LUN_id = v_LUN_id
        AND storage_server_connection = v_storage_server_connection;
END;$$;


ALTER FUNCTION public.getlun_storage_server_connection_mapbylunbystorage_server_conn(v_lun_id character varying, v_storage_server_connection character varying) OWNER TO engine;

--
-- Name: getlunbylunid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlunbylunid(v_lun_id character varying) RETURNS SETOF public.luns_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM luns_view
    WHERE LUN_id = v_LUN_id;
END;$$;


ALTER FUNCTION public.getlunbylunid(v_lun_id character varying) OWNER TO engine;

--
-- Name: getlunsbystorage_server_connection(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlunsbystorage_server_connection(v_storage_server_connection character varying) RETURNS SETOF public.luns_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT luns_view.*
    FROM luns_view
    INNER JOIN LUN_storage_server_connection_map
        ON LUN_storage_server_connection_map.LUN_id = luns_view.LUN_id
    WHERE LUN_storage_server_connection_map.storage_server_connection = v_storage_server_connection;
END;$$;


ALTER FUNCTION public.getlunsbystorage_server_connection(v_storage_server_connection character varying) OWNER TO engine;

--
-- Name: getlunsbyvolumegroupid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getlunsbyvolumegroupid(v_volume_group_id character varying) RETURNS SETOF public.luns_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM luns_view
    WHERE volume_group_id = v_volume_group_id;
END;$$;


ALTER FUNCTION public.getlunsbyvolumegroupid(v_volume_group_id character varying) OWNER TO engine;

--
-- Name: getmacpoolbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmacpoolbyclusterid(v_cluster_id uuid) RETURNS SETOF public.mac_pools
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT mp.*
    FROM mac_pools mp
    INNER JOIN cluster c
        ON c.mac_pool_id = mp.id
    WHERE c.cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getmacpoolbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getmacpoolbymacpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmacpoolbymacpoolid(v_id uuid) RETURNS SETOF public.mac_pools
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM mac_pools
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getmacpoolbymacpoolid(v_id uuid) OWNER TO engine;

--
-- Name: getmacsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmacsbyclusterid(v_cluster_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT mac_addr
    FROM vm_interface
    WHERE EXISTS (
            SELECT 1
            FROM vm_static
            WHERE vm_static.cluster_id = v_cluster_id
              AND vm_static.vm_guid = vm_interface.vm_guid
              AND vm_interface.mac_addr IS NOT NULL
            );
END;$$;


ALTER FUNCTION public.getmacsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getmacsbydatacenterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmacsbydatacenterid(v_data_center_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT mac_addr
    FROM vm_interface
    WHERE EXISTS (
            SELECT 1
            FROM vm_static
            INNER JOIN cluster
                ON vm_static.cluster_id = cluster.cluster_id
            WHERE cluster.storage_pool_id = v_data_center_id
                AND vm_static.vm_guid = vm_interface.vm_guid
            );
END;$$;


ALTER FUNCTION public.getmacsbydatacenterid(v_data_center_id uuid) OWNER TO engine;

--
-- Name: getmanagementnetworkbycluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmanagementnetworkbycluster(v_cluster_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    WHERE id = (
            SELECT network_id
            FROM network_cluster
            WHERE network_cluster.cluster_id = v_cluster_id
                AND network_cluster.management
            );
END;$$;


ALTER FUNCTION public.getmanagementnetworkbycluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getmaxsequencenumber(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getmaxsequencenumber(v_image_group_id uuid) RETURNS integer
    LANGUAGE sql
    AS $$
    SELECT MAX(sequence_number)
    FROM images
    WHERE image_group_id = v_image_group_id;
$$;


ALTER FUNCTION public.getmaxsequencenumber(v_image_group_id uuid) OWNER TO engine;

--
-- Name: name_server; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.name_server (
    address character varying(45) NOT NULL,
    "position" smallint,
    dns_resolver_configuration_id uuid NOT NULL
);


ALTER TABLE public.name_server OWNER TO engine;

--
-- Name: getnameserversbydnsresolverconfigurationid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnameserversbydnsresolverconfigurationid(v_dns_resolver_configuration_id uuid) RETURNS SETOF public.name_server
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM name_server
    WHERE dns_resolver_configuration_id = v_dns_resolver_configuration_id
    ORDER BY position ASC;
END;$$;


ALTER FUNCTION public.getnameserversbydnsresolverconfigurationid(v_dns_resolver_configuration_id uuid) OWNER TO engine;

--
-- Name: getnamesofhostsdedicatedtovm(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnamesofhostsdedicatedtovm(v_vm_guid uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_name
        FROM vm_host_pinning_view
        WHERE vm_id = v_vm_guid;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getnamesofhostsdedicatedtovm(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getnetwork_clusterbycluster_idandbynetwork_id(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetwork_clusterbycluster_idandbynetwork_id(v_cluster_id uuid, v_network_id uuid) RETURNS SETOF public.network_cluster
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_cluster
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getnetwork_clusterbycluster_idandbynetwork_id(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: getnetworkattachmentbynetworkattachmentid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkattachmentbynetworkattachmentid(v_id uuid) RETURNS SETOF public.network_attachments
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_attachments
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getnetworkattachmentbynetworkattachmentid(v_id uuid) OWNER TO engine;

--
-- Name: getnetworkattachmentsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkattachmentsbynetworkid(v_network_id uuid) RETURNS SETOF public.network_attachments
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_attachments
    WHERE network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getnetworkattachmentsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getnetworkattachmentsbynicid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkattachmentsbynicid(v_nic_id uuid) RETURNS SETOF public.network_attachments
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_attachments
    WHERE nic_id = v_nic_id;
END;$$;


ALTER FUNCTION public.getnetworkattachmentsbynicid(v_nic_id uuid) OWNER TO engine;

--
-- Name: getnetworkattachmentswithqosbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkattachmentswithqosbyhostid(v_host_id uuid) RETURNS SETOF public.network_attachments_qos_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT
        s1.id,
        s1.network_id,
        s1.nic_id,
        s1.boot_protocol,
        s1.address,
        s1.netmask,
        s1.gateway,
        s1.custom_properties,
        s1._create_date,
        s1._update_date,
        s1.ipv6_boot_protocol,
        s1.ipv6_address,
        s1.ipv6_prefix,
        s1.ipv6_gateway,
        s1.dns_resolver_configuration_id,
        s2.id AS qos_id,
        s2.name AS qos_name,
        s2.qos_type,
        s2.out_average_linkshare,
        s2.out_average_upperlimit,
        s2.out_average_realtime
    FROM (
        SELECT *
        FROM network_attachments na
        WHERE EXISTS (
            SELECT 1
            FROM vds_interface
            WHERE na.nic_id = vds_interface.id
                AND vds_interface.vds_id = v_host_id
            )
        ) s1
    LEFT JOIN (
            SELECT *
            FROM qos
            WHERE qos.qos_type = 4
        ) s2
        ON s1.id = s2.id
    ;
END;$$;


ALTER FUNCTION public.getnetworkattachmentswithqosbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: getnetworkattachmentwithqosbynicidandnetworkid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkattachmentwithqosbynicidandnetworkid(v_nic_id uuid, v_network_id uuid) RETURNS SETOF public.network_attachments_qos_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT
        s1.id,
        s1.network_id,
        s1.nic_id,
        s1.boot_protocol,
        s1.address,
        s1.netmask,
        s1.gateway,
        s1.custom_properties,
        s1._create_date,
        s1._update_date,
        s1.ipv6_boot_protocol,
        s1.ipv6_address,
        s1.ipv6_prefix,
        s1.ipv6_gateway,
        s1.dns_resolver_configuration_id,
        s2.id AS qos_id,
        s2.name AS qos_name,
        s2.qos_type,
        s2.out_average_linkshare,
        s2.out_average_upperlimit,
        s2.out_average_realtime
    FROM (
        SELECT na.*
        FROM network_attachments na
        WHERE na.network_id = v_network_id
            AND na.nic_id = v_nic_id
        ) s1
    LEFT JOIN (
            SELECT *
            FROM qos
            WHERE qos.qos_type = 4
        ) s2
        ON s1.id = s2.id
    ;
END;$$;


ALTER FUNCTION public.getnetworkattachmentwithqosbynicidandnetworkid(v_nic_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: getnetworkbyid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkbyid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network
    WHERE id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_network_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_id
                )
            );
END;$$;


ALTER FUNCTION public.getnetworkbyid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getnetworkbynameandcluster(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkbynameandcluster(v_name character varying, v_cluster_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    WHERE network.name = v_name
        AND EXISTS (
            SELECT 1
            FROM network_cluster
            WHERE network.id = network_cluster.network_id
                AND network_cluster.cluster_id = v_cluster_id
            );
END;$$;


ALTER FUNCTION public.getnetworkbynameandcluster(v_name character varying, v_cluster_id uuid) OWNER TO engine;

--
-- Name: getnetworkbynameanddatacenter(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkbynameanddatacenter(v_name character varying, v_storage_pool_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    WHERE network.name = v_name
        AND network.storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getnetworkbynameanddatacenter(v_name character varying, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getnetworkbyvdsmnameanddatacenterid(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkbyvdsmnameanddatacenterid(v_vdsm_name character varying, v_data_center_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    WHERE vdsm_name = v_vdsm_name
          AND storage_pool_id = v_data_center_id;
END;$$;


ALTER FUNCTION public.getnetworkbyvdsmnameanddatacenterid(v_vdsm_name character varying, v_data_center_id uuid) OWNER TO engine;

--
-- Name: getnetworkfilterbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkfilterbyid(v_filter_id uuid) RETURNS SETOF public.network_filter
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_filter
    WHERE filter_id = v_filter_id;
END;$$;


ALTER FUNCTION public.getnetworkfilterbyid(v_filter_id uuid) OWNER TO engine;

--
-- Name: getnetworkfilterbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworkfilterbyname(v_filter_name character varying) RETURNS SETOF public.network_filter
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM network_filter
    WHERE filter_name like v_filter_name;
END;$$;


ALTER FUNCTION public.getnetworkfilterbyname(v_filter_name character varying) OWNER TO engine;

--
-- Name: getnetworksbyiscsibondid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworksbyiscsibondid(v_iscsi_bond_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT iscsi_bonds_networks_map.network_id
    FROM iscsi_bonds_networks_map
    WHERE iscsi_bond_id = v_iscsi_bond_id;
END;$$;


ALTER FUNCTION public.getnetworksbyiscsibondid(v_iscsi_bond_id uuid) OWNER TO engine;

--
-- Name: getnetworksbyvfsconfigid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnetworksbyvfsconfigid(v_vfs_config_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network_id
    FROM vfs_config_networks
    WHERE vfs_config_id = v_vfs_config_id;
END;$$;


ALTER FUNCTION public.getnetworksbyvfsconfigid(v_vfs_config_id uuid) OWNER TO engine;

--
-- Name: getnoncountablequtoavmstatuses(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnoncountablequtoavmstatuses() RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
RETURN query
    SELECT 0

    UNION ALL

    SELECT 13

    UNION ALL

    SELECT 14

    UNION ALL

    SELECT 15;
    --(Down(0), Suspended(13), ImageIllegal(14), ImageLocked(15))
END;$$;


ALTER FUNCTION public.getnoncountablequtoavmstatuses() OWNER TO engine;

--
-- Name: numa_node_cpus_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.numa_node_cpus_view AS
 SELECT numa_node.numa_node_id,
    numa_node.vds_id,
    numa_node.vm_id,
    numa_node.numa_node_index,
    numa_node.mem_total,
    numa_node.cpu_count,
    numa_node.mem_free,
    numa_node.usage_mem_percent,
    numa_node.cpu_sys,
    numa_node.cpu_user,
    numa_node.cpu_idle,
    numa_node.usage_cpu_percent,
    numa_node.distance,
    numa_node.hugepages,
    numa_node.numa_tune_mode,
    numa_node_to_cpu_core_ids.numa_node_id2,
    numa_node_to_cpu_core_ids.cpu_core_ids
   FROM (public.numa_node
     JOIN ( SELECT numa_node_cpu_map.numa_node_id AS numa_node_id2,
            array_agg(numa_node_cpu_map.cpu_core_id ORDER BY numa_node_cpu_map.cpu_core_id) AS cpu_core_ids
           FROM public.numa_node_cpu_map
          GROUP BY numa_node_cpu_map.numa_node_id) numa_node_to_cpu_core_ids ON ((numa_node.numa_node_id = numa_node_to_cpu_core_ids.numa_node_id2)));


ALTER TABLE public.numa_node_cpus_view OWNER TO engine;

--
-- Name: getnumanodebyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnumanodebyvdsid(v_vds_id uuid) RETURNS SETOF public.numa_node_cpus_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT numa_node_cpus_view.*
        FROM numa_node_cpus_view
        WHERE vds_id = v_vds_id
        ORDER BY numa_node_index ASC;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getnumanodebyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getnumanodebyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnumanodebyvmid(v_vm_id uuid) RETURNS SETOF public.numa_node_cpus_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT numa_node_cpus_view.*
        FROM numa_node_cpus_view
        WHERE vm_id = v_vm_id
        ORDER BY numa_node_index ASC;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getnumanodebyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getnumberofimagesinstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnumberofimagesinstoragedomain(v_storage_domain_id uuid) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT COUNT(*)
    FROM image_storage_domain_map
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.getnumberofimagesinstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getnumberofvmsincluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnumberofvmsincluster(v_cluster_id uuid) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT COUNT(vms.*)
    FROM vm_static vms
    WHERE vms.cluster_id = v_cluster_id
        AND vms.entity_type = 'VM';
END;$$;


ALTER FUNCTION public.getnumberofvmsincluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getnumofsnapshotsbymemoryvolume(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnumofsnapshotsbymemoryvolume(v_memory_disk_ids uuid[]) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT COUNT(*)
    FROM snapshots
    WHERE memory_dump_disk_id  = ANY(v_memory_disk_ids)
       OR memory_metadata_disk_id  = ANY(v_memory_disk_ids);
END;$$;


ALTER FUNCTION public.getnumofsnapshotsbymemoryvolume(v_memory_disk_ids uuid[]) OWNER TO engine;

--
-- Name: getnvmtagsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnvmtagsbyvmid(v_vm_id uuid) RETURNS SETOF public.tags_vm_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM tags_vm_map
    WHERE tags_vm_map.vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.getnvmtagsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getnvmtagsbyvmidanddefaulttag(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnvmtagsbyvmidanddefaulttag(v_vm_id uuid) RETURNS SETOF public.tags_vm_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vm_map.*
    FROM tags_vm_map
    INNER JOIN tags
        ON tags.tag_id = tags_vm_map.tag_id
    WHERE tags_vm_map.vm_id = v_vm_id
        AND tags.type = 1;
END;$$;


ALTER FUNCTION public.getnvmtagsbyvmidanddefaulttag(v_vm_id uuid) OWNER TO engine;

--
-- Name: getnvramdata(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getnvramdata(v_vm_id uuid) RETURNS SETOF public.vmexternaldata_rs
    LANGUAGE sql
    AS $$
    SELECT nvram_data, nvram_hash
    FROM vm_nvram_data
    WHERE vm_id = v_vm_id
$$;


ALTER FUNCTION public.getnvramdata(v_vm_id uuid) OWNER TO engine;

--
-- Name: getoptionsbyglustervolumeguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getoptionsbyglustervolumeguid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_options
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.getoptionsbyglustervolumeguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: getorderedvmguidsforrunmultipleactions(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getorderedvmguidsforrunmultipleactions(v_vm_guids character varying) RETURNS SETOF public.getorderedvmguidsforrunmultipleactions_rs
    LANGUAGE plpgsql STABLE
    AS $$
   DECLARE
   v_ordered_guids GetOrderedVmGuidsForRunMultipleActions_rs;
BEGIN
   FOR v_ordered_guids IN
       EXECUTE 'SELECT vm_guid from vm_static where vm_guid in( ' || v_vm_guids || ' ) AND entity_type = ''VM''  order by auto_startup desc,priority desc, migration_support desc'
   LOOP
      RETURN NEXT v_ordered_guids;
   END LOOP;

END; $$;


ALTER FUNCTION public.getorderedvmguidsforrunmultipleactions(v_vm_guids character varying) OWNER TO engine;

--
-- Name: getovfdatabyentityidandstoragedomain(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getovfdatabyentityidandstoragedomain(v_entity_guid uuid, v_storage_domain_id uuid) RETURNS SETOF public.unregistered_ovf_of_entities
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM unregistered_ovf_of_entities
    WHERE entity_guid = v_entity_guid
        AND (
            storage_domain_id = v_storage_domain_id
            OR v_storage_domain_id IS NULL
            );
END;$$;


ALTER FUNCTION public.getovfdatabyentityidandstoragedomain(v_entity_guid uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getovfgeneration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getovfgeneration(v_vm_id uuid) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm.ovf_generation
    FROM vm_ovf_generations vm
    WHERE vm.vm_guid = v_vm_id;
END;$$;


ALTER FUNCTION public.getovfgeneration(v_vm_id uuid) OWNER TO engine;

--
-- Name: getpermissionbyroleid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionbyroleid(v_role_id uuid) RETURNS SETOF public.permissions
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM permissions
   WHERE role_id = v_role_id;
END; $$;


ALTER FUNCTION public.getpermissionbyroleid(v_role_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyadelementandobjectid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyadelementandobjectid(v_ad_element_id uuid, v_object_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM permissions_view
    WHERE ad_element_id = v_ad_element_id
        AND object_id = v_object_id;
END; $$;


ALTER FUNCTION public.getpermissionsbyadelementandobjectid(v_ad_element_id uuid, v_object_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyadelementid(uuid, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyadelementid(v_ad_element_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE (permissions_view.app_mode & v_app_mode) > 0
        AND (
            permissions_view.ad_element_id = v_ad_element_id
            OR ad_element_id IN (
                SELECT *
                FROM GetSessionUserAndGroupsById(v_ad_element_id, v_engine_session_seq_id)
                )
            )
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_permissions_permissions_view uv,
                    engine_sessions
                WHERE uv.user_id = engine_sessions.user_id
                    AND engine_sessions.id = v_engine_session_seq_id
                )
            );
END;$$;


ALTER FUNCTION public.getpermissionsbyadelementid(v_ad_element_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: getpermissionsbyadelementidandgroupids(uuid, uuid, uuid[], boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyadelementidandgroupids(v_ad_element_id uuid, v_user_id uuid, v_user_groups uuid[], v_is_filtered boolean, v_app_mode integer) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE (permissions_view.app_mode & v_app_mode) > 0
        AND (
            permissions_view.ad_element_id = v_ad_element_id
            OR ad_element_id = ANY(array_append(v_user_groups, 'EEE00000-0000-0000-0000-123456789EEE'))
            )
        AND (NOT v_is_filtered OR v_user_id = v_ad_element_id);
END;$$;


ALTER FUNCTION public.getpermissionsbyadelementidandgroupids(v_ad_element_id uuid, v_user_id uuid, v_user_groups uuid[], v_is_filtered boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: getpermissionsbyentityid(uuid, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM permissions_view
    WHERE  (permissions_view.app_mode & v_app_mode) > 0
        AND object_id = v_id
        AND (NOT v_is_filtered OR EXISTS (
            SELECT 1
            FROM GetUserPermissionsByEntityId(
                v_id,
                v_engine_session_seq_id,
                v_is_filtered)
        )
    );
END; $$;


ALTER FUNCTION public.getpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: getpermissionsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyid(v_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getpermissionsbyid(v_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyroleid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyroleid(v_role_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE role_id = v_role_id;
END;$$;


ALTER FUNCTION public.getpermissionsbyroleid(v_role_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyroleidandadelementid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyroleidandadelementid(v_role_id uuid, v_ad_element_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE role_id = v_role_id
        AND ad_element_id = v_ad_element_id;
END;$$;


ALTER FUNCTION public.getpermissionsbyroleidandadelementid(v_role_id uuid, v_ad_element_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyroleidandadelementidandobjectid(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyroleidandadelementidandobjectid(v_role_id uuid, v_ad_element_id uuid, v_object_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM permissions_view
    WHERE role_id = v_role_id
        AND ad_element_id = v_ad_element_id
        AND object_id = v_object_id;
END;$$;


ALTER FUNCTION public.getpermissionsbyroleidandadelementidandobjectid(v_role_id uuid, v_ad_element_id uuid, v_object_id uuid) OWNER TO engine;

--
-- Name: getpermissionsbyroleidandobjectid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionsbyroleidandobjectid(v_role_id uuid, v_object_id uuid) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM permissions_view
   WHERE role_id = v_role_id
       AND object_id = v_object_id;

END; $$;


ALTER FUNCTION public.getpermissionsbyroleidandobjectid(v_role_id uuid, v_object_id uuid) OWNER TO engine;

--
-- Name: getpermissionstreebyentityid(uuid, integer, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpermissionstreebyentityid(v_id uuid, v_object_type_id integer, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM  permissions_view p
    WHERE  (p.app_mode & v_app_mode) > 0
        AND object_id IN(
            SELECT id
            FROM fn_get_entity_parents(v_id,v_object_type_id))
        AND (NOT v_is_filtered
             OR EXISTS (
                 SELECT 1
                 FROM engine_session_user_flat_groups u
                 WHERE  p.ad_element_id = u.granted_id
                     AND u.engine_session_seq_id = v_engine_session_seq_id)
        );

END; $$;


ALTER FUNCTION public.getpermissionstreebyentityid(v_id uuid, v_object_type_id integer, v_engine_session_seq_id integer, v_is_filtered boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: getpluggedvminterfacesbymac(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpluggedvminterfacesbymac(v_mac_address character varying) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_view
    WHERE mac_addr = v_mac_address
        AND is_plugged = true;
END;$$;


ALTER FUNCTION public.getpluggedvminterfacesbymac(v_mac_address character varying) OWNER TO engine;

--
-- Name: getpolicyunitbypolicyunitid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpolicyunitbypolicyunitid(v_id uuid) RETURNS SETOF public.policy_units
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM policy_units
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getpolicyunitbypolicyunitid(v_id uuid) OWNER TO engine;

--
-- Name: getpositiveenforcingaffinitygroupsbyrunningvmsonvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getpositiveenforcingaffinitygroupsbyrunningvmsonvdsid(v_vds_id uuid) RETURNS SETOF public.affinity_groups_with_members_from_labels_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT affinity_groups_with_members_from_labels_view.*
    FROM affinity_groups_with_members_from_labels_view
    INNER JOIN affinity_group_members
        ON id = affinity_group_members.affinity_group_id
    INNER JOIN vm_dynamic
        ON affinity_group_members.vm_id = vm_dynamic.vm_guid
            AND vm_dynamic.run_on_vds = v_vds_id
    WHERE (vm_enforcing AND vm_positive AND vms_affinity_enabled)
        OR (vds_enforcing AND vds_positive);
END;$$;


ALTER FUNCTION public.getpositiveenforcingaffinitygroupsbyrunningvmsonvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getproviderbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getproviderbyname(v_name character varying) RETURNS SETOF public.providers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM providers
    WHERE name = v_name;
END;$$;


ALTER FUNCTION public.getproviderbyname(v_name character varying) OWNER TO engine;

--
-- Name: getproviderbyproviderid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getproviderbyproviderid(v_id uuid) RETURNS SETOF public.providers
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM providers
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getproviderbyproviderid(v_id uuid) OWNER TO engine;

--
-- Name: qos_for_disk_profile_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.qos_for_disk_profile_view AS
 SELECT qos.id,
    qos.qos_type,
    qos.name,
    qos.description,
    qos.storage_pool_id,
    qos.max_throughput,
    qos.max_read_throughput,
    qos.max_write_throughput,
    qos.max_iops,
    qos.max_read_iops,
    qos.max_write_iops,
    qos._create_date,
    qos._update_date,
    qos.cpu_limit,
    qos.inbound_average,
    qos.inbound_peak,
    qos.inbound_burst,
    qos.outbound_average,
    qos.outbound_peak,
    qos.outbound_burst,
    qos.out_average_linkshare,
    qos.out_average_upperlimit,
    qos.out_average_realtime,
    disk_profiles.id AS disk_profile_id
   FROM (public.qos
     JOIN public.disk_profiles ON ((qos.id = disk_profiles.qos_id)));


ALTER TABLE public.qos_for_disk_profile_view OWNER TO engine;

--
-- Name: getqosbydiskprofiles(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getqosbydiskprofiles(v_disk_profile_ids uuid[]) RETURNS SETOF public.qos_for_disk_profile_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos_for_disk_profile_view
    WHERE disk_profile_id = ANY(v_disk_profile_ids);

END;$$;


ALTER FUNCTION public.getqosbydiskprofiles(v_disk_profile_ids uuid[]) OWNER TO engine;

--
-- Name: getqosbyqosid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getqosbyqosid(v_id uuid) RETURNS SETOF public.qos
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getqosbyqosid(v_id uuid) OWNER TO engine;

--
-- Name: qos_for_vm_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.qos_for_vm_view AS
 SELECT qos.id,
    qos.qos_type,
    qos.name,
    qos.description,
    qos.storage_pool_id,
    qos.max_throughput,
    qos.max_read_throughput,
    qos.max_write_throughput,
    qos.max_iops,
    qos.max_read_iops,
    qos.max_write_iops,
    qos._create_date,
    qos._update_date,
    qos.cpu_limit,
    qos.inbound_average,
    qos.inbound_peak,
    qos.inbound_burst,
    qos.outbound_average,
    qos.outbound_peak,
    qos.outbound_burst,
    qos.out_average_linkshare,
    qos.out_average_upperlimit,
    qos.out_average_realtime,
    vm_static.vm_guid AS vm_id
   FROM ((public.qos
     JOIN public.cpu_profiles ON ((qos.id = cpu_profiles.qos_id)))
     JOIN public.vm_static ON ((vm_static.cpu_profile_id = cpu_profiles.id)));


ALTER TABLE public.qos_for_vm_view OWNER TO engine;

--
-- Name: getqosbyvmids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getqosbyvmids(v_vm_ids uuid[]) RETURNS SETOF public.qos_for_vm_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM qos_for_vm_view
    WHERE vm_id = ANY(v_vm_ids);
END;$$;


ALTER FUNCTION public.getqosbyvmids(v_vm_ids uuid[]) OWNER TO engine;

--
-- Name: getquotabyadelementid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotabyadelementid(v_ad_element_id uuid, v_storage_pool_id uuid, v_recursive boolean) RETURNS SETOF public.quota_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_view
    WHERE quota_view.quota_id IN (
            SELECT object_id
            FROM PERMISSIONS
            WHERE object_type_id = 17
                AND role_id IN (
                    SELECT role_id
                    FROM ROLES_groups
                    WHERE action_group_id = 901
                    )
                AND ad_element_id = v_ad_element_id
                OR (
                    v_recursive
                    AND ad_element_id IN (
                        SELECT *
                        FROM getUserAndGroupsById(v_ad_element_id)
                        )
                    )
            )
        AND (
            v_storage_pool_id = quota_view.storage_pool_id
            OR v_storage_pool_id IS NULL
            );
END;$$;


ALTER FUNCTION public.getquotabyadelementid(v_ad_element_id uuid, v_storage_pool_id uuid, v_recursive boolean) OWNER TO engine;

--
-- Name: getquotabyquotaguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotabyquotaguid(v_id uuid) RETURNS SETOF public.quota_global_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_global_view
    WHERE quota_id = v_id;
END;$$;


ALTER FUNCTION public.getquotabyquotaguid(v_id uuid) OWNER TO engine;

--
-- Name: getquotabyquotaname(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotabyquotaname(v_quota_name character varying, v_storage_pool_id uuid) RETURNS SETOF public.quota_global_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_global_view
    WHERE quota_name = v_quota_name
        AND storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getquotabyquotaname(v_quota_name character varying, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getquotabystoragepoolguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotabystoragepoolguid(v_storage_pool_id uuid) RETURNS SETOF public.quota_global_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_global_view
    WHERE (
            storage_pool_id = v_storage_pool_id
            OR v_storage_pool_id IS NULL
            );
END;$$;


ALTER FUNCTION public.getquotabystoragepoolguid(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: quota_cluster_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.quota_cluster_view AS
 SELECT q_limit.id AS quota_cluster_id,
    q_limit.quota_id,
    q_limit.cluster_id,
    cluster.name AS cluster_name,
    q_limit.virtual_cpu,
    (public.calculateclusterusage(q_limit.quota_id, q_limit.cluster_id)).virtual_cpu_usage AS virtual_cpu_usage,
    q_limit.mem_size_mb,
    (public.calculateclusterusage(q_limit.quota_id, q_limit.cluster_id)).mem_size_mb_usage AS mem_size_mb_usage
   FROM public.quota_limitation q_limit,
    public.quota q,
    public.cluster
  WHERE ((q_limit.quota_id = q.id) AND (q_limit.cluster_id IS NOT NULL) AND (q_limit.storage_id IS NULL) AND (cluster.cluster_id = q_limit.cluster_id));


ALTER TABLE public.quota_cluster_view OWNER TO engine;

--
-- Name: getquotaclusterbyclusterguid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotaclusterbyclusterguid(v_cluster_id uuid, v_id uuid, v_allow_empty boolean) RETURNS SETOF public.quota_cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM (
        SELECT COALESCE(q_vds_view.quota_cluster_id, q_g_view.quota_id) AS quota_cluster_id,
            q_g_view.quota_id AS quota_id,
            q_vds_view.cluster_id AS cluster_id,
            q_vds_view.cluster_name AS cluster_name,
            COALESCE(q_vds_view.virtual_cpu, q_g_view.virtual_cpu) AS virtual_cpu,
            COALESCE(q_vds_view.virtual_cpu_usage, q_g_view.virtual_cpu_usage) AS virtual_cpu_usage,
            COALESCE(q_vds_view.mem_size_mb, q_g_view.mem_size_mb) AS mem_size_mb,
            COALESCE(q_vds_view.mem_size_mb_usage, q_g_view.mem_size_mb_usage) AS mem_size_mb_usage
        FROM quota_global_view q_g_view
        LEFT JOIN quota_cluster_view q_vds_view
            ON q_g_view.quota_id = q_vds_view.quota_id
                AND (
                    v_cluster_id = q_vds_view.cluster_id
                    OR v_cluster_id IS NULL
                    )
        WHERE q_g_view.quota_id = v_id
        ) sub
    WHERE v_allow_empty
        OR virtual_cpu IS NOT NULL
        OR mem_size_mb IS NOT NULL;
END;$$;


ALTER FUNCTION public.getquotaclusterbyclusterguid(v_cluster_id uuid, v_id uuid, v_allow_empty boolean) OWNER TO engine;

--
-- Name: getquotaclusterbyquotaguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotaclusterbyquotaguid(v_id uuid) RETURNS SETOF public.quota_cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT quota_cluster_view.*
    FROM quota_cluster_view
    WHERE quota_id = v_id;
END;$$;


ALTER FUNCTION public.getquotaclusterbyquotaguid(v_id uuid) OWNER TO engine;

--
-- Name: getquotacount(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotacount() RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT count(*) AS num_quota
    FROM quota;
END;$$;


ALTER FUNCTION public.getquotacount() OWNER TO engine;

--
-- Name: quota_storage_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.quota_storage_view AS
 SELECT q_limit.id AS quota_storage_id,
    q_limit.quota_id,
    q_limit.storage_id,
    storage_domain_static.storage_name,
    q_limit.storage_size_gb,
    public.calculatestorageusage(q_limit.quota_id, q_limit.storage_id) AS storage_size_gb_usage
   FROM public.quota_limitation q_limit,
    public.quota q,
    public.storage_domain_static
  WHERE ((q_limit.quota_id = q.id) AND (q_limit.cluster_id IS NULL) AND (q_limit.storage_id IS NOT NULL) AND (storage_domain_static.id = q_limit.storage_id));


ALTER TABLE public.quota_storage_view OWNER TO engine;

--
-- Name: getquotastoragebyquotaguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotastoragebyquotaguid(v_id uuid) RETURNS SETOF public.quota_storage_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM quota_storage_view
    WHERE quota_id = v_id;
END;$$;


ALTER FUNCTION public.getquotastoragebyquotaguid(v_id uuid) OWNER TO engine;

--
-- Name: getquotastoragebystorageguid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getquotastoragebystorageguid(v_storage_id uuid, v_id uuid, v_allow_empty boolean) RETURNS SETOF public.quota_storage_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM (
        SELECT COALESCE(q_storage_view.quota_storage_id, q_g_view.quota_id) AS quota_storage_id,
            q_g_view.quota_id AS quota_id,
            q_storage_view.storage_id,
            q_storage_view.storage_name,
            COALESCE(q_storage_view.storage_size_gb, q_g_view.storage_size_gb) AS storage_size_gb,
            COALESCE(q_storage_view.storage_size_gb_usage, q_g_view.storage_size_gb_usage) AS storage_size_gb_usage
        FROM quota_global_view q_g_view
        LEFT JOIN quota_storage_view q_storage_view
            ON q_g_view.quota_id = q_storage_view.quota_id
                AND (
                    v_storage_id = q_storage_view.storage_id
                    OR v_storage_id IS NULL
                    )
        WHERE q_g_view.quota_id = v_id
        ) sub
    WHERE (
            v_allow_empty
            OR storage_size_gb IS NOT NULL
            );
END;$$;


ALTER FUNCTION public.getquotastoragebystorageguid(v_storage_id uuid, v_id uuid, v_allow_empty boolean) OWNER TO engine;

--
-- Name: getrepo_files_by_storage_domain(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getrepo_files_by_storage_domain(v_storage_domain_id uuid, v_file_type integer DEFAULT NULL::integer) RETURNS SETOF public.repo_file_meta_data
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT repo_file_meta_data.*
    FROM repo_file_meta_data
    WHERE repo_domain_id = v_storage_domain_id
        AND (
            v_file_type IS NULL
            OR repo_file_meta_data.file_type = v_file_type
            )
    ORDER BY repo_file_meta_data.last_refreshed;
END;$$;


ALTER FUNCTION public.getrepo_files_by_storage_domain(v_storage_domain_id uuid, v_file_type integer) OWNER TO engine;

--
-- Name: getrequirednetworksbydatacenterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getrequirednetworksbydatacenterid(v_data_center_id uuid) RETURNS SETOF public.network
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT network.*
    FROM network
    INNER JOIN network_cluster
        ON network.id = network_cluster.network_id
    WHERE network_cluster.required
        AND network.storage_pool_id = v_data_center_id;
END;$$;


ALTER FUNCTION public.getrequirednetworksbydatacenterid(v_data_center_id uuid) OWNER TO engine;

--
-- Name: getroleactiongroupsbyroleid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getroleactiongroupsbyroleid(v_id uuid) RETURNS SETOF public.roles_groups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM roles_groups
   WHERE role_id = v_id;
END; $$;


ALTER FUNCTION public.getroleactiongroupsbyroleid(v_id uuid) OWNER TO engine;

--
-- Name: getrolebyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getrolebyname(v_name character varying) RETURNS SETOF public.roles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM roles
   WHERE name = v_name;

END; $$;


ALTER FUNCTION public.getrolebyname(v_name character varying) OWNER TO engine;

--
-- Name: getrolsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getrolsbyid(v_id uuid) RETURNS SETOF public.roles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM roles
   WHERE id = v_id;

END; $$;


ALTER FUNCTION public.getrolsbyid(v_id uuid) OWNER TO engine;

--
-- Name: getrunningvmsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getrunningvmsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT DISTINCT vms.*
    FROM vms
    WHERE run_on_vds IS NOT NULL
        AND cluster_id = v_cluster_id;
END; $$;


ALTER FUNCTION public.getrunningvmsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getsessionuserandgroupsbyid(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsessionuserandgroupsbyid(v_id uuid, v_engine_session_seq_id integer) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT ad_groups.ID
    FROM ad_groups,
        engine_sessions
    WHERE engine_sessions.id = v_engine_session_seq_id
        AND ad_groups.id IN (
            SELECT *
            FROM fnsplitteruuid(engine_sessions.group_ids)
            )

    UNION

    SELECT v_id

    UNION

    -- user is also member of 'Everyone'
    SELECT 'EEE00000-0000-0000-0000-123456789EEE';
END;$$;


ALTER FUNCTION public.getsessionuserandgroupsbyid(v_id uuid, v_engine_session_seq_id integer) OWNER TO engine;

--
-- Name: getsnapshotbyguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyguid(v_image_guid uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view images_storage_domain_view
     WHERE image_guid = v_image_guid;
END; $$;


ALTER FUNCTION public.getsnapshotbyguid(v_image_guid uuid) OWNER TO engine;

--
-- Name: getsnapshotbyleafguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyleafguid(v_image_guid uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY WITH RECURSIVE image_list AS (
          SELECT *
          FROM   images_storage_domain_view
          WHERE  image_guid = v_image_guid
          UNION ALL
          SELECT images_storage_domain_view.*
          FROM   images_storage_domain_view
          JOIN   image_list ON
                 image_list.parentid = images_storage_domain_view.image_guid AND
                 image_list.image_group_id = images_storage_domain_view.image_group_id
      )
      SELECT *
      FROM image_list;
END; $$;


ALTER FUNCTION public.getsnapshotbyleafguid(v_image_guid uuid) OWNER TO engine;

--
-- Name: getsnapshotbyparentguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyparentguid(v_parent_guid uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view images_storage_domain_view
     WHERE ParentId = v_parent_guid;
END; $$;


ALTER FUNCTION public.getsnapshotbyparentguid(v_parent_guid uuid) OWNER TO engine;

--
-- Name: getsnapshotbysnapshotid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbysnapshotid(v_snapshot_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots
    WHERE snapshot_id = v_snapshot_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = (
                        SELECT vm_id
                        FROM snapshots
                        WHERE snapshot_id = v_snapshot_id
                        )
                )
            );
END;$$;


ALTER FUNCTION public.getsnapshotbysnapshotid(v_snapshot_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getsnapshotbyvmidandstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyvmidandstatus(v_vm_id uuid, v_status character varying) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND status = v_status
    ORDER BY creation_date ASC LIMIT 1;
END;$$;


ALTER FUNCTION public.getsnapshotbyvmidandstatus(v_vm_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: getsnapshotbyvmidandtype(uuid, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            )
    ORDER BY creation_date ASC LIMIT 1;
END;$$;


ALTER FUNCTION public.getsnapshotbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getsnapshotbyvmidandtypeandstatus(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotbyvmidandtypeandstatus(v_vm_id uuid, v_snapshot_type character varying, v_status character varying) RETURNS SETOF public.snapshots
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type
        AND status = v_status
    ORDER BY creation_date ASC LIMIT 1;
END;$$;


ALTER FUNCTION public.getsnapshotbyvmidandtypeandstatus(v_vm_id uuid, v_snapshot_type character varying, v_status character varying) OWNER TO engine;

--
-- Name: getsnapshotidsbyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotidsbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT snapshot_id
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type
    ORDER BY creation_date ASC;
END;$$;


ALTER FUNCTION public.getsnapshotidsbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) OWNER TO engine;

--
-- Name: getsnapshotidsbyvmidandtypeandstatus(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotidsbyvmidandtypeandstatus(v_vm_id uuid, v_snapshot_type character varying, v_status character varying) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT snapshot_id
    FROM snapshots
    WHERE vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type
        AND status = v_status
    ORDER BY creation_date ASC;
END;$$;


ALTER FUNCTION public.getsnapshotidsbyvmidandtypeandstatus(v_vm_id uuid, v_snapshot_type character varying, v_status character varying) OWNER TO engine;

--
-- Name: getsnapshotsbyimagegroupid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotsbyimagegroupid(v_image_group_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view images_storage_domain_view
     WHERE image_group_id = v_image_group_id;
END; $$;


ALTER FUNCTION public.getsnapshotsbyimagegroupid(v_image_group_id uuid) OWNER TO engine;

--
-- Name: getsnapshotsbyparentsguid(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotsbyparentsguid(v_parent_guids uuid[]) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view
     WHERE parentid = ANY(v_parent_guids);
END; $$;


ALTER FUNCTION public.getsnapshotsbyparentsguid(v_parent_guids uuid[]) OWNER TO engine;

--
-- Name: getsnapshotsbystoragedomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotsbystoragedomainid(v_storage_domain_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view
     WHERE storage_id = v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getsnapshotsbystoragedomainid(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getsnapshotsbyvmsnapshotid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsnapshotsbyvmsnapshotid(v_vm_snapshot_id uuid) RETURNS SETOF public.images_storage_domain_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM images_storage_domain_view images_storage_domain_view
     WHERE vm_snapshot_id = v_vm_snapshot_id;
END; $$;


ALTER FUNCTION public.getsnapshotsbyvmsnapshotid(v_vm_snapshot_id uuid) OWNER TO engine;

--
-- Name: getstepbystepid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepbystepid(v_step_id uuid) RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.*
    FROM step
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.getstepbystepid(v_step_id uuid) OWNER TO engine;

--
-- Name: getstepsbyexternaltaskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepsbyexternaltaskid(v_external_id uuid) RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.*
    FROM step
    WHERE external_id = v_external_id
    ORDER BY parent_step_id nulls first,
        step_number;
END;$$;


ALTER FUNCTION public.getstepsbyexternaltaskid(v_external_id uuid) OWNER TO engine;

--
-- Name: getstepsbyjobid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepsbyjobid(v_job_id uuid) RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.*
    FROM step
    WHERE job_id = v_job_id
    ORDER BY parent_step_id nulls first,
        step_number;
END;$$;


ALTER FUNCTION public.getstepsbyjobid(v_job_id uuid) OWNER TO engine;

--
-- Name: getstepsbyparentstepid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepsbyparentstepid(v_parent_step_id uuid) RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT step.*
    FROM step
    WHERE parent_step_id = v_parent_step_id
    ORDER BY step_number;
END;$$;


ALTER FUNCTION public.getstepsbyparentstepid(v_parent_step_id uuid) OWNER TO engine;

--
-- Name: getstepsforentitybystatus(character varying, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepsforentitybystatus(v_status character varying, v_entity_id uuid, v_entity_type character varying) RETURNS SETOF public.step
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT s.*
    FROM step_subject_entity sse
    INNER JOIN step s
    ON sse.step_id = s.step_id
    WHERE sse.entity_id = v_entity_id
        AND sse.entity_type = v_entity_type
        AND s.status = v_status;
END;$$;


ALTER FUNCTION public.getstepsforentitybystatus(v_status character varying, v_entity_id uuid, v_entity_type character varying) OWNER TO engine;

--
-- Name: getstepsubjectentitiesbystepid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstepsubjectentitiesbystepid(v_step_id uuid) RETURNS SETOF public.step_subject_entity
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM step_subject_entity
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.getstepsubjectentitiesbystepid(v_step_id uuid) OWNER TO engine;

--
-- Name: getstorage_domain_by_type_storagepoolid_and_status(integer, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_by_type_storagepoolid_and_status(v_storage_domain_type integer, v_storage_pool_id uuid, v_status integer) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage_pool_id = v_storage_pool_id
        AND storage_domain_type = v_storage_domain_type
        AND (
            v_status IS NULL
            OR status = v_status
            );
END;$$;


ALTER FUNCTION public.getstorage_domain_by_type_storagepoolid_and_status(v_storage_domain_type integer, v_storage_pool_id uuid, v_status integer) OWNER TO engine;

--
-- Name: getstorage_domain_dynamicbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_dynamicbyid(v_id uuid) RETURNS SETOF public.storage_domain_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_dynamic
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getstorage_domain_dynamicbyid(v_id uuid) OWNER TO engine;

--
-- Name: getstorage_domain_staticbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_staticbyid(v_id uuid) RETURNS SETOF public.storage_domain_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_static
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getstorage_domain_staticbyid(v_id uuid) OWNER TO engine;

--
-- Name: getstorage_domain_staticbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_staticbyname(v_name character varying) RETURNS SETOF public.storage_domain_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_static
    WHERE storage_name = v_name;
END;$$;


ALTER FUNCTION public.getstorage_domain_staticbyname(v_name character varying) OWNER TO engine;

--
-- Name: getstorage_domain_staticbynamefiltered(character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_staticbynamefiltered(v_name character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_domain_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domain_static sds
    WHERE storage_name = v_name
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_domain_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = sds.id
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_domain_staticbynamefiltered(v_name character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getstorage_domain_staticbystorage_pool_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domain_staticbystorage_pool_id(v_storage_pool_id uuid) RETURNS SETOF public.storage_domain_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_domain_static.*
    FROM storage_domain_static
    INNER JOIN storage_pool_iso_map
        ON storage_pool_iso_map.storage_id = storage_domain_static.id
    WHERE storage_pool_iso_map.storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getstorage_domain_staticbystorage_pool_id(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getstorage_domains_by_connection(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_connection(v_connection character varying) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage IN (
            SELECT id
            FROM storage_server_connections
            WHERE connection = v_connection
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_by_connection(v_connection character varying) OWNER TO engine;

--
-- Name: storage_domains_without_storage_pools; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domains_without_storage_pools AS
 SELECT DISTINCT storage_domain_static.id,
    storage_domain_static.storage,
    storage_domain_static.storage_name,
    storage_domain_static.storage_description,
    storage_domain_static.storage_comment,
    storage_domain_static.storage_type,
    storage_domain_static.storage_domain_type,
    storage_domain_static.storage_domain_format_type,
    storage_domain_static.last_time_used_as_master,
    storage_domain_static.wipe_after_delete,
    storage_domain_static.discard_after_delete,
    storage_domain_static.first_metadata_device,
    storage_domain_static.vg_metadata_device,
    storage_domain_static.backup,
    storage_domain_static.block_size,
    NULL::text AS storage_pool_id,
    NULL::text AS storage_pool_name,
    storage_domain_dynamic.available_disk_size,
    storage_domain_dynamic.confirmed_available_disk_size,
    storage_domain_dynamic.vdo_savings,
    storage_domain_dynamic.used_disk_size,
    storage_domains_image_sizes.commited_disk_size,
    storage_domains_image_sizes.actual_images_size,
    NULL::text AS status,
    COALESCE(storage_domain_shared_status.status, 0) AS storage_domain_shared_status,
    storage_domain_static.recoverable,
    (domains_with_unregistered_entities_view.storage_domain_id IS NOT NULL) AS contains_unregistered_entities,
    storage_domain_static.warning_low_space_indicator,
    storage_domain_static.critical_space_action_blocker,
    storage_domain_static.warning_low_confirmed_space_indicator,
    storage_domain_dynamic.external_status,
    vg_discard_support_view.supports_discard,
    (EXISTS ( SELECT 1
           FROM public.hosted_engine_storage_domains_ids_view
          WHERE (hosted_engine_storage_domains_ids_view.id = storage_domain_static.id))) AS is_hosted_engine_storage
   FROM ((((((public.storage_domain_static
     JOIN public.storage_domain_dynamic ON ((storage_domain_static.id = storage_domain_dynamic.id)))
     LEFT JOIN public.storage_pool_iso_map ON ((storage_domain_static.id = storage_pool_iso_map.storage_id)))
     LEFT JOIN public.storage_domain_shared_status ON ((storage_domain_shared_status.storage_id = storage_domain_static.id)))
     LEFT JOIN public.domains_with_unregistered_entities_view ON ((domains_with_unregistered_entities_view.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.storage_domains_image_sizes ON ((storage_domains_image_sizes.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.vg_discard_support_view ON (((storage_domain_static.storage)::text = (vg_discard_support_view.volume_group_id)::text)));


ALTER TABLE public.storage_domains_without_storage_pools OWNER TO engine;

--
-- Name: getstorage_domains_by_id(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_id(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_domains_without_storage_pools
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains_without_storage_pools
    WHERE id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_domain_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_id
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_by_id(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getstorage_domains_by_id_and_by_storage_pool_id(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_id_and_by_storage_pool_id(v_id uuid, v_storage_pool_id uuid) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE id = v_id
        AND storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getstorage_domains_by_id_and_by_storage_pool_id(v_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getstorage_domains_by_storage_pool_id_and_connection(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_storage_pool_id_and_connection(v_storage_pool_id uuid, v_connection character varying) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage_pool_id = v_storage_pool_id
        AND storage IN (
            SELECT id
            FROM storage_server_connections
            WHERE connection = v_connection
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_by_storage_pool_id_and_connection(v_storage_pool_id uuid, v_connection character varying) OWNER TO engine;

--
-- Name: getstorage_domains_by_storage_pool_id_with_permitted_action(uuid, integer, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_storage_pool_id_with_permitted_action(v_user_id uuid, v_action_group_id integer, v_storage_pool_id uuid) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage_pool_id = v_storage_pool_id
        AND (
            SELECT get_entity_permissions(v_user_id, v_action_group_id, id, 11)
            ) IS NOT NULL;
END;$$;


ALTER FUNCTION public.getstorage_domains_by_storage_pool_id_with_permitted_action(v_user_id uuid, v_action_group_id integer, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getstorage_domains_by_storagepoolid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_by_storagepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage_pool_id = v_storage_pool_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_domain_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = id
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_by_storagepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getstorage_domains_list_by_imageid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_list_by_imageid(v_image_id uuid) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE id IN (
            SELECT storage_domain_id
            FROM image_storage_domain_map
            WHERE image_id = v_image_id
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_list_by_imageid(v_image_id uuid) OWNER TO engine;

--
-- Name: getstorage_domains_list_by_storagedomainid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_domains_list_by_storagedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage_domains.id = v_storage_domain_id
    AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_pool_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_storage_domain_id
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_domains_list_by_storagedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getstorage_pool_iso_mapbystorage_idandbystorage_pool_id(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_pool_iso_mapbystorage_idandbystorage_pool_id(v_storage_id uuid, v_storage_pool_id uuid) RETURNS SETOF public.storage_pool_iso_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool_iso_map
    WHERE storage_id = v_storage_id
        AND storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getstorage_pool_iso_mapbystorage_idandbystorage_pool_id(v_storage_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getstorage_pool_iso_mapsbybystorage_pool_id(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_pool_iso_mapsbybystorage_pool_id(v_storage_id uuid, v_storage_pool_id uuid) RETURNS SETOF public.storage_pool_iso_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_pool_iso_map.*
    FROM storage_pool_iso_map
    INNER JOIN storage_domain_static
        ON storage_pool_iso_map.storage_id = storage_domain_static.id
    WHERE storage_pool_id = v_storage_pool_id
        AND storage_domain_static.storage_type != 9
        AND storage_domain_static.storage_type != 10; -- filter Cinder and Managed block storage domains
END;$$;


ALTER FUNCTION public.getstorage_pool_iso_mapsbybystorage_pool_id(v_storage_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getstorage_pool_iso_mapsbystorage_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_pool_iso_mapsbystorage_id(v_storage_id uuid) RETURNS SETOF public.storage_pool_iso_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool_iso_map
    WHERE storage_id = v_storage_id;
END;$$;


ALTER FUNCTION public.getstorage_pool_iso_mapsbystorage_id(v_storage_id uuid) OWNER TO engine;

--
-- Name: getstorage_poolbyid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_poolbyid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_storage_pool_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_id
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_poolbyid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getstorage_poolbyname(character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_poolbyname(v_name character varying, v_is_case_sensitive boolean) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE name = v_name
        OR (
            NOT v_is_case_sensitive
            AND name ilike v_name
            );
END;$$;


ALTER FUNCTION public.getstorage_poolbyname(v_name character varying, v_is_case_sensitive boolean) OWNER TO engine;

--
-- Name: getstorage_poolsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_poolsbyclusterid(v_clusterid uuid) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE storage_pool.id IN (
            SELECT storage_pool_id
            FROM cluster
            WHERE cluster_id = v_clusterId
            );
END;$$;


ALTER FUNCTION public.getstorage_poolsbyclusterid(v_clusterid uuid) OWNER TO engine;

--
-- Name: getstorage_poolsbystoragedomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_poolsbystoragedomainid(v_storage_domain_id uuid) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_pool.*
    FROM storage_pool
    INNER JOIN storage_pool_iso_map
        ON storage_pool.id = storage_pool_iso_map.storage_pool_id
    WHERE storage_pool_iso_map.storage_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.getstorage_poolsbystoragedomainid(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getstorage_poolsbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_poolsbyvdsid(v_vdsid uuid) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_clusterId UUID;

BEGIN
    SELECT cluster_id
    INTO v_clusterId
    FROM Vds_static
    WHERE vds_id = v_vdsId;

    RETURN QUERY

    SELECT *
    FROM storage_pool
    WHERE storage_pool.id IN (
            SELECT storage_pool_id
            FROM cluster
            WHERE cluster_id = v_clusterId
            );
END;$$;


ALTER FUNCTION public.getstorage_poolsbyvdsid(v_vdsid uuid) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbyconnection(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbyconnection(v_connection character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE connection = v_connection;
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbyconnection(v_connection character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbyid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbyid(v_id character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbyid(v_id character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbyiqn(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbyiqn(v_iqn character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE iqn = v_iqn
        OR iqn IS NULL
        AND v_iqn IS NULL;
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbyiqn(v_iqn character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbyiqnandconnection(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbyiqnandconnection(v_iqn character varying, v_connection character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE iqn = v_iqn
        AND (
            connection = v_connection
            OR connection IS NULL
            );
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbyiqnandconnection(v_iqn character varying, v_connection character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbykey(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbykey(v_iqn character varying, v_connection character varying, v_port character varying, v_portal character varying, v_username character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE (
            iqn = v_iqn
            OR (
                iqn IS NULL
                AND v_iqn IS NULL
                )
            )
        AND (connection = v_connection)
        AND (
            port = v_port
            OR (
                port IS NULL
                AND v_port IS NULL
                )
            )
        AND (
            portal = v_portal
            OR (
                portal IS NULL
                AND v_portal IS NULL
                )
            )
        AND (
            user_name = v_username
            OR (
                user_name IS NULL
                AND v_username IS NULL
                )
            );
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbykey(v_iqn character varying, v_connection character varying, v_port character varying, v_portal character varying, v_username character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbylunid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbylunid(v_lunid character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_server_connections.*
    FROM storage_server_connections storage_server_connections
    INNER JOIN lun_storage_server_connection_map
        ON lun_storage_server_connection_map.storage_server_connection = storage_server_connections.id
    WHERE (lun_storage_server_connection_map.lun_id = v_lunId);
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbylunid(v_lunid character varying) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbystoragetype(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbystoragetype(v_storage_type integer) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE storage_type = v_storage_type;
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbystoragetype(v_storage_type integer) OWNER TO engine;

--
-- Name: getstorage_server_connectionsbyvolumegroupid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorage_server_connectionsbyvolumegroupid(v_volume_group_id character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT storage_server_connections.*
    FROM LUN_storage_server_connection_map LUN_storage_server_connection_map
    INNER JOIN LUNs
        ON LUN_storage_server_connection_map.LUN_id = LUNs.LUN_id
    INNER JOIN storage_domain_static
        ON LUNs.volume_group_id = storage_domain_static.storage
    INNER JOIN storage_server_connections
        ON LUN_storage_server_connection_map.storage_server_connection = storage_server_connections.id
    WHERE (storage_domain_static.storage = v_volume_group_id);
END;$$;


ALTER FUNCTION public.getstorage_server_connectionsbyvolumegroupid(v_volume_group_id character varying) OWNER TO engine;

--
-- Name: getstorageconnectionsbyconnectionportandiqn(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageconnectionsbyconnectionportandiqn(v_iqn character varying, v_connection character varying, v_port character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE iqn = v_iqn
        AND connection = v_connection
        AND port = v_port;
END;$$;


ALTER FUNCTION public.getstorageconnectionsbyconnectionportandiqn(v_iqn character varying, v_connection character varying, v_port character varying) OWNER TO engine;

--
-- Name: getstorageconnectionsbystoragetypeandstatus(uuid, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageconnectionsbystoragetypeandstatus(v_storage_pool_id uuid, v_storage_type integer, v_statuses character varying) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE statuses INT [];

BEGIN
    statuses := string_to_array(v_statuses, ',')::INT [];

    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE (
            v_storage_type IS NULL
            OR storage_server_connections.storage_type = v_storage_type
            )
        AND (
            id IN (
                SELECT storage
                FROM storage_domains
                WHERE storage_domains.storage_pool_id = v_storage_pool_id
                    AND storage_domains.status = ANY (statuses)
                )
            OR (
                id IN (
                    SELECT lun_storage_server_connection_map.storage_server_connection
                    FROM lun_storage_server_connection_map
                    INNER JOIN luns
                        ON lun_storage_server_connection_map.lun_id = luns.lun_id
                    INNER JOIN storage_domains
                        ON luns.volume_group_id = storage_domains.storage
                    WHERE (
                            storage_domains.storage_pool_id = v_storage_pool_id
                            AND storage_domains.status = ANY (statuses)
                            )
                    )
                )
            );
END;$$;


ALTER FUNCTION public.getstorageconnectionsbystoragetypeandstatus(v_storage_pool_id uuid, v_storage_type integer, v_statuses character varying) OWNER TO engine;

--
-- Name: storage_device; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_device (
    id uuid NOT NULL,
    name text NOT NULL,
    device_uuid character varying(38),
    filesystem_uuid character varying(38),
    vds_id uuid NOT NULL,
    description text,
    device_type character varying(50),
    device_path text,
    filesystem_type character varying(50),
    mount_point text,
    size bigint,
    is_free boolean,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    _update_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    is_gluster_brick boolean DEFAULT false
);


ALTER TABLE public.storage_device OWNER TO engine;

--
-- Name: getstoragedevicebyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedevicebyid(v_id uuid) RETURNS SETOF public.storage_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_device
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getstoragedevicebyid(v_id uuid) OWNER TO engine;

--
-- Name: getstoragedevicesbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedevicesbyvdsid(v_vds_id uuid) RETURNS SETOF public.storage_device
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_device
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.getstoragedevicesbyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getstoragedomainbyglustervolumeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedomainbyglustervolumeid(v_gluster_vol_id uuid) RETURNS SETOF public.storage_domains
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains
    WHERE storage IN (
            SELECT id
            FROM storage_server_connections
            WHERE gluster_volume_id = v_gluster_vol_id
            );
END;$$;


ALTER FUNCTION public.getstoragedomainbyglustervolumeid(v_gluster_vol_id uuid) OWNER TO engine;

--
-- Name: storage_domain_dr; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_domain_dr (
    storage_domain_id uuid NOT NULL,
    georep_session_id uuid NOT NULL,
    sync_schedule character varying(256),
    gluster_scheduler_job_id uuid
);


ALTER TABLE public.storage_domain_dr OWNER TO engine;

--
-- Name: getstoragedomaindr(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid) RETURNS SETOF public.storage_domain_dr
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM storage_domain_dr
    WHERE storage_domain_id = v_storage_domain_id
    AND georep_session_id = v_georep_session_id;
END;$$;


ALTER FUNCTION public.getstoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid) OWNER TO engine;

--
-- Name: getstoragedomaindrlist(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedomaindrlist(v_storage_domain_id uuid) RETURNS SETOF public.storage_domain_dr
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM storage_domain_dr
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.getstoragedomaindrlist(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getstoragedomaindrwithgeorep(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedomaindrwithgeorep(v_georep_session_id uuid) RETURNS SETOF public.storage_domain_dr
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM storage_domain_dr
    WHERE georep_session_id = v_georep_session_id;
END;$$;


ALTER FUNCTION public.getstoragedomaindrwithgeorep(v_georep_session_id uuid) OWNER TO engine;

--
-- Name: getstoragedomainidsbystoragepoolidandstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragedomainidsbystoragepoolidandstatus(v_storage_pool_id uuid, v_status integer) RETURNS SETOF public.getstoragedomainidsbystoragepoolidandstatus_rs
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT storage_id
    FROM storage_pool_iso_map
    INNER JOIN storage_domain_static
        ON storage_pool_iso_map.storage_id = storage_domain_static.id
    WHERE storage_pool_id = v_storage_pool_id
        AND status = v_status
        AND storage_domain_static.storage_type != 9
        AND storage_domain_static.storage_type != 10; -- filter Cinder and Managed block storage domains
END;$$;


ALTER FUNCTION public.getstoragedomainidsbystoragepoolidandstatus(v_storage_pool_id uuid, v_status integer) OWNER TO engine;

--
-- Name: getstoragepoolsbyclusterservice(boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstoragepoolsbyclusterservice(v_supports_virt_service boolean, v_supports_gluster_service boolean) RETURNS SETOF public.storage_pool
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT sp.*
    FROM storage_pool SP
    WHERE EXISTS (
            SELECT 1
            FROM cluster vg
            WHERE (
                    (
                        v_supports_virt_service = TRUE
                        AND vg.virt_service = TRUE
                        )
                    OR (
                        v_supports_gluster_service = TRUE
                        AND vg.gluster_service = TRUE
                        )
                    )
                AND vg.storage_pool_id = sp.id
            );
END;$$;


ALTER FUNCTION public.getstoragepoolsbyclusterservice(v_supports_virt_service boolean, v_supports_gluster_service boolean) OWNER TO engine;

--
-- Name: getstorageserverconnectionextensionbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageserverconnectionextensionbyid(v_id uuid) RETURNS SETOF public.storage_server_connection_extension
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connection_extension
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getstorageserverconnectionextensionbyid(v_id uuid) OWNER TO engine;

--
-- Name: getstorageserverconnectionextensionsbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageserverconnectionextensionsbyhostid(v_vds_id uuid) RETURNS SETOF public.storage_server_connection_extension
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connection_extension
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.getstorageserverconnectionextensionsbyhostid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getstorageserverconnectionextensionsbyhostidandtarget(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageserverconnectionextensionsbyhostidandtarget(v_vds_id uuid, v_iqn character varying) RETURNS SETOF public.storage_server_connection_extension
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connection_extension
    WHERE vds_id = v_vds_id
        AND iqn = v_iqn;
END;$$;


ALTER FUNCTION public.getstorageserverconnectionextensionsbyhostidandtarget(v_vds_id uuid, v_iqn character varying) OWNER TO engine;

--
-- Name: getstorageserverconnectionsbyids(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageserverconnectionsbyids(v_ids text) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE id = ANY (string_to_array(v_ids, ',')::VARCHAR []);
END;$$;


ALTER FUNCTION public.getstorageserverconnectionsbyids(v_ids text) OWNER TO engine;

--
-- Name: getstorageserverconnectionsfordomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getstorageserverconnectionsfordomain(v_storage_domain_id uuid) RETURNS SETOF public.storage_server_connections
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_server_connections
    WHERE EXISTS (
            SELECT 1
            FROM storage_domain_static
            WHERE storage_domain_static.id = v_storage_domain_id
                AND storage_domain_static.storage_type IN (
                    1,
                    4,
                    6,
                    7
                    ) -- file storage domains - nfs,posix,local,gluster
                AND storage_server_connections.id = storage_domain_static.storage

            UNION ALL

            SELECT 1
            FROM storage_domain_static
            INNER JOIN luns
                ON storage_domain_static.storage = luns.volume_group_id
            INNER JOIN lun_storage_server_connection_map
                ON luns.lun_id = lun_storage_server_connection_map.lun_id
                    AND storage_server_connections.id = lun_storage_server_connection_map.storage_server_connection
            WHERE storage_domain_static.id = v_storage_domain_id
                AND storage_domain_static.storage_type = 3 -- storage type = iscsi
            );
END;$$;


ALTER FUNCTION public.getstorageserverconnectionsfordomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getsupportedclusterfeature(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid) RETURNS SETOF public.supported_cluster_features_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM supported_cluster_features_view
    WHERE feature_id = v_feature_id
        AND cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getsupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid) OWNER TO engine;

--
-- Name: getsupportedclusterfeaturesbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsupportedclusterfeaturesbyclusterid(v_cluster_id uuid) RETURNS SETOF public.supported_cluster_features_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM supported_cluster_features_view
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.getsupportedclusterfeaturesbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: supported_host_features; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.supported_host_features (
    host_id uuid NOT NULL,
    feature_name character varying(256) NOT NULL
);


ALTER TABLE public.supported_host_features OWNER TO engine;

--
-- Name: getsupportedhostfeaturesbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsupportedhostfeaturesbyhostid(v_host_id uuid) RETURNS SETOF public.supported_host_features
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM supported_host_features
    WHERE host_id = v_host_id;
END;$$;


ALTER FUNCTION public.getsupportedhostfeaturesbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: getsystem_statistics(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getsystem_statistics(v_entity character varying, v_status character varying) RETURNS public.getsystem_statistics_rs
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_i Getsystem_statistics_rs;

v_sql VARCHAR(4000);

v_sys_entity VARCHAR(10);

BEGIN
    v_sql := NULL;

    v_sys_entity := upper(v_entity);

    IF v_sys_entity = 'VM' THEN
        v_sql := 'SELECT count(vm_guid) FROM vm_dynamic';
    ELSIF v_sys_entity = 'HOST' THEN
        v_sql := 'SELECT count(vds_id) FROM vds_dynamic';

    ELSIF v_sys_entity = 'USER' THEN
        v_sql := 'SELECT count(user_id) FROM users';

    ELSIF v_sys_entity = 'TSD' THEN
        v_sql := 'SELECT count(id) FROM storage_domain_static';

    ELSIF v_sys_entity = 'ASD' THEN
        v_sql := 'SELECT count(storage_id) FROM storage_pool_iso_map';
    ELSE
        RAISE 'Unknown entity type "%"', v_entity;
    END IF;

    IF v_status != '' THEN
        IF v_sys_entity != 'USER'
            AND v_sys_entity != 'TSD' THEN
            v_sql := coalesce(v_sql, '') || ' where status in (' || coalesce(v_status, '') || ')';
        END IF;
    END IF;
    EXECUTE v_sql
    INTO v_i;

RETURN v_i;END;$$;


ALTER FUNCTION public.getsystem_statistics(v_entity character varying, v_status character varying) OWNER TO engine;

--
-- Name: gettags_vm_pool_mapbytag_idandbyvm_pool_id(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettags_vm_pool_mapbytag_idandbyvm_pool_id(v_tag_id uuid, v_vm_pool_id uuid) RETURNS SETOF public.tags_vm_pool_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vm_pool_map.*
    FROM tags_vm_pool_map
    WHERE tag_id = v_tag_id
        AND vm_pool_id = v_vm_pool_id;
END;$$;


ALTER FUNCTION public.gettags_vm_pool_mapbytag_idandbyvm_pool_id(v_tag_id uuid, v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: gettagsbyparent_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyparent_id(v_parent_id uuid) RETURNS SETOF public.tags
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags.*
    FROM tags
    WHERE parent_id = v_parent_id;
END;$$;


ALTER FUNCTION public.gettagsbyparent_id(v_parent_id uuid) OWNER TO engine;

--
-- Name: gettagsbytag_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbytag_id(v_tag_id uuid) RETURNS SETOF public.tags
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags.*
    FROM tags
    WHERE tag_id = v_tag_id;
END;$$;


ALTER FUNCTION public.gettagsbytag_id(v_tag_id uuid) OWNER TO engine;

--
-- Name: gettagsbytag_name(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbytag_name(v_tag_name character varying) RETURNS SETOF public.tags
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags.*
    FROM tags
    WHERE tag_name = v_tag_name;
END;$$;


ALTER FUNCTION public.gettagsbytag_name(v_tag_name character varying) OWNER TO engine;

--
-- Name: tags_user_group_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.tags_user_group_map_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.parent_id,
    tags.readonly,
    tags.type,
    tags_user_group_map.group_id
   FROM (public.tags_user_group_map
     JOIN public.tags ON ((tags_user_group_map.tag_id = tags.tag_id)));


ALTER TABLE public.tags_user_group_map_view OWNER TO engine;

--
-- Name: gettagsbyusergroupid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyusergroupid(v_group_ids character varying) RETURNS SETOF public.tags_user_group_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_user_group_map_view.*
    FROM tags_user_group_map_view
    WHERE group_id IN (
            SELECT *
            FROM fnSplitterUuid(v_group_ids)
            );
END;$$;


ALTER FUNCTION public.gettagsbyusergroupid(v_group_ids character varying) OWNER TO engine;

--
-- Name: tags_user_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.tags_user_map_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.parent_id,
    tags.readonly,
    tags.type,
    tags_user_map.user_id
   FROM (public.tags
     JOIN public.tags_user_map ON ((tags.tag_id = tags_user_map.tag_id)));


ALTER TABLE public.tags_user_map_view OWNER TO engine;

--
-- Name: gettagsbyuserid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyuserid(v_user_ids character varying) RETURNS SETOF public.tags_user_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_user_map_view.*
    FROM tags_user_map_view
    WHERE user_id IN (
            SELECT *
            FROM fnSplitterUuid(v_user_ids)
            );
END;$$;


ALTER FUNCTION public.gettagsbyuserid(v_user_ids character varying) OWNER TO engine;

--
-- Name: tags_vds_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.tags_vds_map_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.parent_id,
    tags.readonly,
    tags.type,
    tags_vds_map.vds_id
   FROM (public.tags
     JOIN public.tags_vds_map ON ((tags.tag_id = tags_vds_map.tag_id)));


ALTER TABLE public.tags_vds_map_view OWNER TO engine;

--
-- Name: gettagsbyvdsid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyvdsid(v_vds_ids character varying) RETURNS SETOF public.tags_vds_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_vds_map_view.*
    FROM tags_vds_map_view
    WHERE vds_id IN (
            SELECT *
            FROM fnSplitterUuid(v_vds_ids)
            );
END;$$;


ALTER FUNCTION public.gettagsbyvdsid(v_vds_ids character varying) OWNER TO engine;

--
-- Name: tags_vm_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.tags_vm_map_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.parent_id,
    tags.readonly,
    tags.type,
    tags_vm_map.vm_id
   FROM (public.tags
     JOIN public.tags_vm_map ON ((tags.tag_id = tags_vm_map.tag_id)));


ALTER TABLE public.tags_vm_map_view OWNER TO engine;

--
-- Name: gettagsbyvmid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyvmid(v_vm_ids character varying) RETURNS SETOF public.tags_vm_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_vm_map_view.*
    FROM tags_vm_map_view
    WHERE vm_id IN (
            SELECT *
            FROM fnSplitterUuid(v_vm_ids)
            );
END;$$;


ALTER FUNCTION public.gettagsbyvmid(v_vm_ids character varying) OWNER TO engine;

--
-- Name: tags_vm_pool_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.tags_vm_pool_map_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.parent_id,
    tags.readonly,
    tags.type,
    tags_vm_pool_map.vm_pool_id
   FROM (public.tags
     JOIN public.tags_vm_pool_map ON ((tags.tag_id = tags_vm_pool_map.tag_id)));


ALTER TABLE public.tags_vm_pool_map_view OWNER TO engine;

--
-- Name: gettagsbyvmpoolid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagsbyvmpoolid(v_vm_pool_ids character varying) RETURNS SETOF public.tags_vm_pool_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_vm_pool_map_view.*
    FROM tags_vm_pool_map_view
    WHERE vm_pool_id IN (
            SELECT *
            FROM fnSplitterUuid(v_vm_pool_ids)
            );
END;$$;


ALTER FUNCTION public.gettagsbyvmpoolid(v_vm_pool_ids character varying) OWNER TO engine;

--
-- Name: gettaguserbytagidandbyuserid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettaguserbytagidandbyuserid(v_tag_id uuid, v_user_id uuid) RETURNS SETOF public.tags_user_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_user_map.*
    FROM tags_user_map
    WHERE tag_id = v_tag_id
        AND user_id = v_user_id;
END;$$;


ALTER FUNCTION public.gettaguserbytagidandbyuserid(v_tag_id uuid, v_user_id uuid) OWNER TO engine;

--
-- Name: gettagusergroupbygroupidandbytagid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagusergroupbygroupidandbytagid(v_group_id uuid, v_tag_id uuid) RETURNS SETOF public.tags_user_group_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_user_group_map.*
    FROM tags_user_group_map
    WHERE group_id = v_group_id
        AND tag_id = v_tag_id;
END;$$;


ALTER FUNCTION public.gettagusergroupbygroupidandbytagid(v_group_id uuid, v_tag_id uuid) OWNER TO engine;

--
-- Name: gettagvdsbytagidandbyvdsid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagvdsbytagidandbyvdsid(v_tag_id uuid, v_vds_id uuid) RETURNS SETOF public.tags_vds_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vds_map.*
    FROM tags_vds_map
    WHERE tag_id = v_tag_id
        AND vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.gettagvdsbytagidandbyvdsid(v_tag_id uuid, v_vds_id uuid) OWNER TO engine;

--
-- Name: gettagvmbytagidandbyvmid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettagvmbytagidandbyvmid(v_tag_id uuid, v_vm_id uuid) RETURNS SETOF public.tags_vm_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT tags_vm_map.*
    FROM tags_vm_map
    WHERE tag_id = v_tag_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.gettagvmbytagidandbyvmid(v_tag_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: gettemplatecount(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettemplatecount() RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT count (vm_templates.*)
      FROM vm_templates_based_view vm_templates;
END; $$;


ALTER FUNCTION public.gettemplatecount() OWNER TO engine;

--
-- Name: gettemplateswithleaseonstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettemplateswithleaseonstoragedomain(v_storage_domain_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM vm_templates_based_view
    WHERE lease_sd_id = v_storage_domain_id
        AND entity_type = 'TEMPLATE';
END; $$;


ALTER FUNCTION public.gettemplateswithleaseonstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: gettemplateversionsforbasetemplate(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettemplateversionsforbasetemplate(v_base_template_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY
   SELECT *
   FROM vm_templates_based_view
   WHERE base_template_id = v_base_template_id
       AND vmt_guid != v_base_template_id
   ORDER BY template_version_number desc;
END; $$;


ALTER FUNCTION public.gettemplateversionsforbasetemplate(v_base_template_id uuid) OWNER TO engine;

--
-- Name: gettemplatewithlatestversioninchain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettemplatewithlatestversioninchain(v_template_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY
   SELECT *
   FROM vm_templates_based_view
   WHERE base_template_id =
      (SELECT vmt_guid
       FROM vm_static
       WHERE vm_guid = v_template_id)
   ORDER BY template_version_number DESC
   LIMIT 1;
END; $$;


ALTER FUNCTION public.gettemplatewithlatestversioninchain(v_template_id uuid) OWNER TO engine;

--
-- Name: gettpmdata(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettpmdata(v_vm_id uuid) RETURNS SETOF public.vmexternaldata_rs
    LANGUAGE sql STABLE
    AS $$
    SELECT tpm_data, tpm_hash
    FROM vm_external_data
    WHERE vm_id = v_vm_id
$$;


ALTER FUNCTION public.gettpmdata(v_vm_id uuid) OWNER TO engine;

--
-- Name: gluster_volume_transport_types; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.gluster_volume_transport_types (
    volume_id uuid NOT NULL,
    transport_type character varying(32) NOT NULL
);


ALTER TABLE public.gluster_volume_transport_types OWNER TO engine;

--
-- Name: gettransporttypesbyglustervolumeguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettransporttypesbyglustervolumeguid(v_volume_id uuid) RETURNS SETOF public.gluster_volume_transport_types
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM gluster_volume_transport_types
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.gettransporttypesbyglustervolumeguid(v_volume_id uuid) OWNER TO engine;

--
-- Name: gettrustedclusters(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.gettrustedclusters() RETURNS SETOF public.cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT cluster_view.*
    FROM cluster_view
    WHERE trusted_service;
END;$$;


ALTER FUNCTION public.gettrustedclusters() OWNER TO engine;

--
-- Name: getunmonitoredbackups(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getunmonitoredbackups() RETURNS SETOF public.vm_backups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_backups
    WHERE phase != 'Succeeded' AND phase != 'Failed'
    AND NOT EXISTS(
        SELECT command_id
        FROM command_entities
        WHERE command_id = backup_id
    );
END;$$;


ALTER FUNCTION public.getunmonitoredbackups() OWNER TO engine;

--
-- Name: getupandprioritizedvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getupandprioritizedvds(v_storage_pool_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds.*
        FROM vds vds,
            cluster cluster
        WHERE (vds.status = 3)
            AND (vds.storage_pool_id = v_storage_pool_id)
            AND (
                vds_spm_priority IS NULL
                OR vds_spm_priority > - 1
                )
            AND vds.cluster_id = cluster.cluster_id
            AND cluster.virt_service = true
        ORDER BY vds_spm_priority DESC, RANDOM();
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getupandprioritizedvds(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getusedscsidevicesbyhostid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getusedscsidevicesbyhostid(v_host_id uuid) RETURNS SETOF public.host_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT hdv1.* FROM host_device_view hdv
        INNER JOIN luns
            ON hdv.device_name LIKE '%'||luns.lun_id
        INNER JOIN host_device_view hdv1
            ON hdv1.device_name = hdv.parent_device_name
        WHERE hdv1.host_id = v_host_id;
END;$$;


ALTER FUNCTION public.getusedscsidevicesbyhostid(v_host_id uuid) OWNER TO engine;

--
-- Name: getuserandgroupsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserandgroupsbyid(v_id uuid) RETURNS SETOF public.iduuidtype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT ad_groups.ID
    FROM ad_groups,
         engine_sessions
    WHERE engine_sessions.user_id = v_id
        AND ad_groups.id IN (
            SELECT *
            FROM fnsplitteruuid(engine_sessions.group_ids)
        )

    UNION
    SELECT v_id

    UNION
    -- user is also member of 'Everyone'
    SELECT 'EEE00000-0000-0000-0000-123456789EEE';
END;$$;


ALTER FUNCTION public.getuserandgroupsbyid(v_id uuid) OWNER TO engine;

--
-- Name: getuserbyexternalid(character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserbyexternalid(v_domain character varying, v_external_id text) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT users.*
        FROM users
        WHERE domain = v_domain
            AND external_id = v_external_id;
    END;$$;


ALTER FUNCTION public.getuserbyexternalid(v_domain character varying, v_external_id text) OWNER TO engine;

--
-- Name: getuserbyuserid(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserbyuserid(v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT users.*
        FROM users
        WHERE user_id = v_user_id
            AND (
                NOT v_is_filtered
                OR EXISTS (
                    SELECT 1
                    FROM users u,
                        user_db_users_permissions_view p
                    WHERE u.user_id = v_user_id
                        AND u.user_id = p.ad_element_id
                    )
                );
    END;$$;


ALTER FUNCTION public.getuserbyuserid(v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getuserbyusernameanddomain(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserbyusernameanddomain(v_username character varying, v_domain character varying) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT users.*
        FROM users
        WHERE username = v_username
            AND domain = v_domain;
    END;$$;


ALTER FUNCTION public.getuserbyusernameanddomain(v_username character varying, v_domain character varying) OWNER TO engine;

--
-- Name: getuserpermissionsbyentityid(uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) RETURNS SETOF public.permissions_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT *
    FROM permissions_view p
    WHERE object_id = v_id
    AND (NOT v_is_filtered OR EXISTS (
        SELECT 1
        FROM  engine_session_user_flat_groups u
        WHERE  p.ad_element_id = u.granted_id
            AND u.engine_session_seq_id = v_engine_session_seq_id));
END; $$;


ALTER FUNCTION public.getuserpermissionsbyentityid(v_id uuid, v_engine_session_seq_id integer, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getuserprofilebyuserid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserprofilebyuserid(v_user_id uuid) RETURNS SETOF public.user_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM user_profiles
    WHERE user_id = v_user_id;
END;$$;


ALTER FUNCTION public.getuserprofilebyuserid(v_user_id uuid) OWNER TO engine;

--
-- Name: getuserprofileproperty(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserprofileproperty(v_property_id uuid) RETURNS SETOF public.user_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM user_profiles
    WHERE property_id = v_property_id;
END;$$;


ALTER FUNCTION public.getuserprofileproperty(v_property_id uuid) OWNER TO engine;

--
-- Name: getuserprofilepropertybyname(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getuserprofilepropertybyname(v_user_id uuid, v_property_name text) RETURNS SETOF public.user_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM user_profiles
    WHERE user_id = v_user_id AND property_name = v_property_name;
END;$$;


ALTER FUNCTION public.getuserprofilepropertybyname(v_user_id uuid, v_property_name text) OWNER TO engine;

--
-- Name: getusersbytemplateguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getusersbytemplateguid(v_template_guid uuid) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

BEGIN
    RETURN QUERY

    SELECT users.*
    FROM users
        INNER JOIN permissions
            ON users.user_id = permissions.ad_element_id
    WHERE permissions.object_type_id = 4
        AND permissions.object_id = v_template_guid;
END;$$;


ALTER FUNCTION public.getusersbytemplateguid(v_template_guid uuid) OWNER TO engine;

--
-- Name: getusersbyvmguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getusersbyvmguid(v_vm_guid uuid) RETURNS SETOF public.users
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
        RETURN QUERY

        SELECT users.*
        FROM users
        INNER JOIN permissions
            ON users.user_id = permissions.ad_element_id
        WHERE permissions.object_type_id = 2
            AND permissions.object_id = v_vm_guid;
    END;$$;


ALTER FUNCTION public.getusersbyvmguid(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getusertagsbytagids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getusertagsbytagids(v_tag_ids character varying) RETURNS SETOF public.tags_user_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_user_map_view.*
    FROM tags_user_map_view
    WHERE tag_id IN (
            SELECT *
            FROM fnSplitterUuid(v_tag_ids)
            );
END;$$;


ALTER FUNCTION public.getusertagsbytagids(v_tag_ids character varying) OWNER TO engine;

--
-- Name: getvdcoptionbyid(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdcoptionbyid(v_option_id integer) RETURNS SETOF public.vdc_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vdc_options.*
    FROM vdc_options
    WHERE option_id = v_option_id;
END;$$;


ALTER FUNCTION public.getvdcoptionbyid(v_option_id integer) OWNER TO engine;

--
-- Name: getvdcoptionbyname(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdcoptionbyname(v_option_name character varying, v_version character varying) RETURNS SETOF public.vdc_options
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vdc_options.*
    FROM vdc_options
    WHERE OPTION_name = v_option_name
        AND version = v_version;
END;$$;


ALTER FUNCTION public.getvdcoptionbyname(v_option_name character varying, v_version character varying) OWNER TO engine;

--
-- Name: getvds_spm_id_mapbystorage_pool_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvds_spm_id_mapbystorage_pool_id(v_storage_pool_id uuid) RETURNS SETOF public.vds_spm_id_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_spm_id_map.*
    FROM vds_spm_id_map
    WHERE storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getvds_spm_id_mapbystorage_pool_id(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getvds_spm_id_mapbystorage_pool_idandbyvds_spm_id(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvds_spm_id_mapbystorage_pool_idandbyvds_spm_id(v_storage_pool_id uuid, v_vds_spm_id integer) RETURNS SETOF public.vds_spm_id_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_spm_id_map.*
    FROM vds_spm_id_map
    WHERE storage_pool_id = v_storage_pool_id
        AND vds_spm_id = v_vds_spm_id;
END;$$;


ALTER FUNCTION public.getvds_spm_id_mapbystorage_pool_idandbyvds_spm_id(v_storage_pool_id uuid, v_vds_spm_id integer) OWNER TO engine;

--
-- Name: getvds_spm_id_mapbyvds_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvds_spm_id_mapbyvds_id(v_vds_id uuid) RETURNS SETOF public.vds_spm_id_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_spm_id_map.*
    FROM vds_spm_id_map
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.getvds_spm_id_mapbyvds_id(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvdsbyclusterid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    -- this sp returns all vds for a given cluster
    BEGIN
        IF (v_is_filtered) THEN
            RETURN QUERY

        SELECT DISTINCT (rec).*
        FROM fn_db_mask_object('vds') AS q(rec vds)
        WHERE (rec).cluster_id = v_cluster_id
            AND EXISTS (
                SELECT 1
                FROM user_vds_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = (rec).vds_id
                );ELSE

        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE cluster_id = v_cluster_id;
        END IF;

    END;
    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyclusterid(v_cluster_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvdsbyhostname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyhostname(v_host_name character varying) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE host_name = v_host_name;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyhostname(v_host_name character varying) OWNER TO engine;

--
-- Name: getvdsbyhostnameandclusterid(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyhostnameandclusterid(v_host_name character varying, v_cluster_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE host_name = v_host_name
        AND   cluster_id = v_cluster_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyhostnameandclusterid(v_host_name character varying, v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvdsbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyname(v_vds_name character varying) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE vds_name = v_vds_name;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyname(v_vds_name character varying) OWNER TO engine;

--
-- Name: getvdsbynameandclusterid(character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbynameandclusterid(v_vds_name character varying, v_cluster_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE vds_name = v_vds_name
        AND   cluster_id = v_cluster_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbynameandclusterid(v_vds_name character varying, v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvdsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbynetworkid(v_network_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds
    WHERE EXISTS (
            SELECT 1
            FROM vds_interface
            INNER JOIN network
                ON network.name = vds_interface.network_name
            INNER JOIN network_cluster
                ON network.id = network_cluster.network_id
            WHERE network_id = v_network_id
                AND vds.cluster_id = network_cluster.cluster_id
                AND vds_interface.vds_id = vds.vds_id
            );
END;$$;


ALTER FUNCTION public.getvdsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvdsbystoragepoolid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbystoragepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE storage_pool_id = v_storage_pool_id
            AND (
                NOT v_is_filtered
                OR EXISTS (
                    SELECT 1
                    FROM user_vds_permissions_view
                    WHERE user_id = v_user_id
                        AND entity_id = vds_id
                    )
                );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbystoragepoolid(v_storage_pool_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvdsbystoragepoolidwithstatuses(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbystoragepoolidwithstatuses(v_storage_pool_id uuid, v_statuses character varying) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY
        SELECT vds.*
        FROM vds
        INNER JOIN cluster cluster
            ON vds.cluster_id = cluster.cluster_id
        WHERE (v_statuses IS NULL
            OR vds.status IN (
                SELECT *
                FROM fnSplitterInteger(v_statuses)))
            AND (vds.storage_pool_id = v_storage_pool_id)
            AND cluster.virt_service = true;
    END;
    RETURN;
END; $$;


ALTER FUNCTION public.getvdsbystoragepoolidwithstatuses(v_storage_pool_id uuid, v_statuses character varying) OWNER TO engine;

--
-- Name: getvdsbytype(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbytype(v_vds_type integer) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE vds_type = v_vds_type;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbytype(v_vds_type integer) OWNER TO engine;

--
-- Name: getvdsbyuniqueid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyuniqueid(v_vds_unique_id character varying) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE vds_unique_id = v_vds_unique_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyuniqueid(v_vds_unique_id character varying) OWNER TO engine;

--
-- Name: getvdsbyvdsid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsbyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE v_columns TEXT [];

BEGIN
    BEGIN
        IF (v_is_filtered) THEN
            RETURN QUERY

            SELECT DISTINCT (rec).*
            FROM fn_db_mask_object('vds') AS q(rec vds)
            WHERE (rec).vds_id = v_vds_id
                AND EXISTS (
                    SELECT 1
                    FROM user_vds_permissions_view
                    WHERE user_id = v_user_id
                        AND entity_id = v_vds_id
                    );
        ELSE

            RETURN QUERY

            SELECT DISTINCT vds.*
            FROM vds
            WHERE vds_id = v_vds_id;
        END IF;

    END;
    RETURN;
END;$$;


ALTER FUNCTION public.getvdsbyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvdsdynamicbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsdynamicbyvdsid(v_vds_id uuid) RETURNS SETOF public.vds_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_dynamic.*
        FROM vds_dynamic
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsdynamicbyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvdsforclusterwithpeerstatus(uuid, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsforclusterwithpeerstatus(v_cluster_id uuid, v_status integer, v_peer_status character varying) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds.*
        FROM vds
        INNER JOIN gluster_server
            ON vds_id = server_id
        WHERE (status = v_status)
            AND (peer_status = v_peer_status)
            AND (cluster_id = v_cluster_id)
        ORDER BY vds.vds_id ASC;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsforclusterwithpeerstatus(v_cluster_id uuid, v_status integer, v_peer_status character varying) OWNER TO engine;

--
-- Name: getvdsforclusterwithstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsforclusterwithstatus(v_cluster_id uuid, v_status integer) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds.*
        FROM vds
        WHERE (status = v_status)
            AND (cluster_id = v_cluster_id)
        ORDER BY vds.vds_id ASC;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsforclusterwithstatus(v_cluster_id uuid, v_status integer) OWNER TO engine;

--
-- Name: getvdsinterfacebyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsinterfacebyid(v_vds_interface_id uuid) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds_interface_view
    WHERE id = v_vds_interface_id;
END;$$;


ALTER FUNCTION public.getvdsinterfacebyid(v_vds_interface_id uuid) OWNER TO engine;

--
-- Name: getvdsinterfacebyname(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsinterfacebyname(v_host_id uuid, v_name character varying) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds_interface_view
    WHERE name = v_name
        AND vds_id = v_host_id;
END;$$;


ALTER FUNCTION public.getvdsinterfacebyname(v_host_id uuid, v_name character varying) OWNER TO engine;

--
-- Name: getvdsinterfacesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsinterfacesbynetworkid(v_network_id uuid) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_interface_view.*
    FROM vds_interface_view
    INNER JOIN vds
        ON vds.vds_id = vds_interface_view.vds_id
    INNER JOIN network_cluster
        ON network_cluster.cluster_id = vds.cluster_id
    INNER JOIN network
        ON network.id = network_cluster.network_id
            AND network.name = vds_interface_view.network_name
    WHERE network.id = v_network_id;
END;$$;


ALTER FUNCTION public.getvdsinterfacesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvdsmanagedinterfacebyvdsid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsmanagedinterfacebyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vds_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vds_interface_view
    -- Checking if the 2nd bit in the type column is set, meaning that the interface is managed
    WHERE vds_id = v_vds_id
        AND (type & 2) = 2
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vds_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vds_id
                )
            );
END;$$;


ALTER FUNCTION public.getvdsmanagedinterfacebyvdsid(v_vds_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvdsstaticbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyclusterid(v_cluster_id uuid) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_static.*
        FROM vds_static vds_static
        WHERE cluster_id = v_cluster_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvdsstaticbyhostname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyhostname(v_host_name character varying) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.*
    FROM vds_static
    WHERE host_name = v_host_name;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyhostname(v_host_name character varying) OWNER TO engine;

--
-- Name: getvdsstaticbyip(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyip(v_ip character varying) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_static.*
        FROM vds_static vds_static,
            fence_agents fence_agents
        WHERE fence_agents.ip = v_ip
            AND fence_agents.vds_id = vds_static.vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyip(v_ip character varying) OWNER TO engine;

--
-- Name: getvdsstaticbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyvdsid(v_vds_id uuid) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.*
    FROM vds_static
    WHERE vds_id = v_vds_id;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvdsstaticbyvdsids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyvdsids(v_vds_ids uuid[]) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.*
    FROM vds_static
    WHERE vds_id = ANY(v_vds_ids);

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyvdsids(v_vds_ids uuid[]) OWNER TO engine;

--
-- Name: getvdsstaticbyvdsname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstaticbyvdsname(v_host_name character varying) RETURNS SETOF public.vds_static
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds_static.*
    FROM vds_static
    WHERE vds_name = v_host_name;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstaticbyvdsname(v_host_name character varying) OWNER TO engine;

--
-- Name: getvdsstatisticsbyvdsid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdsstatisticsbyvdsid(v_vds_id uuid) RETURNS SETOF public.vds_statistics
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT vds_statistics.*
        FROM vds_statistics
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdsstatisticsbyvdsid(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvdswithoutmigratingvmsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdswithoutmigratingvmsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    -- this sp returns all vds in given cluster that have no pending vms and no vms in migration states
    BEGIN
        RETURN QUERY

        SELECT DISTINCT vds.*
        FROM vds
        WHERE cluster_id = v_cluster_id
            AND pending_vcpus_count = 0
            AND vds.status = 3
            AND vds_id NOT IN (
                SELECT DISTINCT run_on_vds
                FROM vm_dynamic
                WHERE status IN (
                        5,
                        6,
                        11,
                        12
                        )
                );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvdswithoutmigratingvmsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvdswithoutnetwork(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvdswithoutnetwork(v_network_id uuid) RETURNS SETOF public.vds
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vds.*
    FROM vds
    INNER JOIN network_cluster
        ON vds.cluster_id = network_cluster.cluster_id
    WHERE network_cluster.network_id = v_network_id
        AND NOT EXISTS (
            SELECT 1
            FROM vds_interface
            INNER JOIN network
                ON network.name = vds_interface.network_name
            INNER JOIN network_cluster
                ON network.id = network_cluster.network_id
            WHERE network_cluster.network_id = v_network_id
                AND vds.cluster_id = network_cluster.cluster_id
                AND vds_interface.vds_id = vds.vds_id
            );
END;$$;


ALTER FUNCTION public.getvdswithoutnetwork(v_network_id uuid) OWNER TO engine;

--
-- Name: getvfsconfigbynicid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvfsconfigbynicid(v_nic_id uuid) RETURNS SETOF public.host_nic_vfs_config
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM host_nic_vfs_config
    WHERE nic_id = v_nic_id;
END;$$;


ALTER FUNCTION public.getvfsconfigbynicid(v_nic_id uuid) OWNER TO engine;

--
-- Name: getvm_interface_statisticsbyid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvm_interface_statisticsbyid(v_id uuid) RETURNS SETOF public.vm_interface_statistics
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_statistics
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvm_interface_statisticsbyid(v_id uuid) OWNER TO engine;

--
-- Name: getvm_pool_mapbyvm_pool_id(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvm_pool_mapbyvm_pool_id(v_vm_pool_id uuid) RETURNS SETOF public.vm_pool_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_pool_map.*
    FROM vm_pool_map
    INNER JOIN vm_static
        ON vm_pool_map.vm_guid = vm_static.vm_guid
    WHERE vm_pool_id = v_vm_pool_id
    ORDER BY vm_static.vm_name;
END;$$;


ALTER FUNCTION public.getvm_pool_mapbyvm_pool_id(v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: getvm_poolsbyadgroup_names(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvm_poolsbyadgroup_names(v_ad_group_names character varying) RETURNS SETOF public.vm_pools_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT vm_pools_view.*
    FROM ad_groups
    INNER JOIN users_and_groups_to_vm_pool_map_view
        ON ad_groups.id = users_and_groups_to_vm_pool_map_view.user_id
    INNER JOIN vm_pools_view
        ON users_and_groups_to_vm_pool_map_view.vm_pool_id = vm_pools_view.vm_pool_id
    WHERE (
            ad_groups.name IN (
                SELECT Id
                FROM fnSplitter(v_ad_group_names)
                )
            );
END;$$;


ALTER FUNCTION public.getvm_poolsbyadgroup_names(v_ad_group_names character varying) OWNER TO engine;

--
-- Name: vm_pools_full_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_pools_full_view AS
 SELECT vmp.vm_pool_id,
    vmp.vm_pool_name,
    vmp.vm_pool_description,
    vmp.vm_pool_comment,
    vmp.vm_pool_type,
    vmp.stateful,
    vmp.parameters,
    vmp.prestarted_vms,
    vmp.cluster_id,
    vmp.cluster_name,
    vmp.architecture,
    vmp.max_assigned_vms_per_user,
    vmp.spice_proxy,
    ( SELECT count(vm_pool_map.vm_pool_id) AS expr1
           FROM (public.vm_pools_view v1
             LEFT JOIN public.vm_pool_map ON (((v1.vm_pool_id = vm_pool_map.vm_pool_id) AND (v1.vm_pool_id = vmp.vm_pool_id))))) AS assigned_vm_count,
    ( SELECT count(v2.vm_pool_id) AS expr1
           FROM ((public.vm_pools v2
             LEFT JOIN public.vm_pool_map vm_pool_map_1 ON (((v2.vm_pool_id = vm_pool_map_1.vm_pool_id) AND (v2.vm_pool_id = vmp.vm_pool_id))))
             LEFT JOIN public.vm_dynamic ON ((vm_pool_map_1.vm_guid = vm_dynamic.vm_guid)))
          WHERE (vm_dynamic.status <> ALL (ARRAY[0, 15]))
          GROUP BY v2.vm_pool_id) AS vm_running_count,
    vmp.storage_pool_name,
    vmp.storage_pool_id,
    vmp.is_being_destroyed,
    vmp.is_auto_storage_select
   FROM public.vm_pools_view vmp;


ALTER TABLE public.vm_pools_full_view OWNER TO engine;

--
-- Name: getvm_poolsbyvm_pool_id(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvm_poolsbyvm_pool_id(v_vm_pool_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_pools_full_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_pools_full_view.*
    FROM vm_pools_full_view
    WHERE vm_pool_id = v_vm_pool_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_pool_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_pool_id
                )
            );
END;$$;


ALTER FUNCTION public.getvm_poolsbyvm_pool_id(v_vm_pool_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvm_poolsbyvm_pool_name(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvm_poolsbyvm_pool_name(v_vm_pool_name character varying) RETURNS SETOF public.vm_pools_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_pools_view.*
    FROM vm_pools_view
    WHERE vm_pool_name = v_vm_pool_name;
END;$$;


ALTER FUNCTION public.getvm_poolsbyvm_pool_name(v_vm_pool_name character varying) OWNER TO engine;

--
-- Name: getvmandtemplatesidsbystoragedomainid(uuid, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmandtemplatesidsbystoragedomainid(v_storage_domain_id uuid, v_include_shareable boolean, v_active_only boolean) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT vd.vm_id
    FROM vm_device vd
    INNER JOIN images_storage_domain_view i
        ON i.image_group_id = vd.device_id
    WHERE i.storage_id = v_storage_domain_id
        AND i.active = v_active_only
        AND i.shareable = v_include_shareable;
END;$$;


ALTER FUNCTION public.getvmandtemplatesidsbystoragedomainid(v_storage_domain_id uuid, v_include_shareable boolean, v_active_only boolean) OWNER TO engine;

--
-- Name: getvmbackupbyvmbackupid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmbackupbyvmbackupid(v_backup_id uuid) RETURNS SETOF public.vm_backups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_backups
    WHERE backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.getvmbackupbyvmbackupid(v_backup_id uuid) OWNER TO engine;

--
-- Name: getvmbackupsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmbackupsbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_backups
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_backups
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.getvmbackupsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvmbootactivedisk(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmbootactivedisk(v_vm_guid uuid) RETURNS SETOF public.all_disks
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT all_disks.*
    FROM all_disks
    INNER JOIN vm_device
        ON vm_device.device_id = all_disks.image_group_id
    INNER JOIN disk_vm_element
        ON disk_vm_element.disk_id = all_disks.image_group_id
    WHERE disk_vm_element.vm_id = v_vm_guid
        AND disk_vm_element.is_boot = TRUE
        AND vm_device.vm_id = v_vm_guid
        AND vm_device.snapshot_id IS NULL;
END;$$;


ALTER FUNCTION public.getvmbootactivedisk(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getvmbyvmguid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmbyvmguid(v_vm_guid uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE vm_guid = v_vm_guid
       AND   (NOT v_is_filtered OR EXISTS (SELECT 1
                                       FROM   user_vm_permissions_view
                                       WHERE  user_id = v_user_id AND entity_id = v_vm_guid));
END; $$;


ALTER FUNCTION public.getvmbyvmguid(v_vm_guid uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmbyvmnamefordatacenter(uuid, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmbyvmnamefordatacenter(v_data_center_id uuid, v_vm_name character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE vm_name = v_vm_name
       AND   (v_data_center_id is null OR storage_pool_id = v_data_center_id)
       AND   (NOT v_is_filtered OR EXISTS (SELECT 1
                                       FROM   user_vm_permissions_view
                                       WHERE  user_id = v_user_id AND entity_id = vms.vm_guid));
END; $$;


ALTER FUNCTION public.getvmbyvmnamefordatacenter(v_data_center_id uuid, v_vm_name character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmcheckpointbyvmcheckpointid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmcheckpointbyvmcheckpointid(v_checkpoint_id uuid) RETURNS SETOF public.vm_checkpoints
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_checkpoints
    WHERE checkpoint_id = v_checkpoint_id;
END;$$;


ALTER FUNCTION public.getvmcheckpointbyvmcheckpointid(v_checkpoint_id uuid) OWNER TO engine;

--
-- Name: getvmcheckpointbyvmcheckpointparentid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmcheckpointbyvmcheckpointparentid(v_checkpoint_id uuid) RETURNS SETOF public.vm_checkpoints
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_checkpoints
    WHERE parent_id = v_checkpoint_id;
END;$$;


ALTER FUNCTION public.getvmcheckpointbyvmcheckpointparentid(v_checkpoint_id uuid) OWNER TO engine;

--
-- Name: getvmcheckpointsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmcheckpointsbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_checkpoints
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY WITH RECURSIVE checkpoint_list AS (
          SELECT *
          FROM   vm_checkpoints
          WHERE  vm_id = v_vm_id AND parent_id is NULL
          UNION ALL
          SELECT vm_checkpoints.*
          FROM   vm_checkpoints
          JOIN   checkpoint_list ON
                 checkpoint_list.checkpoint_id = vm_checkpoints.parent_id AND
                 checkpoint_list.vm_id = vm_checkpoints.vm_id
      )
      SELECT *
      FROM checkpoint_list;
END;$$;


ALTER FUNCTION public.getvmcheckpointsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvmdatafrompoolbypoolid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdatafrompoolbypoolid(v_pool_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vms.*
    FROM vms
    WHERE vm_pool_id = v_pool_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_pool_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_pool_id
                )
            )
        -- Limiting results to 1 since we only need a single VM from the pool to retrieve the pool data
        LIMIT 1;
END;$$;


ALTER FUNCTION public.getvmdatafrompoolbypoolid(v_pool_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmdevicebydeviceid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebydeviceid(v_device_id uuid, v_vm_id uuid) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE device_id = v_device_id
        AND (
            v_vm_id IS NULL
            OR vm_id = v_vm_id
            );
END;$$;


ALTER FUNCTION public.getvmdevicebydeviceid(v_device_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: getvmdevicebytype(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebytype(v_type character varying) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE type = v_type;
END;$$;


ALTER FUNCTION public.getvmdevicebytype(v_type character varying) OWNER TO engine;

--
-- Name: getvmdevicebytypeanddevice(uuid[], character varying, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebytypeanddevice(v_vm_ids uuid[], v_type character varying, v_device character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE vm_id = ANY(v_vm_ids)
        AND type = v_type
        AND device = v_device
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vm_id
                )
            )
    ORDER BY NULLIF(alias, '') NULLS LAST;
END;$$;


ALTER FUNCTION public.getvmdevicebytypeanddevice(v_vm_ids uuid[], v_type character varying, v_device character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmdevicebyvmid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE vm_id = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            )
    ORDER BY device_id;
END;$$;


ALTER FUNCTION public.getvmdevicebyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmdevicebyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebyvmidandtype(v_vm_id uuid, v_type character varying) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE vm_id = v_vm_id
        AND type = v_type
    ORDER BY NULLIF(alias, '') NULLS LAST;
END;$$;


ALTER FUNCTION public.getvmdevicebyvmidandtype(v_vm_id uuid, v_type character varying) OWNER TO engine;

--
-- Name: getvmdevicebyvmidtypeanddevice(uuid, character varying, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicebyvmidtypeanddevice(v_vm_id uuid, v_type character varying, v_device character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_device_view
    WHERE vm_id = v_vm_id
        AND type = v_type
        AND device = v_device
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                UNION
                SELECT 1
                FROM user_vm_template_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
            )
        )
    ORDER BY NULLIF(alias, '') NULLS LAST;
END;$$;


ALTER FUNCTION public.getvmdevicebyvmidtypeanddevice(v_vm_id uuid, v_type character varying, v_device character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmdevicesattachedtohost(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdevicesattachedtohost(v_host_id uuid) RETURNS SETOF public.vm_device
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_device.*
    FROM vm_device
    INNER JOIN vm_host_pinning_map
        ON vm_device.vm_id = vm_host_pinning_map.vm_id
            AND vm_host_pinning_map.vds_id = v_host_id
    WHERE vm_device.type = 'hostdev';
END;$$;


ALTER FUNCTION public.getvmdevicesattachedtohost(v_host_id uuid) OWNER TO engine;

--
-- Name: getvmdynamicbyvmguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmdynamicbyvmguid(v_vm_guid uuid) RETURNS SETOF public.vm_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_dynamic.*
    FROM vm_dynamic
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.getvmdynamicbyvmguid(v_vm_guid uuid) OWNER TO engine;

--
-- Name: vm_host_device_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_host_device_view AS
 SELECT host_device.host_id,
    host_device.device_name,
    host_device.parent_device_name,
    host_device.capability,
    host_device.iommu_group,
    host_device.product_name,
    host_device.product_id,
    host_device.vendor_name,
    host_device.vendor_id,
    host_device.physfn,
    host_device.total_vfs,
    host_device.vm_id,
    host_device.net_iface_name,
    host_device.driver,
    host_device.is_assignable,
    host_device.address,
    host_device.mdev_types,
    host_device.block_path,
    host_device.hostdev_spec_params,
    vm_device.vm_id AS configured_vm_id,
    vm_device.spec_params,
    array_to_string(array_agg(vm_host_pinning_view.vm_name) OVER (PARTITION BY host_device.host_id, host_device.device_name), ','::text) AS attached_vm_names,
    ( SELECT vm_static.vm_name
           FROM public.vm_static
          WHERE (vm_static.vm_guid = host_device.vm_id)) AS running_vm_name
   FROM ((public.vm_device
     JOIN public.vm_host_pinning_view ON ((vm_device.vm_id = vm_host_pinning_view.vm_id)))
     JOIN public.host_device ON ((((host_device.device_name)::text = (vm_device.device)::text) AND (vm_host_pinning_view.vds_id = host_device.host_id))))
  WHERE ((vm_device.type)::text = 'hostdev'::text);


ALTER TABLE public.vm_host_device_view OWNER TO engine;

--
-- Name: getvmextendedhostdevicesbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmextendedhostdevicesbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_host_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_host_device_view.*
    FROM vm_host_device_view
    WHERE vm_host_device_view.configured_vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.getvmextendedhostdevicesbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: vm_guest_agent_interfaces; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_guest_agent_interfaces (
    vm_id uuid NOT NULL,
    interface_name text,
    mac_address character varying(59),
    ipv4_addresses text,
    ipv6_addresses text
);


ALTER TABLE public.vm_guest_agent_interfaces OWNER TO engine;

--
-- Name: getvmguestagentinterfacesbyvmid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmguestagentinterfacesbyvmid(v_vm_id uuid, v_user_id uuid, v_filtered boolean) RETURNS SETOF public.vm_guest_agent_interfaces
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_guest_agent_interfaces
    WHERE vm_id = v_vm_id
        AND (
            NOT v_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            );
END;$$;


ALTER FUNCTION public.getvmguestagentinterfacesbyvmid(v_vm_id uuid, v_user_id uuid, v_filtered boolean) OWNER TO engine;

--
-- Name: getvmiconbyvmicondataurl(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmiconbyvmicondataurl(v_data_url text) RETURNS SETOF public.vm_icons
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icons
    WHERE data_url = v_data_url;
END;$$;


ALTER FUNCTION public.getvmiconbyvmicondataurl(v_data_url text) OWNER TO engine;

--
-- Name: getvmiconbyvmiconid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmiconbyvmiconid(v_id uuid) RETURNS SETOF public.vm_icons
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icons
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvmiconbyvmiconid(v_id uuid) OWNER TO engine;

--
-- Name: getvmicondefaultbyvmicondefaultid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmicondefaultbyvmicondefaultid(v_id uuid) RETURNS SETOF public.vm_icon_defaults
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icon_defaults
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvmicondefaultbyvmicondefaultid(v_id uuid) OWNER TO engine;

--
-- Name: getvmicondefaultbyvmicondefaultlargeiconid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmicondefaultbyvmicondefaultlargeiconid(v_large_icon_id uuid) RETURNS SETOF public.vm_icon_defaults
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icon_defaults
    WHERE large_icon_id = v_large_icon_id;
END;$$;


ALTER FUNCTION public.getvmicondefaultbyvmicondefaultlargeiconid(v_large_icon_id uuid) OWNER TO engine;

--
-- Name: getvmicondefaultbyvmicondefaultosid(integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmicondefaultbyvmicondefaultosid(v_os_id integer) RETURNS SETOF public.vm_icon_defaults
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_icon_defaults
    WHERE os_id = v_os_id;
END;$$;


ALTER FUNCTION public.getvmicondefaultbyvmicondefaultosid(v_os_id integer) OWNER TO engine;

--
-- Name: getvmidsforversionupdate(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmidsforversionupdate(v_base_template_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vs.vm_guid
    FROM vm_static vs natural
    INNER JOIN vm_dynamic
    WHERE (
            vmt_guid = v_base_template_id
            OR vmt_guid IN (
                SELECT vm_guid
                FROM vm_static
                WHERE vmt_guid = v_base_template_id
                )
            )
        AND template_version_number IS NULL
        AND entity_type = 'VM'
        AND status = 0
        AND (
            is_stateless = TRUE
            OR (
                EXISTS (
                    SELECT *
                    FROM vm_pool_map
                    WHERE vm_guid = vs.vm_guid
                    )
                AND NOT EXISTS (
                    SELECT *
                    FROM snapshots
                    WHERE vm_id = vs.vm_guid
                        AND snapshot_type = 'STATELESS'
                    )
                )
            );
END;$$;


ALTER FUNCTION public.getvmidsforversionupdate(v_base_template_id uuid) OWNER TO engine;

--
-- Name: getvmidsforvnicsoutofsync(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmidsforvnicsoutofsync(v_ids uuid[]) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT vm_guid
    FROM vm_interface
    WHERE NOT synced
    AND vm_guid = ANY(v_ids);
END;$$;


ALTER FUNCTION public.getvmidsforvnicsoutofsync(v_ids uuid[]) OWNER TO engine;

--
-- Name: getvmidswithspecificisoattached(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmidswithspecificisoattached(v_iso_disk_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vd.vm_guid
    FROM vm_dynamic vd
    WHERE vd.current_cd = v_iso_disk_id::VARCHAR;
END; $$;


ALTER FUNCTION public.getvmidswithspecificisoattached(v_iso_disk_id uuid) OWNER TO engine;

--
-- Name: getvmimagebyimageguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmimagebyimageguid(v_image_guid uuid) RETURNS SETOF public.vm_images_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
     RETURN QUERY SELECT *
     FROM vm_images_view
     WHERE image_guid = v_image_guid;
END; $$;


ALTER FUNCTION public.getvmimagebyimageguid(v_image_guid uuid) OWNER TO engine;

--
-- Name: vm_init; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_init (
    vm_id uuid NOT NULL,
    host_name text,
    domain text,
    authorized_keys text,
    regenerate_keys boolean DEFAULT false,
    time_zone character varying(40) DEFAULT NULL::character varying,
    dns_servers text,
    dns_search_domains text,
    networks text,
    password text,
    winkey character varying(30) DEFAULT NULL::character varying,
    custom_script text,
    input_locale character varying(256) DEFAULT NULL::character varying,
    ui_language character varying(256) DEFAULT NULL::character varying,
    system_locale character varying(256) DEFAULT NULL::character varying,
    user_locale character varying(256) DEFAULT NULL::character varying,
    user_name character varying(256) DEFAULT NULL::character varying,
    active_directory_ou character varying(256) DEFAULT NULL::character varying,
    org_name character varying(256) DEFAULT NULL::character varying,
    cloud_init_network_protocol character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.vm_init OWNER TO engine;

--
-- Name: getvminitbyids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminitbyids(v_vm_init_ids uuid[]) RETURNS SETOF public.vm_init
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT *
     FROM vm_init
     WHERE vm_init.vm_id = ANY(v_vm_init_ids);
END; $$;


ALTER FUNCTION public.getvminitbyids(v_vm_init_ids uuid[]) OWNER TO engine;

--
-- Name: getvminitbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminitbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_init
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_init.*
   FROM vm_init
   WHERE vm_id = v_vm_id;

END; $$;


ALTER FUNCTION public.getvminitbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvminterfacebytemplateid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacebytemplateid(v_template_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface
    WHERE vm_guid = v_template_id;
END;$$;


ALTER FUNCTION public.getvminterfacebytemplateid(v_template_id uuid) OWNER TO engine;

--
-- Name: getvminterfacebyvminterfaceid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacebyvminterfaceid(v_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvminterfacebyvminterfaceid(v_id uuid) OWNER TO engine;

--
-- Name: getvminterfacefilterparameterbyvminterfacefilterparameterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacefilterparameterbyvminterfacefilterparameterid(v_id uuid) RETURNS SETOF public.vm_interface_filter_parameters
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface_filter_parameters.*
    FROM vm_interface_filter_parameters
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvminterfacefilterparameterbyvminterfacefilterparameterid(v_id uuid) OWNER TO engine;

--
-- Name: getvminterfacefilterparametersbyvminterfaceid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacefilterparametersbyvminterfaceid(v_vm_interface_id uuid) RETURNS SETOF public.vm_interface_filter_parameters
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface_filter_parameters.*
    FROM vm_interface_filter_parameters
    WHERE vm_interface_id = v_vm_interface_id;
END;$$;


ALTER FUNCTION public.getvminterfacefilterparametersbyvminterfaceid(v_vm_interface_id uuid) OWNER TO engine;

--
-- Name: getvminterfacesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacesbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface.*
    FROM vm_interface
    INNER JOIN vnic_profiles
        ON vm_interface.vnic_profile_id = vnic_profiles.id
    INNER JOIN vm_static
        ON vm_interface.vm_guid = vm_static.vm_guid
    WHERE vnic_profiles.network_id = v_network_id
        AND vm_static.entity_type = 'VM';
END;$$;


ALTER FUNCTION public.getvminterfacesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvminterfacesbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfacesbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface
    WHERE vm_guid = v_vm_id;
END;$$;


ALTER FUNCTION public.getvminterfacesbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvminterfaceviewsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvminterfaceviewsbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface_view.*
    FROM vm_interface_view
    INNER JOIN vnic_profiles
        ON vnic_profiles.id = vm_interface_view.vnic_profile_id
    WHERE vnic_profiles.network_id = v_network_id
        AND vm_interface_view.vm_entity_type = 'VM';
END;$$;


ALTER FUNCTION public.getvminterfaceviewsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvmmapsinvmpoolbyvmpoolidandstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmmapsinvmpoolbyvmpoolidandstatus(v_vm_pool_id uuid, v_status integer) RETURNS SETOF public.vm_pool_map
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_pool_id,
        vm_pool_map.vm_guid
    FROM vm_pool_map,
        vm_dynamic
    WHERE vm_pool_map.vm_guid = vm_dynamic.vm_guid
        AND vm_pool_id = v_vm_pool_id
        AND vm_dynamic.status = v_status;
END;$$;


ALTER FUNCTION public.getvmmapsinvmpoolbyvmpoolidandstatus(v_vm_pool_id uuid, v_status integer) OWNER TO engine;

--
-- Name: getvmnameswithspecificisoattached(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnameswithspecificisoattached(v_iso_disk_id uuid) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vm.vm_name
    FROM vm_static vm
    WHERE vm.iso_path = v_iso_disk_id::VARCHAR;
END; $$;


ALTER FUNCTION public.getvmnameswithspecificisoattached(v_iso_disk_id uuid) OWNER TO engine;

--
-- Name: vm_interface_monitoring_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_interface_monitoring_view AS
 SELECT vm_interface_statistics.rx_rate,
    vm_interface_statistics.tx_rate,
    vm_interface_statistics.rx_drop,
    vm_interface_statistics.tx_drop,
    vm_interface_statistics.rx_total,
    vm_interface_statistics.tx_total,
    vm_interface_statistics.rx_offset,
    vm_interface_statistics.tx_offset,
    vm_interface_statistics.iface_status,
    vm_interface_statistics.sample_time,
    vm_interface.mac_addr,
    vm_interface.vnic_profile_id,
    vm_interface.speed,
    vm_interface.vm_guid,
    vm_interface.id
   FROM (public.vm_interface_statistics
     JOIN public.vm_interface ON ((vm_interface_statistics.id = vm_interface.id)));


ALTER TABLE public.vm_interface_monitoring_view OWNER TO engine;

--
-- Name: getvmnetworkinterfacetomonitorbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnetworkinterfacetomonitorbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_interface_monitoring_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_monitoring_view
    WHERE vm_guid = v_vm_id;
END;$$;


ALTER FUNCTION public.getvmnetworkinterfacetomonitorbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvmnetworkinterfaceviewbytemplateid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnetworkinterfaceviewbytemplateid(v_template_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_view
    WHERE vm_guid = v_template_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_template_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_template_id
                )
            );
END;$$;


ALTER FUNCTION public.getvmnetworkinterfaceviewbytemplateid(v_template_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmnetworkinterfaceviewbyvmid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnetworkinterfaceviewbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_view
    WHERE vm_guid = v_vm_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vm_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = v_vm_id
                )
            );
END;$$;


ALTER FUNCTION public.getvmnetworkinterfaceviewbyvmid(v_vm_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmnetworkinterfaceviewbyvmnetworkinterfaceviewid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnetworkinterfaceviewbyvmnetworkinterfaceviewid(v_id uuid) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_interface_view
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvmnetworkinterfaceviewbyvmnetworkinterfaceviewid(v_id uuid) OWNER TO engine;

--
-- Name: numa_node_with_cluster_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.numa_node_with_cluster_view AS
 SELECT vm_numa_node.numa_node_id AS vm_numa_node_id,
    vm_numa_node.vm_id AS vm_numa_node_vm_id,
    vm_numa_node.numa_node_index AS vm_numa_node_index,
    vm_numa_node.mem_total AS vm_numa_node_mem_total,
    vm_numa_node.cpu_count AS vm_numa_node_cpu_count,
    vm_numa_node.mem_free AS vm_numa_node_mem_free,
    vm_numa_node.usage_mem_percent AS vm_numa_node_usage_mem_percent,
    vm_numa_node.cpu_sys AS vm_numa_node_cpu_sys,
    vm_numa_node.cpu_user AS vm_numa_node_cpu_user,
    vm_numa_node.cpu_idle AS vm_numa_node_cpu_idle,
    vm_numa_node.usage_cpu_percent AS vm_numa_node_usage_cpu_percent,
    vm_numa_node.distance AS vm_numa_node_distance,
    vm_numa_node.hugepages AS vm_numa_node_hugepages,
    vm_numa_node.numa_tune_mode AS vm_numa_node_numa_tune_mode,
    vm_static.cluster_id
   FROM (public.numa_node vm_numa_node
     LEFT JOIN public.vm_static ON ((vm_numa_node.vm_id = vm_static.vm_guid)));


ALTER TABLE public.numa_node_with_cluster_view OWNER TO engine;

--
-- Name: getvmnumanodebycluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmnumanodebycluster(v_cluster_id uuid) RETURNS SETOF public.numa_node_with_cluster_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    BEGIN
        RETURN QUERY

        SELECT numa_node_with_cluster_view.*
        FROM numa_node_with_cluster_view
        WHERE cluster_id = v_cluster_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.getvmnumanodebycluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvmsandtemplatesidswithoutattachedimagedisks(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsandtemplatesidswithoutattachedimagedisks(v_storage_pool_id uuid, v_shareable boolean) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vs.vm_guid
      FROM vm_static vs
      WHERE vs.vm_guid NOT IN (SELECT DISTINCT vd.vm_id
                               FROM vm_device vd
                               INNER JOIN base_disks i
                               ON i.disk_id = vd.device_id
                               AND vd.snapshot_id IS NULL
                               WHERE i.disk_storage_type in (0, 2)  -- Filter VMs with Images (0) or Cinder (2) disks.
                                 AND i.shareable = v_shareable)
      AND vs.cluster_id IN (SELECT vg.cluster_id
                              FROM cluster vg, storage_pool sp
                              WHERE vg.storage_pool_id = v_storage_pool_id);
END; $$;


ALTER FUNCTION public.getvmsandtemplatesidswithoutattachedimagedisks(v_storage_pool_id uuid, v_shareable boolean) OWNER TO engine;

--
-- Name: getvmsbyadgroupnames(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyadgroupnames(v_ad_group_names character varying) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select distinct vms.* from vms
   inner join permissions on vms.vm_guid = permissions.object_id
   inner join ad_groups on ad_groups.id = permissions.ad_element_id
   WHERE     (ad_groups.name in(select Id from fnSplitter(v_ad_group_names)));
END; $$;


ALTER FUNCTION public.getvmsbyadgroupnames(v_ad_group_names character varying) OWNER TO engine;

--
-- Name: getvmsbyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyclusterid(v_cluster_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vms.*
      FROM vms
      WHERE cluster_id = v_cluster_id;
END; $$;


ALTER FUNCTION public.getvmsbyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvmsbycpuprofileids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbycpuprofileids(v_cpu_profile_ids uuid[]) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vms.*
        FROM vms
        WHERE cpu_profile_id = ANY(v_cpu_profile_ids);
END; $$;


ALTER FUNCTION public.getvmsbycpuprofileids(v_cpu_profile_ids uuid[]) OWNER TO engine;

--
-- Name: vms_with_plug_info; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vms_with_plug_info AS
 SELECT vms.vm_name,
    vms.mem_size_mb,
    vms.max_memory_size_mb,
    vms.num_of_io_threads,
    vms.nice_level,
    vms.cpu_shares,
    vms.vmt_guid,
    vms.os,
    vms.description,
    vms.free_text_comment,
    vms.cluster_id,
    vms.creation_date,
    vms.auto_startup,
    vms.lease_sd_id,
    vms.lease_info,
    vms.is_stateless,
    vms.is_smartcard_enabled,
    vms.is_delete_protected,
    vms.sso_method,
    vms.dedicated_vm_for_vds,
    vms.default_boot_sequence,
    vms.vm_type,
    vms.vm_pool_spice_proxy,
    vms.cluster_name,
    vms.transparent_hugepages,
    vms.trusted_service,
    vms.storage_pool_id,
    vms.storage_pool_name,
    vms.cluster_spice_proxy,
    vms.vmt_name,
    vms.status,
    vms.vm_ip,
    vms.vm_ip_inet_array,
    vms.vm_host,
    vms.last_start_time,
    vms.boot_time,
    vms.downtime,
    vms.guest_cur_user_name,
    vms.console_cur_user_name,
    vms.runtime_name,
    vms.guest_os,
    vms.console_user_id,
    vms.guest_agent_nics_hash,
    vms.run_on_vds,
    vms.migrating_to_vds,
    vms.app_list,
    vms.vm_pool_name,
    vms.vm_pool_id,
    vms.vm_guid,
    vms.num_of_monitors,
    vms.allow_console_reconnect,
    vms.is_initialized,
    vms.num_of_sockets,
    vms.cpu_per_socket,
    vms.threads_per_cpu,
    vms.usb_policy,
    vms.acpi_enable,
    vms.session,
    vms.num_of_cpus,
    vms.quota_id,
    vms.quota_name,
    vms.quota_enforcement_type,
    vms.boot_sequence,
    vms.utc_diff,
    vms.client_ip,
    vms.guest_requested_memory,
    vms.time_zone,
    vms.cpu_user,
    vms.cpu_sys,
    vms.elapsed_time,
    vms.usage_network_percent,
    vms.disks_usage,
    vms.usage_mem_percent,
    vms.usage_cpu_percent,
    vms.run_on_vds_name,
    vms.cluster_cpu_name,
    vms.cluster_cpu_flags,
    vms.cluster_cpu_verb,
    vms.default_display_type,
    vms.priority,
    vms.iso_path,
    vms.origin,
    vms.cluster_compatibility_version,
    vms.initrd_url,
    vms.kernel_url,
    vms.kernel_params,
    vms.pause_status,
    vms.exit_message,
    vms.exit_status,
    vms.migration_support,
    vms.predefined_properties,
    vms.userdefined_properties,
    vms.min_allocated_mem,
    vms.hash,
    vms.cpu_pinning,
    vms.db_generation,
    vms.host_cpu_flags,
    vms.tunnel_migration,
    vms.vnc_keyboard_layout,
    vms.is_run_and_pause,
    vms.created_by_user_id,
    vms.last_watchdog_event,
    vms.last_watchdog_action,
    vms.is_run_once,
    vms.volatile_run,
    vms.vm_fqdn,
    vms.cpu_name,
    vms.emulated_machine,
    vms.current_cd,
    vms.reason,
    vms.exit_reason,
    vms.instance_type_id,
    vms.image_type_id,
    vms.architecture,
    vms.original_template_id,
    vms.original_template_name,
    vms.last_stop_time,
    vms.migration_downtime,
    vms.template_version_number,
    vms.serial_number_policy,
    vms.custom_serial_number,
    vms.is_boot_menu_enabled,
    vms.guest_cpu_count,
    vms.next_run_config_exists,
    vms.is_previewing_snapshot,
    vms.changed_fields,
    vms.is_spice_file_transfer_enabled,
    vms.is_spice_copy_paste_enabled,
    vms.cpu_profile_id,
    vms.is_auto_converge,
    vms.is_migrate_compressed,
    vms.is_migrate_encrypted,
    vms.custom_emulated_machine,
    vms.bios_type,
    vms.cluster_bios_type,
    vms.custom_cpu_name,
    vms.spice_port,
    vms.spice_tls_port,
    vms.spice_ip,
    vms.vnc_port,
    vms.vnc_ip,
    vms.ovirt_guest_agent_status,
    vms.qemu_guest_agent_status,
    vms.guest_mem_buffered,
    vms.guest_mem_cached,
    vms.small_icon_id,
    vms.large_icon_id,
    vms.migration_policy_id,
    vms.provider_id,
    vms.console_disconnect_action,
    vms.resume_behavior,
    vms.guest_timezone_offset,
    vms.guest_timezone_name,
    vms.guestos_arch,
    vms.guestos_codename,
    vms.guestos_distribution,
    vms.guestos_kernel_version,
    vms.guestos_type,
    vms.guestos_version,
    vms.custom_compatibility_version,
    vms.guest_containers,
    vms.has_illegal_images,
    vms.multi_queues_enabled,
    vms.virtio_scsi_multi_queues,
    vms.use_tsc_frequency,
    vms.namespace,
    vms.balloon_enabled,
    vms.console_disconnect_action_delay,
    vms.cpu_pinning_policy,
    vms.current_cpu_pinning,
    vms.current_sockets,
    vms.current_cores,
    vms.current_threads,
    vms.current_numa_pinning,
    vms.parallel_migrations,
    vd.device_id,
    vd.vm_id,
    vd.type,
    vd.device,
    vd.address,
    vd.spec_params,
    vd.is_managed,
    vd.is_plugged,
    vd.is_readonly,
    vd._create_date,
    vd._update_date,
    vd.alias,
    vd.custom_properties,
    vd.snapshot_id,
    vd.logical_name,
    vd.host_device
   FROM (public.vms
     JOIN public.vm_device vd ON ((vd.vm_id = vms.vm_guid)));


ALTER TABLE public.vms_with_plug_info OWNER TO engine;

--
-- Name: getvmsbydiskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbydiskid(v_disk_guid uuid) RETURNS SETOF public.vms_with_plug_info
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT DISTINCT vms_with_plug_info.*
      FROM vms_with_plug_info
      WHERE device_id = v_disk_guid;
END; $$;


ALTER FUNCTION public.getvmsbydiskid(v_disk_guid uuid) OWNER TO engine;

--
-- Name: getvmsbyids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyids(v_vms_ids uuid[]) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm.*
             FROM vms vm
             WHERE vm.vm_guid = ANY(v_vms_ids);
END; $$;


ALTER FUNCTION public.getvmsbyids(v_vms_ids uuid[]) OWNER TO engine;

--
-- Name: getvmsbyinstancetypeid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyinstancetypeid(v_instance_type_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY select vms.* from vms
   WHERE instance_type_id = v_instance_type_id;
END; $$;


ALTER FUNCTION public.getvmsbyinstancetypeid(v_instance_type_id uuid) OWNER TO engine;

--
-- Name: getvmsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbynetworkid(v_network_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM vms
   WHERE EXISTS (
      SELECT 1
      FROM vm_interface
      INNER JOIN vnic_profiles
      ON vnic_profiles.id = vm_interface.vnic_profile_id
      WHERE vnic_profiles.network_id = v_network_id
          AND vm_interface.vm_guid = vms.vm_guid);
END; $$;


ALTER FUNCTION public.getvmsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvmsbyorigin(integer[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyorigin(v_origins integer[]) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT vms.*
        FROM vms
        WHERE origin = ANY(v_origins);
END; $$;


ALTER FUNCTION public.getvmsbyorigin(v_origins integer[]) OWNER TO engine;

--
-- Name: getvmsbystoragedomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbystoragedomainid(v_storage_domain_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT DISTINCT vms.*
      FROM vms
      INNER JOIN vm_device vd ON vd.vm_id = vms.vm_guid
      INNER JOIN images ON images.image_group_id = vd.device_id
          AND images.active = TRUE
      INNER JOIN image_storage_domain_map on images.image_guid = image_storage_domain_map.image_id
      WHERE image_storage_domain_map.storage_domain_id = v_storage_domain_id;
END; $$;


ALTER FUNCTION public.getvmsbystoragedomainid(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getvmsbyuserid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyuserid(v_user_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE v_vm_ids  UUID[];
BEGIN
SELECT array_agg(object_id) INTO v_vm_ids
FROM permissions
    WHERE ad_element_id = v_user_id;

RETURN QUERY
SELECT vms.*
FROM vms
   WHERE vm_guid = ANY(v_vm_ids);
END; $$;


ALTER FUNCTION public.getvmsbyuserid(v_user_id uuid) OWNER TO engine;

--
-- Name: getvmsbyuseridwithgroupsanduserroles(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyuseridwithgroupsanduserroles(v_user_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   from vms
   inner join permissions_view as perms on vms.vm_guid = perms.object_id
   WHERE (perms.ad_element_id = v_user_id
       OR perms.ad_element_id IN(
           SELECT id
           FROM getUserAndGroupsById(v_user_id)))
       AND perms.role_type = 2;

END; $$;


ALTER FUNCTION public.getvmsbyuseridwithgroupsanduserroles(v_user_id uuid) OWNER TO engine;

--
-- Name: getvmsbyvmpoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyvmpoolid(v_vm_pool_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vms.*
      FROM vms
      WHERE vm_pool_id = v_vm_pool_id;
END; $$;


ALTER FUNCTION public.getvmsbyvmpoolid(v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: getvmsbyvmtguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyvmtguid(v_vmt_guid uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE vmt_guid = v_vmt_guid;
END; $$;


ALTER FUNCTION public.getvmsbyvmtguid(v_vmt_guid uuid) OWNER TO engine;

--
-- Name: getvmsbyvnicprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsbyvnicprofileid(v_vnic_profile_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM vms
   WHERE EXISTS (
      SELECT 1
      FROM vm_interface
      WHERE vm_interface.vnic_profile_id = v_vnic_profile_id
          AND vm_interface.vm_guid = vms.vm_guid);
END; $$;


ALTER FUNCTION public.getvmsbyvnicprofileid(v_vnic_profile_id uuid) OWNER TO engine;

--
-- Name: getvmsdynamicrunningonvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsdynamicrunningonvds(v_vds_id uuid) RETURNS SETOF public.vm_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY SELECT vm_dynamic.*
      FROM vm_dynamic
      WHERE run_on_vds = v_vds_id;
END; $$;


ALTER FUNCTION public.getvmsdynamicrunningonvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmsidsforovfupdate(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsidsforovfupdate(v_storage_pool_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm.vm_guid AS vm_guid
    FROM vms vm,
        vm_ovf_generations ovf_gen
    WHERE vm.vm_guid = ovf_gen.vm_guid
        AND vm.db_generation > ovf_gen.ovf_generation
        AND vm.storage_pool_id = v_storage_pool_id
        -- filter out external VMs if needed.
        AND vm.origin != 4;
END;$$;


ALTER FUNCTION public.getvmsidsforovfupdate(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getvmsmigratingtovds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsmigratingtovds(v_vds_id uuid) RETURNS SETOF public.vm_dynamic
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vm_dynamic.*
   FROM vm_dynamic
   WHERE migrating_to_vds = v_vds_id;
END; $$;


ALTER FUNCTION public.getvmsmigratingtovds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmspinnedtohost(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmspinnedtohost(v_host_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vms.*
    FROM vms
        JOIN vm_host_pinning_map pin ON pin.vm_id = vms.vm_guid
    WHERE pin.vds_id = v_host_id;
END; $$;


ALTER FUNCTION public.getvmspinnedtohost(v_host_id uuid) OWNER TO engine;

--
-- Name: vms_monitoring_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vms_monitoring_view AS
 SELECT vm_dynamic.vm_guid,
    vm_dynamic.status,
    vm_dynamic.vm_ip,
    vm_dynamic.vm_host,
    vm_dynamic.last_start_time,
    vm_dynamic.guest_cur_user_name,
    vm_dynamic.guest_os,
    vm_dynamic.run_on_vds,
    vm_dynamic.migrating_to_vds,
    vm_dynamic.app_list,
    vm_dynamic.acpi_enable,
    vm_dynamic.session,
    vm_dynamic.utc_diff,
    vm_dynamic.client_ip,
    vm_dynamic.guest_requested_memory,
    vm_dynamic.boot_sequence,
    vm_dynamic.exit_status,
    vm_dynamic.pause_status,
    vm_dynamic.exit_message,
    vm_dynamic.hash,
    vm_dynamic.console_user_id,
    vm_dynamic.guest_agent_nics_hash,
    vm_dynamic.console_cur_user_name,
    vm_dynamic.last_watchdog_event,
    vm_dynamic.last_watchdog_action,
    vm_dynamic.is_run_once,
    vm_dynamic.vm_fqdn,
    vm_dynamic.cpu_name,
    vm_dynamic.last_stop_time,
    vm_dynamic.current_cd,
    vm_dynamic.reason,
    vm_dynamic.exit_reason,
    vm_dynamic.guest_cpu_count,
    vm_dynamic.emulated_machine,
    vm_dynamic.spice_port,
    vm_dynamic.spice_tls_port,
    vm_dynamic.spice_ip,
    vm_dynamic.vnc_port,
    vm_dynamic.vnc_ip,
    vm_dynamic.ovirt_guest_agent_status,
    vm_dynamic.guest_timezone_offset,
    vm_dynamic.guest_timezone_name,
    vm_dynamic.guestos_arch,
    vm_dynamic.guestos_codename,
    vm_dynamic.guestos_distribution,
    vm_dynamic.guestos_kernel_version,
    vm_dynamic.guestos_type,
    vm_dynamic.guestos_version,
    vm_dynamic.guest_containers,
    vm_dynamic.boot_time,
    vm_dynamic.downtime,
    vm_dynamic.volatile_run,
    vm_dynamic.lease_info,
    vm_dynamic.runtime_name,
    vm_dynamic.qemu_guest_agent_status,
    vm_dynamic.current_cpu_pinning,
    vm_dynamic.current_sockets,
    vm_dynamic.current_cores,
    vm_dynamic.current_threads,
    vm_dynamic.current_numa_pinning,
    vm_static.vm_name,
    vm_static.origin,
    vm_static.auto_startup,
    vm_static.mem_size_mb,
    vm_static.min_allocated_mem,
    vm_static.num_of_sockets,
    vm_static.cpu_per_socket,
    vm_static.threads_per_cpu,
    vm_static.priority,
    vm_static.lease_sd_id,
    public.fn_get_num_of_vcpus(vm_static.*) AS num_of_cpus,
    vm_static.cpu_pinning,
    vm_static.cpu_pinning_policy
   FROM (public.vm_dynamic
     JOIN public.vm_static ON ((vm_static.vm_guid = vm_dynamic.vm_guid)));


ALTER TABLE public.vms_monitoring_view OWNER TO engine;

--
-- Name: getvmsrunningbyvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsrunningbyvds(v_vds_id uuid) RETURNS SETOF public.vms_monitoring_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY
SELECT DISTINCT vms_monitoring_view.*
   FROM vms_monitoring_view
   WHERE run_on_vds = v_vds_id;

END; $$;


ALTER FUNCTION public.getvmsrunningbyvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmsrunningonmultiplevds(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsrunningonmultiplevds(v_vds_ids uuid[]) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY

   SELECT DISTINCT vms.*
   FROM vms
   WHERE run_on_vds = ANY(v_vds_ids);

END; $$;


ALTER FUNCTION public.getvmsrunningonmultiplevds(v_vds_ids uuid[]) OWNER TO engine;

--
-- Name: getvmsrunningonormigratingtovds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsrunningonormigratingtovds(v_vds_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    -- use migrating_to_vds column when the VM is in status Migrating From
    RETURN QUERY SELECT DISTINCT V.* FROM VMS V
    WHERE V.run_on_vds=v_vds_id
        OR (V.status = 5
            AND V.migrating_to_vds=v_vds_id)
    ORDER BY V.vm_name;
END; $$;


ALTER FUNCTION public.getvmsrunningonormigratingtovds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmsrunningonvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsrunningonvds(v_vds_id uuid) RETURNS SETOF public.vms
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT DISTINCT vms.*
   FROM vms
   WHERE run_on_vds = v_vds_id;

END; $$;


ALTER FUNCTION public.getvmsrunningonvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmsstaticrunningonvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmsstaticrunningonvds(v_vds_id uuid) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vs.*
    FROM vm_static_view vs
    JOIN vm_dynamic vd ON vd.vm_guid = vs.vm_guid
    WHERE run_on_vds = v_vds_id;
END; $$;


ALTER FUNCTION public.getvmsstaticrunningonvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: getvmstaticbycluster(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticbycluster(v_cluster_id uuid) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE cluster_id = v_cluster_id
       AND entity_type = 'VM';

END; $$;


ALTER FUNCTION public.getvmstaticbycluster(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvmstaticbygroupidandnetwork(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticbygroupidandnetwork(v_groupid uuid, v_networkname character varying) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_static_view.*
    FROM vm_static_view
    INNER JOIN vm_interface_view
        ON vm_static_view.vm_guid = vm_interface_view.vm_guid
            AND network_name = v_networkName
            AND vm_static_view.cluster_id = v_groupId;
END;$$;


ALTER FUNCTION public.getvmstaticbygroupidandnetwork(v_groupid uuid, v_networkname character varying) OWNER TO engine;

--
-- Name: getvmstaticbyname(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticbyname(v_vm_name character varying) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE vm_name = v_vm_name
       AND entity_type = 'VM';

END; $$;


ALTER FUNCTION public.getvmstaticbyname(v_vm_name character varying) OWNER TO engine;

--
-- Name: getvmstaticbyvmguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticbyvmguid(v_vm_guid uuid) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE vm_guid = v_vm_guid
       AND   entity_type = 'VM';

END; $$;


ALTER FUNCTION public.getvmstaticbyvmguid(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getvmstaticbyvmguids(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticbyvmguids(v_vm_guids uuid[]) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE vm_guid = ANY(v_vm_guids)
       AND entity_type = 'VM';
END; $$;


ALTER FUNCTION public.getvmstaticbyvmguids(v_vm_guids uuid[]) OWNER TO engine;

--
-- Name: getvmstaticwithouticon(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstaticwithouticon() RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY SELECT vm_static_view.*
   FROM vm_static_view
   WHERE entity_type = 'VM'
      AND (small_icon_id IS NULL OR large_icon_id IS NULL);
END; $$;


ALTER FUNCTION public.getvmstaticwithouticon() OWNER TO engine;

--
-- Name: getvmstatisticsbyvmguid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmstatisticsbyvmguid(v_vm_guid uuid) RETURNS SETOF public.vm_statistics
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_statistics.*
    FROM vm_statistics
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.getvmstatisticsbyvmguid(v_vm_guid uuid) OWNER TO engine;

--
-- Name: getvmswithleaseonstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmswithleaseonstoragedomain(v_storage_domain_id uuid) RETURNS SETOF public.vm_static_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vm_static_view.*
    FROM vm_static_view
    WHERE lease_sd_id = v_storage_domain_id
        AND entity_type = 'VM';
END; $$;


ALTER FUNCTION public.getvmswithleaseonstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: getvmtagsbytagid(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtagsbytagid(v_tag_ids character varying) RETURNS SETOF public.tags_vm_map_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT DISTINCT tags_vm_map_view.*
    FROM tags_vm_map_view
    WHERE tag_id IN (
            SELECT *
            FROM fnSplitterUuid(v_tag_ids)
            );
END;$$;


ALTER FUNCTION public.getvmtagsbytagid(v_tag_ids character varying) OWNER TO engine;

--
-- Name: getvmtemplatebyclusterid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatebyclusterid(v_cluster_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE cluster_id = v_cluster_id;
END; $$;


ALTER FUNCTION public.getvmtemplatebyclusterid(v_cluster_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatebyvmtguid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatebyvmtguid(v_vmt_guid uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE vmt_guid = v_vmt_guid
          AND (NOT v_is_filtered OR EXISTS (
              SELECT 1
              FROM   user_vm_template_permissions_view
              WHERE  user_id = v_user_id
                  AND entity_id = v_vmt_guid));
END; $$;


ALTER FUNCTION public.getvmtemplatebyvmtguid(v_vmt_guid uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmtemplatebyvmtname(uuid, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatebyvmtname(v_storage_pool_id uuid, v_vmt_name character varying, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE name = v_vmt_name
          AND   (v_storage_pool_id is null OR storage_pool_id = v_storage_pool_id OR storage_pool_id is null)
          AND (NOT v_is_filtered OR EXISTS (
              SELECT 1
              FROM   user_vm_template_permissions_view
              WHERE  user_id = v_user_id
                  AND entity_id = vmt_guid))
      ORDER BY vm_templates.template_version_number DESC;
END; $$;


ALTER FUNCTION public.getvmtemplatebyvmtname(v_storage_pool_id uuid, v_vmt_name character varying, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmtemplateinterfacesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplateinterfacesbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_interface
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface.*
    FROM vm_interface
    INNER JOIN vm_static
        ON vm_interface.vm_guid = vm_static.vm_guid
    INNER JOIN vnic_profiles
        ON vm_interface.vnic_profile_id = vnic_profiles.id
    WHERE vnic_profiles.network_id = v_network_id
        AND vm_static.entity_type = 'TEMPLATE';
END;$$;


ALTER FUNCTION public.getvmtemplateinterfacesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvmtemplateinterfaceviewsbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplateinterfaceviewsbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_interface_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_interface_view.*
    FROM vm_interface_view
    INNER JOIN vnic_profiles
        ON vnic_profiles.id = vm_interface_view.vnic_profile_id
    WHERE vnic_profiles.network_id = v_network_id
        AND vm_interface_view.vm_entity_type = 'TEMPLATE';
END;$$;


ALTER FUNCTION public.getvmtemplateinterfaceviewsbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatesbycpuprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbycpuprofileid(v_cpu_profile_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY SELECT vm_templates_based_view.*
        FROM vm_templates_based_view
        WHERE cpu_profile_id = v_cpu_profile_id;
END; $$;


ALTER FUNCTION public.getvmtemplatesbycpuprofileid(v_cpu_profile_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatesbyids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbyids(v_vm_templates_ids character varying) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY
   SELECT vm_templates.*
   FROM vm_templates_based_view vm_templates
   WHERE vm_templates.vmt_guid IN (SELECT * FROM fnSplitterUuid(v_vm_templates_ids));
END; $$;


ALTER FUNCTION public.getvmtemplatesbyids(v_vm_templates_ids character varying) OWNER TO engine;

--
-- Name: vm_templates_based_with_plug_info; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_templates_based_with_plug_info AS
 SELECT vm_templates_based_view.vmt_guid,
    vm_templates_based_view.name,
    vm_templates_based_view.mem_size_mb,
    vm_templates_based_view.max_memory_size_mb,
    vm_templates_based_view.num_of_io_threads,
    vm_templates_based_view.os,
    vm_templates_based_view.creation_date,
    vm_templates_based_view.child_count,
    vm_templates_based_view.num_of_sockets,
    vm_templates_based_view.cpu_per_socket,
    vm_templates_based_view.threads_per_cpu,
    vm_templates_based_view.num_of_cpus,
    vm_templates_based_view.description,
    vm_templates_based_view.free_text_comment,
    vm_templates_based_view.cluster_id,
    vm_templates_based_view.num_of_monitors,
    vm_templates_based_view.allow_console_reconnect,
    vm_templates_based_view.status,
    vm_templates_based_view.usb_policy,
    vm_templates_based_view.time_zone,
    vm_templates_based_view.cluster_name,
    vm_templates_based_view.cluster_compatibility_version,
    vm_templates_based_view.trusted_service,
    vm_templates_based_view.cluster_bios_type,
    vm_templates_based_view.vm_type,
    vm_templates_based_view.nice_level,
    vm_templates_based_view.cpu_shares,
    vm_templates_based_view.storage_pool_id,
    vm_templates_based_view.storage_pool_name,
    vm_templates_based_view.quota_enforcement_type,
    vm_templates_based_view.default_boot_sequence,
    vm_templates_based_view.default_display_type,
    vm_templates_based_view.priority,
    vm_templates_based_view.auto_startup,
    vm_templates_based_view.lease_sd_id,
    vm_templates_based_view.is_stateless,
    vm_templates_based_view.is_smartcard_enabled,
    vm_templates_based_view.is_delete_protected,
    vm_templates_based_view.sso_method,
    vm_templates_based_view.iso_path,
    vm_templates_based_view.origin,
    vm_templates_based_view.initrd_url,
    vm_templates_based_view.kernel_url,
    vm_templates_based_view.kernel_params,
    vm_templates_based_view.quota_id,
    vm_templates_based_view.quota_name,
    vm_templates_based_view.db_generation,
    vm_templates_based_view.host_cpu_flags,
    vm_templates_based_view.migration_support,
    vm_templates_based_view.dedicated_vm_for_vds,
    vm_templates_based_view.is_disabled,
    vm_templates_based_view.tunnel_migration,
    vm_templates_based_view.vnc_keyboard_layout,
    vm_templates_based_view.min_allocated_mem,
    vm_templates_based_view.is_run_and_pause,
    vm_templates_based_view.created_by_user_id,
    vm_templates_based_view.entity_type,
    vm_templates_based_view.migration_downtime,
    vm_templates_based_view.architecture,
    vm_templates_based_view.template_version_number,
    vm_templates_based_view.base_template_id,
    vm_templates_based_view.template_version_name,
    vm_templates_based_view.serial_number_policy,
    vm_templates_based_view.custom_serial_number,
    vm_templates_based_view.is_boot_menu_enabled,
    vm_templates_based_view.is_spice_file_transfer_enabled,
    vm_templates_based_view.is_spice_copy_paste_enabled,
    vm_templates_based_view.cpu_profile_id,
    vm_templates_based_view.is_auto_converge,
    vm_templates_based_view.is_migrate_compressed,
    vm_templates_based_view.is_migrate_encrypted,
    vm_templates_based_view.predefined_properties,
    vm_templates_based_view.userdefined_properties,
    vm_templates_based_view.custom_emulated_machine,
    vm_templates_based_view.bios_type,
    vm_templates_based_view.custom_cpu_name,
    vm_templates_based_view.small_icon_id,
    vm_templates_based_view.large_icon_id,
    vm_templates_based_view.migration_policy_id,
    vm_templates_based_view.console_disconnect_action,
    vm_templates_based_view.resume_behavior,
    vm_templates_based_view.custom_compatibility_version,
    vm_templates_based_view.multi_queues_enabled,
    vm_templates_based_view.virtio_scsi_multi_queues,
    vm_templates_based_view.use_tsc_frequency,
    vm_templates_based_view.is_template_sealed,
    vm_templates_based_view.cpu_pinning,
    vm_templates_based_view.balloon_enabled,
    vm_templates_based_view.console_disconnect_action_delay,
    vm_templates_based_view.cpu_pinning_policy,
    vm_templates_based_view.parallel_migrations,
    images.image_guid,
    images.image_group_id,
    vd.is_plugged
   FROM ((public.vm_templates_based_view
     JOIN public.vm_device vd ON ((vd.vm_id = vm_templates_based_view.vmt_guid)))
     JOIN public.images ON (((images.image_group_id = vd.device_id) AND (images.active = true))));


ALTER TABLE public.vm_templates_based_with_plug_info OWNER TO engine;

--
-- Name: getvmtemplatesbyimageid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbyimageid(v_image_guid uuid) RETURNS SETOF public.vm_templates_based_with_plug_info
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT *
      FROM vm_templates_based_with_plug_info t
      WHERE t.image_guid = v_image_guid;
END; $$;


ALTER FUNCTION public.getvmtemplatesbyimageid(v_image_guid uuid) OWNER TO engine;

--
-- Name: getvmtemplatesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbynetworkid(v_network_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY SELECT *
   FROM vm_templates_based_view
   WHERE EXISTS (
      SELECT 1
      FROM vm_interface
      INNER JOIN vnic_profiles
      ON vnic_profiles.id = vm_interface.vnic_profile_id
      WHERE vnic_profiles.network_id = v_network_id
          AND vm_interface.vm_guid = vm_templates_based_view.vmt_guid
          AND vm_templates_based_view.entity_type = 'TEMPLATE');
END; $$;


ALTER FUNCTION public.getvmtemplatesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatesbystoragedomainid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbystoragedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT DISTINCT vm_templates.*
      FROM vm_templates_based_view vm_templates
      INNER JOIN vm_device vd ON vd.vm_id = vm_templates.vmt_guid
      INNER JOIN images i ON i.image_group_id = vd.device_id AND i.active = TRUE
      WHERE i.image_guid in(
          SELECT image_id
          FROM image_storage_domain_map
          WHERE storage_domain_id = v_storage_domain_id)
              AND (NOT v_is_filtered OR EXISTS (
                  SELECT 1
                  FROM   user_vm_template_permissions_view
                  WHERE  user_id = v_user_id
                      AND entity_id = vm_templates.vmt_guid));
END; $$;


ALTER FUNCTION public.getvmtemplatesbystoragedomainid(v_storage_domain_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvmtemplatesbystoragepoolid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbystoragepoolid(v_storage_pool_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
      RETURN QUERY
      SELECT DISTINCT vm_templates.*
      FROM vm_templates_based_view vm_templates
      WHERE vm_templates.storage_pool_id = v_storage_pool_id;
END; $$;


ALTER FUNCTION public.getvmtemplatesbystoragepoolid(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatesbyvnicprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesbyvnicprofileid(v_vnic_profile_id uuid) RETURNS SETOF public.vm_templates_based_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
   RETURN QUERY
   SELECT *
   FROM vm_templates_based_view
   WHERE EXISTS (
      SELECT 1
      FROM vm_interface
      WHERE vm_interface.vnic_profile_id = v_vnic_profile_id
      AND vm_interface.vm_guid = vm_templates_based_view.vmt_guid
      AND vm_templates_based_view.entity_type = 'TEMPLATE');
END; $$;


ALTER FUNCTION public.getvmtemplatesbyvnicprofileid(v_vnic_profile_id uuid) OWNER TO engine;

--
-- Name: getvmtemplatesidsforovfupdate(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplatesidsforovfupdate(v_storage_pool_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT templates.vmt_guid AS vm_guid
    FROM vm_templates_based_view templates,
        vm_ovf_generations generations
    WHERE generations.vm_guid = templates.vmt_guid
        AND templates.db_generation > generations.ovf_generation
        AND templates.storage_pool_id = v_storage_pool_id;
END;$$;


ALTER FUNCTION public.getvmtemplatesidsforovfupdate(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: vm_templates_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_templates_view AS
 SELECT vm_templates_based_view.vmt_guid,
    vm_templates_based_view.name,
    vm_templates_based_view.mem_size_mb,
    vm_templates_based_view.max_memory_size_mb,
    vm_templates_based_view.num_of_io_threads,
    vm_templates_based_view.os,
    vm_templates_based_view.creation_date,
    vm_templates_based_view.child_count,
    vm_templates_based_view.num_of_sockets,
    vm_templates_based_view.cpu_per_socket,
    vm_templates_based_view.threads_per_cpu,
    vm_templates_based_view.num_of_cpus,
    vm_templates_based_view.description,
    vm_templates_based_view.free_text_comment,
    vm_templates_based_view.cluster_id,
    vm_templates_based_view.num_of_monitors,
    vm_templates_based_view.allow_console_reconnect,
    vm_templates_based_view.status,
    vm_templates_based_view.usb_policy,
    vm_templates_based_view.time_zone,
    vm_templates_based_view.cluster_name,
    vm_templates_based_view.cluster_compatibility_version,
    vm_templates_based_view.trusted_service,
    vm_templates_based_view.cluster_bios_type,
    vm_templates_based_view.vm_type,
    vm_templates_based_view.nice_level,
    vm_templates_based_view.cpu_shares,
    vm_templates_based_view.storage_pool_id,
    vm_templates_based_view.storage_pool_name,
    vm_templates_based_view.quota_enforcement_type,
    vm_templates_based_view.default_boot_sequence,
    vm_templates_based_view.default_display_type,
    vm_templates_based_view.priority,
    vm_templates_based_view.auto_startup,
    vm_templates_based_view.lease_sd_id,
    vm_templates_based_view.is_stateless,
    vm_templates_based_view.is_smartcard_enabled,
    vm_templates_based_view.is_delete_protected,
    vm_templates_based_view.sso_method,
    vm_templates_based_view.iso_path,
    vm_templates_based_view.origin,
    vm_templates_based_view.initrd_url,
    vm_templates_based_view.kernel_url,
    vm_templates_based_view.kernel_params,
    vm_templates_based_view.quota_id,
    vm_templates_based_view.quota_name,
    vm_templates_based_view.db_generation,
    vm_templates_based_view.host_cpu_flags,
    vm_templates_based_view.migration_support,
    vm_templates_based_view.dedicated_vm_for_vds,
    vm_templates_based_view.is_disabled,
    vm_templates_based_view.tunnel_migration,
    vm_templates_based_view.vnc_keyboard_layout,
    vm_templates_based_view.min_allocated_mem,
    vm_templates_based_view.is_run_and_pause,
    vm_templates_based_view.created_by_user_id,
    vm_templates_based_view.entity_type,
    vm_templates_based_view.migration_downtime,
    vm_templates_based_view.architecture,
    vm_templates_based_view.template_version_number,
    vm_templates_based_view.base_template_id,
    vm_templates_based_view.template_version_name,
    vm_templates_based_view.serial_number_policy,
    vm_templates_based_view.custom_serial_number,
    vm_templates_based_view.is_boot_menu_enabled,
    vm_templates_based_view.is_spice_file_transfer_enabled,
    vm_templates_based_view.is_spice_copy_paste_enabled,
    vm_templates_based_view.cpu_profile_id,
    vm_templates_based_view.is_auto_converge,
    vm_templates_based_view.is_migrate_compressed,
    vm_templates_based_view.is_migrate_encrypted,
    vm_templates_based_view.predefined_properties,
    vm_templates_based_view.userdefined_properties,
    vm_templates_based_view.custom_emulated_machine,
    vm_templates_based_view.bios_type,
    vm_templates_based_view.custom_cpu_name,
    vm_templates_based_view.small_icon_id,
    vm_templates_based_view.large_icon_id,
    vm_templates_based_view.migration_policy_id,
    vm_templates_based_view.console_disconnect_action,
    vm_templates_based_view.resume_behavior,
    vm_templates_based_view.custom_compatibility_version,
    vm_templates_based_view.multi_queues_enabled,
    vm_templates_based_view.virtio_scsi_multi_queues,
    vm_templates_based_view.use_tsc_frequency,
    vm_templates_based_view.is_template_sealed,
    vm_templates_based_view.cpu_pinning,
    vm_templates_based_view.balloon_enabled,
    vm_templates_based_view.console_disconnect_action_delay,
    vm_templates_based_view.cpu_pinning_policy,
    vm_templates_based_view.parallel_migrations
   FROM public.vm_templates_based_view
  WHERE ((vm_templates_based_view.entity_type)::text = 'TEMPLATE'::text);


ALTER TABLE public.vm_templates_view OWNER TO engine;

--
-- Name: getvmtemplateswithouticon(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmtemplateswithouticon() RETURNS SETOF public.vm_templates_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY
   SELECT vm_template.*
   FROM vm_templates_view AS vm_template
   WHERE small_icon_id IS NULL OR large_icon_id IS NULL;
END; $$;


ALTER FUNCTION public.getvmtemplateswithouticon() OWNER TO engine;

--
-- Name: getvmunmanageddevicesbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvmunmanageddevicesbyvmid(v_vm_id uuid) RETURNS SETOF public.vm_device_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT vm_device_view.*
    FROM vm_device_view
    WHERE vm_id = v_vm_id
        AND NOT is_managed;
END;$$;


ALTER FUNCTION public.getvmunmanageddevicesbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: getvnicprofilebyvnicprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofilebyvnicprofileid(v_id uuid) RETURNS SETOF public.vnic_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.getvnicprofilebyvnicprofileid(v_id uuid) OWNER TO engine;

--
-- Name: getvnicprofilesbyfailovervnicprofileid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofilesbyfailovervnicprofileid(v_failover_vnic_profile_id uuid) RETURNS SETOF public.vnic_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
RETURN QUERY

SELECT *
FROM vnic_profiles
WHERE failover_vnic_profile_id = v_failover_vnic_profile_id;
END;$$;


ALTER FUNCTION public.getvnicprofilesbyfailovervnicprofileid(v_failover_vnic_profile_id uuid) OWNER TO engine;

--
-- Name: getvnicprofilesbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofilesbynetworkid(v_network_id uuid) RETURNS SETOF public.vnic_profiles
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles
    WHERE network_id = v_network_id;
END;$$;


ALTER FUNCTION public.getvnicprofilesbynetworkid(v_network_id uuid) OWNER TO engine;

--
-- Name: getvnicprofileviewbyvnicprofileviewid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofileviewbyvnicprofileviewid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vnic_profile_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vnic_profiles_view.id
                )
            );
END;$$;


ALTER FUNCTION public.getvnicprofileviewbyvnicprofileviewid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvnicprofileviewsbyclusterid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofileviewsbyclusterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE EXISTS (
        SELECT 1
        FROM network_cluster
        WHERE cluster_id = v_id
        AND network_cluster.network_id = vnic_profiles_view.network_id
    )
    AND (
      NOT v_is_filtered
      OR EXISTS(
          SELECT 1
          FROM user_vnic_profile_permissions_view
          WHERE user_id = v_user_id
                AND entity_id = vnic_profiles_view.id
      )
    );
END;$$;


ALTER FUNCTION public.getvnicprofileviewsbyclusterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvnicprofileviewsbydatacenterid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofileviewsbydatacenterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE data_center_id = v_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vnic_profile_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vnic_profiles_view.id
                )
            );
END;$$;


ALTER FUNCTION public.getvnicprofileviewsbydatacenterid(v_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvnicprofileviewsbynetworkid(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofileviewsbynetworkid(v_network_id uuid, v_user_id uuid, v_is_filtered boolean) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE network_id = v_network_id
        AND (
            NOT v_is_filtered
            OR EXISTS (
                SELECT 1
                FROM user_vnic_profile_permissions_view
                WHERE user_id = v_user_id
                    AND entity_id = vnic_profiles_view.id
                )
            );
END;$$;


ALTER FUNCTION public.getvnicprofileviewsbynetworkid(v_network_id uuid, v_user_id uuid, v_is_filtered boolean) OWNER TO engine;

--
-- Name: getvnicprofileviewsbynetworkqosid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.getvnicprofileviewsbynetworkqosid(v_network_qos_id uuid) RETURNS SETOF public.vnic_profiles_view
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vnic_profiles_view
    WHERE network_qos_id = v_network_qos_id;
END;$$;


ALTER FUNCTION public.getvnicprofileviewsbynetworkqosid(v_network_qos_id uuid) OWNER TO engine;

--
-- Name: increasestoragepoolmasterversion(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.increasestoragepoolmasterversion(v_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE v_master_domain_version INT;

BEGIN
    UPDATE storage_pool
    SET master_domain_version = master_domain_version + 1
    WHERE id = v_id RETURNING master_domain_version
    INTO v_master_domain_version;

    RETURN v_master_domain_version;
END;$$;


ALTER FUNCTION public.increasestoragepoolmasterversion(v_id uuid) OWNER TO engine;

--
-- Name: incrementdbgeneration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.incrementdbgeneration(v_vm_guid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET db_generation  = db_generation + 1
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.incrementdbgeneration(v_vm_guid uuid) OWNER TO engine;

--
-- Name: incrementdbgenerationforallinstoragepool(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.incrementdbgenerationforallinstoragepool(v_storage_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
     curs CURSOR FOR SELECT vms.vm_guid FROM vm_static vms
                     WHERE vms.cluster_id IN (SELECT vgs.cluster_id FROM cluster vgs
                                                WHERE vgs.storage_pool_id=v_storage_pool_id)
                     ORDER BY vm_guid;
     id UUID;
BEGIN
      OPEN curs;
      LOOP
         FETCH curs INTO id;
         IF NOT FOUND THEN
            EXIT;
         END IF;
         UPDATE vm_static SET db_generation  = db_generation + 1 WHERE vm_guid = id;
      END LOOP;
END; $$;


ALTER FUNCTION public.incrementdbgenerationforallinstoragepool(v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: incrementdbgenerationforvms(uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.incrementdbgenerationforvms(v_vm_guids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_static
    SET db_generation = db_generation + 1
    WHERE vm_guid = ANY(v_vm_guids);
END; $$;


ALTER FUNCTION public.incrementdbgenerationforvms(v_vm_guids uuid[]) OWNER TO engine;

--
-- Name: insert_entity_snapshot(uuid, uuid, character varying, character varying, character varying, text, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insert_entity_snapshot(v_id uuid, v_command_id uuid, v_command_type character varying, v_entity_id character varying, v_entity_type character varying, v_entity_snapshot text, v_snapshot_class character varying, v_snapshot_type integer, v_insertion_order integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO business_entity_snapshot (
            id,
            command_id,
            command_type,
            entity_id,
            entity_type,
            entity_snapshot,
            snapshot_class,
            snapshot_type,
            insertion_order
            )
        VALUES (
            v_id,
            v_command_id,
            v_command_type,
            v_entity_id,
            v_entity_type,
            v_entity_snapshot,
            v_snapshot_class,
            v_snapshot_type,
            v_insertion_order
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insert_entity_snapshot(v_id uuid, v_command_id uuid, v_command_type character varying, v_entity_id character varying, v_entity_type character varying, v_entity_snapshot text, v_snapshot_class character varying, v_snapshot_type integer, v_insertion_order integer) OWNER TO engine;

--
-- Name: insert_osinfo(integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insert_osinfo(v_os_id integer, v_os_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO dwh_osinfo (
        os_id,
        os_name
        )
    VALUES (
        v_os_id,
        v_os_name
        );

    UPDATE dwh_history_timekeeping
    SET var_datetime = now()
    WHERE var_name = 'lastOsinfoUpdate';
END;$$;


ALTER FUNCTION public.insert_osinfo(v_os_id integer, v_os_name character varying) OWNER TO engine;

--
-- Name: insert_roles_groups(integer, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insert_roles_groups(v_action_group_id integer, v_role_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO roles_groups(
        action_group_id,
        role_id)
    VALUES(
        v_action_group_id,
        v_role_id);
END; $$;


ALTER FUNCTION public.insert_roles_groups(v_action_group_id integer, v_role_id uuid) OWNER TO engine;

--
-- Name: insertaffinitygroupwithmembers(uuid, character varying, character varying, uuid, boolean, boolean, boolean, boolean, boolean, boolean, bigint, uuid[], uuid[], uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertaffinitygroupwithmembers(v_id uuid, v_name character varying, v_description character varying, v_cluster_id uuid, v_vm_positive boolean, v_vm_enforcing boolean, v_vds_positive boolean, v_vds_enforcing boolean, v_vms_affinity_enabled boolean, v_vds_affinity_enabled boolean, v_priority bigint, v_vm_ids uuid[], v_vds_ids uuid[], v_vm_label_ids uuid[], v_host_label_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    o uuid;
BEGIN
    INSERT INTO affinity_groups (
        id,
        name,
        description,
        cluster_id,
        vm_positive,
        vm_enforcing,
        vds_positive,
        vds_enforcing,
        vms_affinity_enabled,
        vds_affinity_enabled,
        priority
        )
    VALUES (
        v_id,
        v_name,
        v_description,
        v_cluster_id,
        v_vm_positive,
        v_vm_enforcing,
        v_vds_positive,
        v_vds_enforcing,
        v_vms_affinity_enabled,
        v_vds_affinity_enabled,
        v_priority
        );

    FOREACH o IN ARRAY v_vm_ids
    LOOP
        PERFORM InsertAffinityVm(v_id, o);
    END LOOP;

    FOREACH o IN ARRAY v_vds_ids
    LOOP
        PERFORM InsertAffinityHost(v_id, o);
    END LOOP;

    FOREACH o IN ARRAY v_vm_label_ids
    LOOP
        PERFORM InsertAffinityVmLabel(v_id, o);
    END LOOP;

    FOREACH o IN ARRAY v_host_label_ids
    LOOP
        PERFORM InsertAffinityHostLabel(v_id, o);
    END LOOP;

END;$$;


ALTER FUNCTION public.insertaffinitygroupwithmembers(v_id uuid, v_name character varying, v_description character varying, v_cluster_id uuid, v_vm_positive boolean, v_vm_enforcing boolean, v_vds_positive boolean, v_vds_enforcing boolean, v_vms_affinity_enabled boolean, v_vds_affinity_enabled boolean, v_priority bigint, v_vm_ids uuid[], v_vds_ids uuid[], v_vm_label_ids uuid[], v_host_label_ids uuid[]) OWNER TO engine;

--
-- Name: insertaffinityhost(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertaffinityhost(v_affinity_group_id uuid, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO affinity_group_members(
        affinity_group_id,
        vds_id
    )
    VALUES (
        v_affinity_group_id,
        v_vds_id
    );
END;$$;


ALTER FUNCTION public.insertaffinityhost(v_affinity_group_id uuid, v_vds_id uuid) OWNER TO engine;

--
-- Name: insertaffinityhostlabel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertaffinityhostlabel(v_affinity_group_id uuid, v_host_label_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO affinity_group_members(
        affinity_group_id,
        host_label_id
    )
    VALUES (
        v_affinity_group_id,
        v_host_label_id
    );
END;$$;


ALTER FUNCTION public.insertaffinityhostlabel(v_affinity_group_id uuid, v_host_label_id uuid) OWNER TO engine;

--
-- Name: insertaffinityvm(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertaffinityvm(v_affinity_group_id uuid, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO affinity_group_members(
        affinity_group_id,
        vm_id
    )
    VALUES (
        v_affinity_group_id,
        v_vm_id
    );
END;$$;


ALTER FUNCTION public.insertaffinityvm(v_affinity_group_id uuid, v_vm_id uuid) OWNER TO engine;

--
-- Name: insertaffinityvmlabel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertaffinityvmlabel(v_affinity_group_id uuid, v_vm_label_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO affinity_group_members(
        affinity_group_id,
        vm_label_id
    )
    VALUES (
        v_affinity_group_id,
        v_vm_label_id
    );
END;$$;


ALTER FUNCTION public.insertaffinityvmlabel(v_affinity_group_id uuid, v_vm_label_id uuid) OWNER TO engine;

--
-- Name: insertasync_tasks(integer, integer, integer, uuid, uuid, uuid, uuid, uuid, uuid, timestamp with time zone, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertasync_tasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_started_at timestamp with time zone, v_storage_pool_id uuid, v_async_task_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO async_tasks (
        action_type,
        result,
        status,
        user_id,
        vdsm_task_id,
        task_id,
        step_id,
        command_id,
        root_command_id,
        started_at,
        storage_pool_id,
        task_type
        )
    VALUES (
        v_action_type,
        v_result,
        v_status,
        v_user_id,
        v_vdsm_task_id,
        v_task_id,
        v_step_id,
        v_command_id,
        v_root_command_id,
        v_started_at,
        v_storage_pool_id,
        v_async_task_type
        );
END;$$;


ALTER FUNCTION public.insertasync_tasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_started_at timestamp with time zone, v_storage_pool_id uuid, v_async_task_type integer) OWNER TO engine;

--
-- Name: insertasynctaskentities(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertasynctaskentities(v_task_id uuid, v_entity_id uuid, v_entity_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NOT EXISTS (
            SELECT 1
            FROM async_tasks_entities
            WHERE async_task_id = v_task_id
                AND entity_id = v_entity_id
            ) THEN
        INSERT INTO async_tasks_entities (
            async_task_id,
            entity_id,
            entity_type
            )
        VALUES (
            v_task_id,
            v_entity_id,
            v_entity_type
            );
END

IF ;END;$$;


ALTER FUNCTION public.insertasynctaskentities(v_task_id uuid, v_entity_id uuid, v_entity_type character varying) OWNER TO engine;

--
-- Name: insertauditlog(bigint, timestamp with time zone, integer, character varying, integer, text, uuid, character varying, uuid, character varying, uuid, character varying, uuid, character varying, uuid, character varying, uuid, character varying, uuid, character varying, uuid, character varying, character varying, uuid, uuid, character varying, text, boolean, uuid, text, character varying, integer, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertauditlog(INOUT v_audit_log_id bigint, v_log_time timestamp with time zone, v_log_type integer, v_log_type_name character varying, v_severity integer, v_message text, v_user_id uuid, v_user_name character varying, v_vds_id uuid, v_vds_name character varying, v_vm_id uuid, v_vm_name character varying, v_vm_template_id uuid, v_vm_template_name character varying, v_storage_pool_id uuid, v_storage_pool_name character varying, v_storage_domain_id uuid, v_storage_domain_name character varying, v_cluster_id uuid, v_cluster_name character varying, v_quota_id uuid, v_quota_name character varying, v_correlation_id character varying, v_job_id uuid, v_gluster_volume_id uuid, v_gluster_volume_name character varying, v_call_stack text, v_repeatable boolean, v_brick_id uuid, v_brick_path text, v_origin character varying, v_custom_event_id integer, v_event_flood_in_sec integer, v_custom_data text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE v_min_alert_severity INT;

BEGIN
    v_min_alert_severity := 10;

    -- insert regular log messages (non alerts)
    IF (v_severity < v_min_alert_severity) THEN
        INSERT INTO audit_log (
            LOG_TIME,
            log_type,
            log_type_name,
            severity,
            message,
            user_id,
            user_name,
            vds_id,
            vds_name,
            vm_id,
            vm_name,
            vm_template_id,
            vm_template_name,
            storage_pool_id,
            storage_pool_name,
            storage_domain_id,
            storage_domain_name,
            cluster_id,
            cluster_name,
            correlation_id,
            job_id,
            quota_id,
            quota_name,
            gluster_volume_id,
            gluster_volume_name,
            call_stack,
            brick_id,
            brick_path,
            origin,
            custom_event_id,
            event_flood_in_sec,
            custom_data
            )
        VALUES (
            v_log_time,
            v_log_type,
            v_log_type_name,
            v_severity,
            v_message,
            v_user_id,
            v_user_name,
            v_vds_id,
            v_vds_name,
            v_vm_id,
            v_vm_name,
            v_vm_template_id,
            v_vm_template_name,
            v_storage_pool_id,
            v_storage_pool_name,
            v_storage_domain_id,
            v_storage_domain_name,
            v_cluster_id,
            v_cluster_name,
            v_correlation_id,
            v_job_id,
            v_quota_id,
            v_quota_name,
            v_gluster_volume_id,
            v_gluster_volume_name,
            v_call_stack,
            v_brick_id,
            v_brick_path,
            v_origin,
            v_custom_event_id,
            v_event_flood_in_sec,
            v_custom_data
            );

        v_audit_log_id := CURRVAL('audit_log_seq');

        ELSE IF (
            v_repeatable
            OR NOT EXISTS (
                SELECT audit_log_id
                FROM audit_log
                WHERE vds_name = v_vds_name
                    AND log_type = v_log_type
                    AND NOT deleted
                )
            ) THEN
        INSERT INTO audit_log (
            LOG_TIME,
            log_type,
            log_type_name,
            severity,
            message,
            user_id,
            user_name,
            vds_id,
            vds_name,
            vm_id,
            vm_name,
            vm_template_id,
            vm_template_name,
            storage_pool_id,
            storage_pool_name,
            storage_domain_id,
            storage_domain_name,
            cluster_id,
            cluster_name,
            correlation_id,
            job_id,
            quota_id,
            quota_name,
            gluster_volume_id,
            gluster_volume_name,
            call_stack,
            brick_id,
            brick_path,
            origin,
            custom_event_id,
            event_flood_in_sec,
            custom_data
            )
        VALUES (
            v_log_time,
            v_log_type,
            v_log_type_name,
            v_severity,
            v_message,
            v_user_id,
            v_user_name,
            v_vds_id,
            v_vds_name,
            v_vm_id,
            v_vm_name,
            v_vm_template_id,
            v_vm_template_name,
            v_storage_pool_id,
            v_storage_pool_name,
            v_storage_domain_id,
            v_storage_domain_name,
            v_cluster_id,
            v_cluster_name,
            v_correlation_id,
            v_job_id,
            v_quota_id,
            v_quota_name,
            v_gluster_volume_id,
            v_gluster_volume_name,
            v_call_stack,
            v_brick_id,
            v_brick_path,
            v_origin,
            v_custom_event_id,
            v_event_flood_in_sec,
            v_custom_data
            );

            v_audit_log_id := CURRVAL('audit_log_seq');
         ELSE

            SELECT audit_log_id
            INTO v_audit_log_id
            FROM audit_log
            WHERE vds_name = v_vds_name
            AND log_type = v_log_type;
        END IF;
    END IF;
END;$$;


ALTER FUNCTION public.insertauditlog(INOUT v_audit_log_id bigint, v_log_time timestamp with time zone, v_log_type integer, v_log_type_name character varying, v_severity integer, v_message text, v_user_id uuid, v_user_name character varying, v_vds_id uuid, v_vds_name character varying, v_vm_id uuid, v_vm_name character varying, v_vm_template_id uuid, v_vm_template_name character varying, v_storage_pool_id uuid, v_storage_pool_name character varying, v_storage_domain_id uuid, v_storage_domain_name character varying, v_cluster_id uuid, v_cluster_name character varying, v_quota_id uuid, v_quota_name character varying, v_correlation_id character varying, v_job_id uuid, v_gluster_volume_id uuid, v_gluster_volume_name character varying, v_call_stack text, v_repeatable boolean, v_brick_id uuid, v_brick_path text, v_origin character varying, v_custom_event_id integer, v_event_flood_in_sec integer, v_custom_data text) OWNER TO engine;

--
-- Name: insertbasedisk(uuid, boolean, character varying, character varying, character varying, boolean, integer, smallint, character varying, smallint, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertbasedisk(v_disk_id uuid, v_wipe_after_delete boolean, v_propagate_errors character varying, v_disk_alias character varying, v_disk_description character varying, v_shareable boolean, v_sgio integer, v_disk_storage_type smallint, v_cinder_volume_type character varying, v_disk_content_type smallint, v_backup character varying, v_backup_mode character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO base_disks (
        disk_id,
        wipe_after_delete,
        propagate_errors,
        disk_alias,
        disk_description,
        shareable,
        sgio,
        disk_storage_type,
        cinder_volume_type,
        disk_content_type,
        backup,
        backup_mode
        )
    VALUES (
        v_disk_id,
        v_wipe_after_delete,
        v_propagate_errors,
        v_disk_alias,
        v_disk_description,
        v_shareable,
        v_sgio,
        v_disk_storage_type,
        v_cinder_volume_type,
        v_disk_content_type,
        v_backup,
        v_backup_mode
        );
END;$$;


ALTER FUNCTION public.insertbasedisk(v_disk_id uuid, v_wipe_after_delete boolean, v_propagate_errors character varying, v_disk_alias character varying, v_disk_description character varying, v_shareable boolean, v_sgio integer, v_disk_storage_type smallint, v_cinder_volume_type character varying, v_disk_content_type smallint, v_backup character varying, v_backup_mode character varying) OWNER TO engine;

--
-- Name: insertbookmark(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertbookmark(v_bookmark_id uuid, v_bookmark_name character varying, v_bookmark_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO bookmarks (
        bookmark_Id,
        bookmark_name,
        bookmark_value
        )
    VALUES (
        v_bookmark_id,
        v_bookmark_name,
        v_bookmark_value
        );
END;$$;


ALTER FUNCTION public.insertbookmark(v_bookmark_id uuid, v_bookmark_name character varying, v_bookmark_value character varying) OWNER TO engine;

--
-- Name: insertcinderstorage(uuid, jsonb, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcinderstorage(v_storage_domain_id uuid, v_driver_options jsonb, v_driver_sensitive_options text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cinder_storage (
        storage_domain_id,
        driver_options,
        driver_sensitive_options
        )
    VALUES (
        v_storage_domain_id,
        v_driver_options,
        v_driver_sensitive_options
        );
END;$$;


ALTER FUNCTION public.insertcinderstorage(v_storage_domain_id uuid, v_driver_options jsonb, v_driver_sensitive_options text) OWNER TO engine;

--
-- Name: insertcluster(uuid, character varying, text, character varying, character varying, text, text, uuid, integer, boolean, character varying, boolean, integer, boolean, boolean, boolean, character varying, boolean, integer, boolean, boolean, uuid, text, boolean, integer, smallint, character varying, boolean, smallint, character varying, character varying, boolean, boolean, smallint, boolean, boolean, boolean, boolean, character varying, boolean, character varying, integer, uuid, uuid, character varying, boolean, boolean, integer, uuid, integer, smallint, boolean, boolean, boolean, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcluster(v_cluster_id uuid, v_description character varying, v_free_text_comment text, v_name character varying, v_cpu_name character varying, v_cpu_flags text, v_cpu_verb text, v_storage_pool_id uuid, v_max_vds_memory_over_commit integer, v_count_threads_as_cores boolean, v_compatibility_version character varying, v_transparent_hugepages boolean, v_migrate_on_error integer, v_virt_service boolean, v_gluster_service boolean, v_tunnel_migration boolean, v_emulated_machine character varying, v_detect_emulated_machine boolean, v_bios_type integer, v_trusted_service boolean, v_ha_reservation boolean, v_cluster_policy_id uuid, v_cluster_policy_custom_properties text, v_enable_balloon boolean, v_architecture integer, v_optimization_type smallint, v_spice_proxy character varying, v_enable_ksm boolean, v_serial_number_policy smallint, v_custom_serial_number character varying, v_additional_rng_sources character varying, v_skip_fencing_if_sd_active boolean, v_skip_fencing_if_connectivity_broken boolean, v_hosts_with_broken_connectivity_threshold smallint, v_fencing_enabled boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_gluster_tuned_profile character varying, v_ksm_merge_across_nodes boolean, v_migration_bandwidth_limit_type character varying, v_custom_migration_bandwidth_limit integer, v_migration_policy_id uuid, v_mac_pool_id uuid, v_switch_type character varying, v_skip_fencing_if_gluster_bricks_up boolean, v_skip_fencing_if_gluster_quorum_not_met boolean, v_firewall_type integer, v_default_network_provider_id uuid, v_log_max_memory_used_threshold integer, v_log_max_memory_used_threshold_type smallint, v_vnc_encryption_enabled boolean, v_smt_disabled boolean, v_managed boolean, v_fips_mode smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cluster (
        cluster_id,
        description,
        name,
        free_text_comment,
        cpu_name,
        cpu_flags,
        cpu_verb,
        storage_pool_id,
        max_vds_memory_over_commit,
        count_threads_as_cores,
        compatibility_version,
        transparent_hugepages,
        migrate_on_error,
        virt_service,
        gluster_service,
        tunnel_migration,
        emulated_machine,
        detect_emulated_machine,
        bios_type,
        trusted_service,
        ha_reservation,
        cluster_policy_id,
        cluster_policy_custom_properties,
        enable_balloon,
        architecture,
        optimization_type,
        spice_proxy,
        enable_ksm,
        serial_number_policy,
        custom_serial_number,
        additional_rng_sources,
        skip_fencing_if_sd_active,
        skip_fencing_if_connectivity_broken,
        hosts_with_broken_connectivity_threshold,
        fencing_enabled,
        is_auto_converge,
        is_migrate_compressed,
        is_migrate_encrypted,
        gluster_tuned_profile,
        ksm_merge_across_nodes,
        migration_bandwidth_limit_type,
        custom_migration_bandwidth_limit,
        migration_policy_id,
        mac_pool_id,
        switch_type,
        skip_fencing_if_gluster_bricks_up,
        skip_fencing_if_gluster_quorum_not_met,
        firewall_type,
        default_network_provider_id,
        log_max_memory_used_threshold,
        log_max_memory_used_threshold_type,
        vnc_encryption_enabled,
        smt_disabled,
        managed,
        fips_mode,
        parallel_migrations
        )
    VALUES (
        v_cluster_id,
        v_description,
        v_name,
        v_free_text_comment,
        v_cpu_name,
        v_cpu_flags,
        v_cpu_verb,
        v_storage_pool_id,
        v_max_vds_memory_over_commit,
        v_count_threads_as_cores,
        v_compatibility_version,
        v_transparent_hugepages,
        v_migrate_on_error,
        v_virt_service,
        v_gluster_service,
        v_tunnel_migration,
        v_emulated_machine,
        v_detect_emulated_machine,
        v_bios_type,
        v_trusted_service,
        v_ha_reservation,
        v_cluster_policy_id,
        v_cluster_policy_custom_properties,
        v_enable_balloon,
        v_architecture,
        v_optimization_type,
        v_spice_proxy,
        v_enable_ksm,
        v_serial_number_policy,
        v_custom_serial_number,
        v_additional_rng_sources,
        v_skip_fencing_if_sd_active,
        v_skip_fencing_if_connectivity_broken,
        v_hosts_with_broken_connectivity_threshold,
        v_fencing_enabled,
        v_is_auto_converge,
        v_is_migrate_compressed,
        v_is_migrate_encrypted,
        v_gluster_tuned_profile,
        v_ksm_merge_across_nodes,
        v_migration_bandwidth_limit_type,
        v_custom_migration_bandwidth_limit,
        v_migration_policy_id,
        v_mac_pool_id,
        v_switch_type,
        v_skip_fencing_if_gluster_bricks_up,
        v_skip_fencing_if_gluster_quorum_not_met,
        v_firewall_type,
        v_default_network_provider_id,
        v_log_max_memory_used_threshold,
        v_log_max_memory_used_threshold_type,
        v_vnc_encryption_enabled,
        v_smt_disabled,
        v_managed,
        v_fips_mode,
        v_parallel_migrations
        );
END;$$;


ALTER FUNCTION public.insertcluster(v_cluster_id uuid, v_description character varying, v_free_text_comment text, v_name character varying, v_cpu_name character varying, v_cpu_flags text, v_cpu_verb text, v_storage_pool_id uuid, v_max_vds_memory_over_commit integer, v_count_threads_as_cores boolean, v_compatibility_version character varying, v_transparent_hugepages boolean, v_migrate_on_error integer, v_virt_service boolean, v_gluster_service boolean, v_tunnel_migration boolean, v_emulated_machine character varying, v_detect_emulated_machine boolean, v_bios_type integer, v_trusted_service boolean, v_ha_reservation boolean, v_cluster_policy_id uuid, v_cluster_policy_custom_properties text, v_enable_balloon boolean, v_architecture integer, v_optimization_type smallint, v_spice_proxy character varying, v_enable_ksm boolean, v_serial_number_policy smallint, v_custom_serial_number character varying, v_additional_rng_sources character varying, v_skip_fencing_if_sd_active boolean, v_skip_fencing_if_connectivity_broken boolean, v_hosts_with_broken_connectivity_threshold smallint, v_fencing_enabled boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_gluster_tuned_profile character varying, v_ksm_merge_across_nodes boolean, v_migration_bandwidth_limit_type character varying, v_custom_migration_bandwidth_limit integer, v_migration_policy_id uuid, v_mac_pool_id uuid, v_switch_type character varying, v_skip_fencing_if_gluster_bricks_up boolean, v_skip_fencing_if_gluster_quorum_not_met boolean, v_firewall_type integer, v_default_network_provider_id uuid, v_log_max_memory_used_threshold integer, v_log_max_memory_used_threshold_type smallint, v_vnc_encryption_enabled boolean, v_smt_disabled boolean, v_managed boolean, v_fips_mode smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: insertclusterfeature(uuid, character varying, character varying, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertclusterfeature(v_feature_id uuid, v_feature_name character varying, v_version character varying, v_category integer, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cluster_features (
        feature_id,
        feature_name,
        version,
        category,
        description
        )
    VALUES (
        v_feature_id,
        v_feature_name,
        v_version,
        v_category,
        v_description
        );
END;$$;


ALTER FUNCTION public.insertclusterfeature(v_feature_id uuid, v_feature_name character varying, v_version character varying, v_category integer, v_description text) OWNER TO engine;

--
-- Name: insertclusterpolicy(uuid, character varying, character varying, boolean, boolean, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertclusterpolicy(v_id uuid, v_name character varying, v_description character varying, v_is_locked boolean, v_is_default boolean, v_custom_properties text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cluster_policies (
        id,
        name,
        description,
        is_locked,
        is_default,
        custom_properties
        )
    VALUES (
        v_id,
        v_name,
        v_description,
        v_is_locked,
        v_is_default,
        v_custom_properties
        );
END;$$;


ALTER FUNCTION public.insertclusterpolicy(v_id uuid, v_name character varying, v_description character varying, v_is_locked boolean, v_is_default boolean, v_custom_properties text) OWNER TO engine;

--
-- Name: insertclusterpolicyunit(uuid, uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertclusterpolicyunit(v_cluster_policy_id uuid, v_policy_unit_id uuid, v_filter_sequence integer, v_factor integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cluster_policy_units (
        cluster_policy_id,
        policy_unit_id,
        filter_sequence,
        factor
        )
    VALUES (
        v_cluster_policy_id,
        v_policy_unit_id,
        v_filter_sequence,
        v_factor
        );
END;$$;


ALTER FUNCTION public.insertclusterpolicyunit(v_cluster_policy_id uuid, v_policy_unit_id uuid, v_filter_sequence integer, v_factor integer) OWNER TO engine;

--
-- Name: insertcommandassociatedentities(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcommandassociatedentities(v_command_id uuid, v_entity_id uuid, v_entity_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    INSERT INTO command_assoc_entities (
        command_id,
        entity_id,
        entity_type
        )
    VALUES (
        v_command_id,
        v_entity_id,
        v_entity_type
        );
END;$$;


ALTER FUNCTION public.insertcommandassociatedentities(v_command_id uuid, v_entity_id uuid, v_entity_type character varying) OWNER TO engine;

--
-- Name: insertcommandentity(uuid, bigint, uuid, integer, uuid, uuid, text, text, character varying, timestamp with time zone, character varying, boolean, boolean, text, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_created_at timestamp with time zone, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    INSERT INTO command_entities (
        user_id,
        engine_session_seq_id,
        command_id,
        command_type,
        parent_command_id,
        root_command_id,
        command_context,
        command_parameters,
        command_params_class,
        created_at,
        status,
        executed,
        callback_enabled,
        return_value,
        return_value_class,
        data
        )
    VALUES (
        v_user_id,
        v_engine_session_seq_id,
        v_command_id,
        v_command_type,
        v_parent_command_id,
        v_root_command_id,
        v_command_context,
        v_command_parameters,
        v_command_params_class,
        NOW(),
        v_status,
        v_executed,
        v_callback_enabled,
        v_return_value,
        v_return_value_class,
        v_data
        );
END;$$;


ALTER FUNCTION public.insertcommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_created_at timestamp with time zone, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) OWNER TO engine;

--
-- Name: insertcpuprofile(uuid, character varying, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcpuprofile(v_id uuid, v_name character varying, v_cluster_id uuid, v_qos_id uuid, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO cpu_profiles (
        id,
        name,
        cluster_id,
        qos_id,
        description
        )
    VALUES (
        v_id,
        v_name,
        v_cluster_id,
        v_qos_id,
        v_description
        );
END;$$;


ALTER FUNCTION public.insertcpuprofile(v_id uuid, v_name character varying, v_cluster_id uuid, v_qos_id uuid, v_description text) OWNER TO engine;

--
-- Name: insertcpuqos(uuid, smallint, character varying, text, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcpuqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_cpu_limit integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO qos (
        id,
        qos_type,
        name,
        description,
        storage_pool_id,
        cpu_limit
        )
    VALUES (
        v_id,
        v_qos_type,
        v_name,
        v_description,
        v_storage_pool_id,
        v_cpu_limit
        );
END;$$;


ALTER FUNCTION public.insertcpuqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_cpu_limit integer) OWNER TO engine;

--
-- Name: insertcustom_actions(integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertcustom_actions(INOUT v_action_id integer, v_action_name character varying, v_path character varying, v_tab integer, v_description character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO custom_actions (
        action_name,
        path,
        tab,
        description
        )
    VALUES (
        v_action_name,
        v_path,
        v_tab,
        v_description
        );

    v_action_id := CURRVAL('custom_actions_seq');
END;$$;


ALTER FUNCTION public.insertcustom_actions(INOUT v_action_id integer, v_action_name character varying, v_path character varying, v_tab integer, v_description character varying) OWNER TO engine;

--
-- Name: insertdedicatedhoststovm(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdedicatedhoststovm(v_vm_guid uuid, v_dedicated_vm_for_vds text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_host_pinning_map (
        vm_id,
        vds_id
        )
    SELECT v_vm_guid,
        vds_id
    FROM fnSplitterUuid(v_dedicated_vm_for_vds) AS vds_id;
END;$$;


ALTER FUNCTION public.insertdedicatedhoststovm(v_vm_guid uuid, v_dedicated_vm_for_vds text) OWNER TO engine;

--
-- Name: insertdisk_image_dynamic(uuid, bigint, bigint, bigint, bigint, bigint, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdisk_image_dynamic(v_image_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO disk_image_dynamic (
        image_id,
        read_rate,
        read_ops,
        write_rate,
        write_ops,
        actual_size,
        read_latency_seconds,
        write_latency_seconds,
        flush_latency_seconds
        )
    VALUES (
        v_image_id,
        v_read_rate,
        v_read_ops,
        v_write_rate,
        v_write_ops,
        v_actual_size,
        v_read_latency_seconds,
        v_write_latency_seconds,
        v_flush_latency_seconds
        );
END;$$;


ALTER FUNCTION public.insertdisk_image_dynamic(v_image_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) OWNER TO engine;

--
-- Name: insertdisklunmap(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdisklunmap(v_disk_id uuid, v_lun_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO disk_lun_map (
        disk_id,
        lun_id
        )
    VALUES (
        v_disk_id,
        v_lun_id
        );
END;$$;


ALTER FUNCTION public.insertdisklunmap(v_disk_id uuid, v_lun_id character varying) OWNER TO engine;

--
-- Name: insertdiskprofile(uuid, character varying, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdiskprofile(v_id uuid, v_name character varying, v_storage_domain_id uuid, v_qos_id uuid, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO disk_profiles (
        id,
        name,
        storage_domain_id,
        qos_id,
        description
        )
    VALUES (
        v_id,
        v_name,
        v_storage_domain_id,
        v_qos_id,
        v_description
        );
END;$$;


ALTER FUNCTION public.insertdiskprofile(v_id uuid, v_name character varying, v_storage_domain_id uuid, v_qos_id uuid, v_description text) OWNER TO engine;

--
-- Name: insertdiskvmelement(uuid, uuid, boolean, boolean, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdiskvmelement(v_disk_id uuid, v_vm_id uuid, v_is_boot boolean, v_pass_discard boolean, v_disk_interface character varying, v_is_using_scsi_reservation boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO disk_vm_element (
        disk_id,
        vm_id,
        is_boot,
        pass_discard,
        disk_interface,
        is_using_scsi_reservation)
    VALUES (
        v_disk_id,
        v_vm_id,
        v_is_boot,
        v_pass_discard,
        v_disk_interface,
        v_is_using_scsi_reservation);
END; $$;


ALTER FUNCTION public.insertdiskvmelement(v_disk_id uuid, v_vm_id uuid, v_is_boot boolean, v_pass_discard boolean, v_disk_interface character varying, v_is_using_scsi_reservation boolean) OWNER TO engine;

--
-- Name: insertdnsresolverconfiguration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertdnsresolverconfiguration(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO dns_resolver_configuration (id)
    VALUES (v_id);
END;$$;


ALTER FUNCTION public.insertdnsresolverconfiguration(v_id uuid) OWNER TO engine;

--
-- Name: insertenginesession(integer, text, uuid, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertenginesession(INOUT v_id integer, v_engine_session_id text, v_user_id uuid, v_user_name character varying, v_authz_name character varying, v_source_ip character varying, v_group_ids character varying, v_role_ids character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO engine_sessions (
        engine_session_id,
        user_id,
        user_name,
        authz_name,
        source_ip,
        group_ids,
        role_ids
        )
    VALUES (
        v_engine_session_id,
        v_user_id,
        v_user_name,
        v_authz_name,
        v_source_ip,
        v_group_ids,
        v_role_ids
        );

    v_id := CURRVAL('engine_session_seq');
END;$$;


ALTER FUNCTION public.insertenginesession(INOUT v_id integer, v_engine_session_id text, v_user_id uuid, v_user_name character varying, v_authz_name character varying, v_source_ip character varying, v_group_ids character varying, v_role_ids character varying) OWNER TO engine;

--
-- Name: insertevent_notification_hist(bigint, character varying, character, character, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertevent_notification_hist(v_audit_log_id bigint, v_event_name character varying, v_method_type character, v_reason character, v_sent_at timestamp with time zone, v_status boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO event_notification_hist (
        audit_log_id,
        event_name,
        method_type,
        reason,
        sent_at,
        status
        )
    VALUES (
        v_audit_log_id,
        v_event_name,
        v_method_type,
        v_reason,
        v_sent_at,
        v_status
        );
END;$$;


ALTER FUNCTION public.insertevent_notification_hist(v_audit_log_id bigint, v_event_name character varying, v_method_type character, v_reason character, v_sent_at timestamp with time zone, v_status boolean) OWNER TO engine;

--
-- Name: insertevent_subscriber(character varying, character varying, character varying, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertevent_subscriber(v_event_up_name character varying, v_notification_method character varying, v_method_address character varying, v_subscriber_id uuid, v_tag_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NOT EXISTS (
            SELECT *
            FROM event_subscriber
            WHERE subscriber_id = v_subscriber_id
                AND event_up_name = v_event_up_name
                AND notification_method = v_notification_method
                AND tag_name = v_tag_name
            ) THEN
        INSERT INTO event_subscriber (
            event_up_name,
            notification_method,
            method_address,
            subscriber_id,
            tag_name
            )
        VALUES (
            v_event_up_name,
            v_notification_method,
            v_method_address,
            v_subscriber_id,
            v_tag_name
            );
    END IF;

END;$$;


ALTER FUNCTION public.insertevent_subscriber(v_event_up_name character varying, v_notification_method character varying, v_method_address character varying, v_subscriber_id uuid, v_tag_name character varying) OWNER TO engine;

--
-- Name: insertexternallease(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertexternallease(v_storage_domain_id uuid, v_lease_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO external_leases (
        storage_domain_id,
        lease_id
        )
    VALUES (
        v_storage_domain_id,
        v_lease_id
        );
END;$$;


ALTER FUNCTION public.insertexternallease(v_storage_domain_id uuid, v_lease_id uuid) OWNER TO engine;

--
-- Name: insertexternalvariable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertexternalvariable(v_var_name character varying, v_var_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO external_variable (
        var_name,
        var_value
        )
    VALUES (
        v_var_name,
        v_var_value
        );
END;$$;


ALTER FUNCTION public.insertexternalvariable(v_var_name character varying, v_var_value character varying) OWNER TO engine;

--
-- Name: insertfenceagent(uuid, uuid, integer, character varying, character varying, character varying, text, text, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertfenceagent(v_id uuid, v_vds_id uuid, v_agent_order integer, v_ip character varying, v_type character varying, v_agent_user character varying, v_agent_password text, v_options text, v_encrypt_options boolean, v_port integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO fence_agents (
        id,
        vds_id,
        agent_order,
        ip,
        type,
        agent_user,
        agent_password,
        options,
        encrypt_options,
        port
        )
    VALUES (
        v_id,
        v_vds_id,
        v_agent_order,
        v_ip,
        v_type,
        v_agent_user,
        v_agent_password,
        v_options,
        v_encrypt_options,
        v_port
        );
END;$$;


ALTER FUNCTION public.insertfenceagent(v_id uuid, v_vds_id uuid, v_agent_order integer, v_ip character varying, v_type character varying, v_agent_user character varying, v_agent_password text, v_options text, v_encrypt_options boolean, v_port integer) OWNER TO engine;

--
-- Name: insertglusterclusterservice(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterclusterservice(v_cluster_id uuid, v_service_type character varying, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_cluster_services (
        cluster_id,
        service_type,
        status
        )
    VALUES (
        v_cluster_id,
        v_service_type,
        v_status
        );
END;$$;


ALTER FUNCTION public.insertglusterclusterservice(v_cluster_id uuid, v_service_type character varying, v_status character varying) OWNER TO engine;

--
-- Name: insertglustergeorepsession(uuid, uuid, character varying, character varying, uuid, character varying, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustergeorepsession(v_session_id uuid, v_master_volume_id uuid, v_session_key character varying, v_slave_host_name character varying, v_slave_host_uuid uuid, v_slave_volume_name character varying, v_slave_volume_id uuid, v_status character varying, v_user_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_georep_session (
        session_id,
        master_volume_id,
        session_key,
        slave_host_name,
        slave_host_uuid,
        slave_volume_name,
        slave_volume_id,
        status,
        user_name
        )
    VALUES (
        v_session_id,
        v_master_volume_id,
        v_session_key,
        v_slave_host_name,
        v_slave_host_uuid,
        v_slave_volume_name,
        v_slave_volume_id,
        v_status,
        v_user_name
        );
END;$$;


ALTER FUNCTION public.insertglustergeorepsession(v_session_id uuid, v_master_volume_id uuid, v_session_key character varying, v_slave_host_name character varying, v_slave_host_uuid uuid, v_slave_volume_name character varying, v_slave_volume_id uuid, v_status character varying, v_user_name character varying) OWNER TO engine;

--
-- Name: insertglustergeorepsessionconfig(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustergeorepsessionconfig(v_session_id uuid, v_config_key character varying, v_config_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_georep_config (
        session_id,
        config_key,
        config_value
        )
    VALUES (
        v_session_id,
        v_config_key,
        v_config_value
        );
END;$$;


ALTER FUNCTION public.insertglustergeorepsessionconfig(v_session_id uuid, v_config_key character varying, v_config_value character varying) OWNER TO engine;

--
-- Name: insertglustergeorepsessiondetail(uuid, uuid, character varying, uuid, character varying, character varying, character varying, bigint, bigint, bigint, bigint, timestamp without time zone, timestamp without time zone, timestamp without time zone, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustergeorepsessiondetail(v_session_id uuid, v_master_brick_id uuid, v_slave_host_name character varying, v_slave_host_uuid uuid, v_status character varying, v_checkpoint_status character varying, v_crawl_status character varying, v_data_pending bigint, v_entry_pending bigint, v_meta_pending bigint, v_failures bigint, v_last_synced_at timestamp without time zone, v_checkpoint_time timestamp without time zone, v_checkpoint_completed_time timestamp without time zone, v_is_checkpoint_completed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_georep_session_details (
        session_id,
        master_brick_id,
        slave_host_name,
        slave_host_uuid,
        status,
        checkpoint_status,
        crawl_status,
        data_pending,
        entry_pending,
        meta_pending,
        failures,
        last_synced_at,
        checkpoint_time,
        checkpoint_completed_time,
        is_checkpoint_completed
        )
    VALUES (
        v_session_id,
        v_master_brick_id,
        v_slave_host_name,
        v_slave_host_uuid,
        v_status,
        v_checkpoint_status,
        v_crawl_status,
        v_data_pending,
        v_entry_pending,
        v_meta_pending,
        v_failures,
        v_last_synced_at,
        v_checkpoint_time,
        v_checkpoint_completed_time,
        v_is_checkpoint_completed
        );
END;$$;


ALTER FUNCTION public.insertglustergeorepsessiondetail(v_session_id uuid, v_master_brick_id uuid, v_slave_host_name character varying, v_slave_host_uuid uuid, v_status character varying, v_checkpoint_status character varying, v_crawl_status character varying, v_data_pending bigint, v_entry_pending bigint, v_meta_pending bigint, v_failures bigint, v_last_synced_at timestamp without time zone, v_checkpoint_time timestamp without time zone, v_checkpoint_completed_time timestamp without time zone, v_is_checkpoint_completed boolean) OWNER TO engine;

--
-- Name: insertglusterglobalvolumeoption(uuid, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterglobalvolumeoption(v_id uuid, v_cluster_id uuid, v_option_key character varying, v_option_val character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_global_volume_options (
        id,
        cluster_id,
        option_key,
        option_val
        )
    VALUES (
        v_id,
        v_cluster_id,
        v_option_key,
        v_option_val
        );
END;$$;


ALTER FUNCTION public.insertglusterglobalvolumeoption(v_id uuid, v_cluster_id uuid, v_option_key character varying, v_option_val character varying) OWNER TO engine;

--
-- Name: insertglusterhook(uuid, uuid, character varying, character varying, character varying, character varying, character varying, character varying, text, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterhook(v_id uuid, v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying, v_hook_status character varying, v_content_type character varying, v_checksum character varying, v_content text, v_conflict_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_hooks (
        id,
        cluster_id,
        gluster_command,
        stage,
        name,
        hook_status,
        content_type,
        checksum,
        content,
        conflict_status
        )
    VALUES (
        v_id,
        v_cluster_id,
        v_gluster_command,
        v_stage,
        v_name,
        v_hook_status,
        v_content_type,
        v_checksum,
        v_content,
        v_conflict_status
        );
END;$$;


ALTER FUNCTION public.insertglusterhook(v_id uuid, v_cluster_id uuid, v_gluster_command character varying, v_stage character varying, v_name character varying, v_hook_status character varying, v_content_type character varying, v_checksum character varying, v_content text, v_conflict_status integer) OWNER TO engine;

--
-- Name: insertglusterserver(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterserver(v_server_id uuid, v_gluster_server_uuid uuid, v_peer_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_server (
        server_id,
        gluster_server_uuid,
        peer_status
        )
    VALUES (
        v_server_id,
        v_gluster_server_uuid,
        v_peer_status
        );
END;$$;


ALTER FUNCTION public.insertglusterserver(v_server_id uuid, v_gluster_server_uuid uuid, v_peer_status character varying) OWNER TO engine;

--
-- Name: insertglusterserverhook(uuid, uuid, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterserverhook(v_hook_id uuid, v_server_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_server_hooks (
        hook_id,
        server_id,
        hook_status,
        content_type,
        checksum
        )
    VALUES (
        v_hook_id,
        v_server_id,
        v_hook_status,
        v_content_type,
        v_checksum
        );

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id = v_hook_id;
END;$$;


ALTER FUNCTION public.insertglusterserverhook(v_hook_id uuid, v_server_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying) OWNER TO engine;

--
-- Name: insertglusterserverservice(uuid, uuid, uuid, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglusterserverservice(v_id uuid, v_server_id uuid, v_service_id uuid, v_pid integer, v_status character varying, v_message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_server_services (
        id,
        server_id,
        service_id,
        pid,
        status,
        message
        )
    VALUES (
        v_id,
        v_server_id,
        v_service_id,
        v_pid,
        v_status,
        v_message
        );
END;$$;


ALTER FUNCTION public.insertglusterserverservice(v_id uuid, v_server_id uuid, v_service_id uuid, v_pid integer, v_status character varying, v_message character varying) OWNER TO engine;

--
-- Name: insertglustervolume(uuid, uuid, character varying, character varying, character varying, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolume(v_id uuid, v_cluster_id uuid, v_vol_name character varying, v_vol_type character varying, v_status character varying, v_replica_count integer, v_stripe_count integer, v_disperse_count integer, v_redundancy_count integer, v_is_arbiter boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volumes (
        id,
        cluster_id,
        vol_name,
        vol_type,
        status,
        replica_count,
        stripe_count,
        disperse_count,
        redundancy_count,
        is_arbiter
        )
    VALUES (
        v_id,
        v_cluster_id,
        v_vol_name,
        v_vol_type,
        v_status,
        v_replica_count,
        v_stripe_count,
        v_disperse_count,
        v_redundancy_count,
        v_is_arbiter
        );
END;$$;


ALTER FUNCTION public.insertglustervolume(v_id uuid, v_cluster_id uuid, v_vol_name character varying, v_vol_type character varying, v_status character varying, v_replica_count integer, v_stripe_count integer, v_disperse_count integer, v_redundancy_count integer, v_is_arbiter boolean) OWNER TO engine;

--
-- Name: insertglustervolumeaccessprotocol(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumeaccessprotocol(v_volume_id uuid, v_access_protocol character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_access_protocols (
        volume_id,
        access_protocol
        )
    VALUES (
        v_volume_id,
        v_access_protocol
        );
END;$$;


ALTER FUNCTION public.insertglustervolumeaccessprotocol(v_volume_id uuid, v_access_protocol character varying) OWNER TO engine;

--
-- Name: insertglustervolumebrick(uuid, uuid, uuid, character varying, integer, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumebrick(v_id uuid, v_volume_id uuid, v_server_id uuid, v_brick_dir character varying, v_brick_order integer, v_status character varying, v_network_id uuid, v_is_arbiter boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_bricks (
        id,
        volume_id,
        server_id,
        brick_dir,
        brick_order,
        status,
        network_id,
        is_arbiter
        )
    VALUES (
        v_id,
        v_volume_id,
        v_server_id,
        v_brick_dir,
        v_brick_order,
        v_status,
        v_network_id,
        v_is_arbiter
        );
END;$$;


ALTER FUNCTION public.insertglustervolumebrick(v_id uuid, v_volume_id uuid, v_server_id uuid, v_brick_dir character varying, v_brick_order integer, v_status character varying, v_network_id uuid, v_is_arbiter boolean) OWNER TO engine;

--
-- Name: insertglustervolumebrickdetails(uuid, bigint, bigint, bigint, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumebrickdetails(v_brick_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_confirmed_total_space bigint, v_vdo_savings integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_brick_details (
        brick_id,
        total_space,
        used_space,
        free_space,
        confirmed_free_space,
        confirmed_total_space,
        vdo_savings,
        _update_date
        )
    VALUES (
        v_brick_id,
        v_total_space,
        v_used_space,
        v_free_space,
        v_confirmed_free_space,
        v_confirmed_total_space,
        v_vdo_savings,
        LOCALTIMESTAMP
        );
END;$$;


ALTER FUNCTION public.insertglustervolumebrickdetails(v_brick_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_confirmed_total_space bigint, v_vdo_savings integer) OWNER TO engine;

--
-- Name: insertglustervolumedetails(uuid, bigint, bigint, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumedetails(v_volume_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_vdo_savings integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_details (
        volume_id,
        total_space,
        used_space,
        free_space,
        confirmed_free_space,
        vdo_savings,
        _update_date
        )
    VALUES (
        v_volume_id,
        v_total_space,
        v_used_space,
        v_free_space,
        v_confirmed_free_space,
        v_vdo_savings,
        LOCALTIMESTAMP
        );
END;$$;


ALTER FUNCTION public.insertglustervolumedetails(v_volume_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_vdo_savings integer) OWNER TO engine;

--
-- Name: insertglustervolumeoption(uuid, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumeoption(v_id uuid, v_volume_id uuid, v_option_key character varying, v_option_val character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_options (
        id,
        volume_id,
        option_key,
        option_val
        )
    VALUES (
        v_id,
        v_volume_id,
        v_option_key,
        v_option_val
        );
END;$$;


ALTER FUNCTION public.insertglustervolumeoption(v_id uuid, v_volume_id uuid, v_option_key character varying, v_option_val character varying) OWNER TO engine;

--
-- Name: insertglustervolumesnapshot(uuid, character varying, uuid, character varying, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumesnapshot(v_snapshot_id uuid, v_snapshot_name character varying, v_volume_id uuid, v_description character varying, v_status character varying, v__create_date timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_snapshots (
        snapshot_id,
        snapshot_name,
        volume_id,
        description,
        status,
        _create_date
        )
    VALUES (
        v_snapshot_id,
        v_snapshot_name,
        v_volume_id,
        v_description,
        v_status,
        v__create_date
        );

    PERFORM UpdateSnapshotCountInc(v_volume_id, 1);
END;$$;


ALTER FUNCTION public.insertglustervolumesnapshot(v_snapshot_id uuid, v_snapshot_name character varying, v_volume_id uuid, v_description character varying, v_status character varying, v__create_date timestamp with time zone) OWNER TO engine;

--
-- Name: insertglustervolumesnapshotconfig(uuid, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumesnapshotconfig(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying, v_param_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_snapshot_config (
        cluster_id,
        volume_id,
        param_name,
        param_value
        )
    VALUES (
        v_cluster_id,
        v_volume_id,
        v_param_name,
        v_param_value
        );
END;$$;


ALTER FUNCTION public.insertglustervolumesnapshotconfig(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying, v_param_value character varying) OWNER TO engine;

--
-- Name: insertglustervolumesnapshotschedule(uuid, character varying, character varying, character varying, character varying, character varying, integer, timestamp with time zone, time without time zone, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumesnapshotschedule(v_volume_id uuid, v_job_id character varying, v_snapshot_name_prefix character varying, v_snapshot_description character varying, v_recurrence character varying, v_time_zone character varying, v_interval integer, v_start_date timestamp with time zone, v_execution_time time without time zone, v_days character varying, v_end_by timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_snapshot_schedules (
        volume_id,
        job_id,
        snapshot_name_prefix,
        snapshot_description,
        recurrence,
        time_zone,
        interval,
        start_date,
        execution_time,
        days,
        end_by
        )
    VALUES (
        v_volume_id,
        v_job_id,
        v_snapshot_name_prefix,
        v_snapshot_description,
        v_recurrence,
        v_time_zone,
        v_interval,
        v_start_date,
        v_execution_time,
        v_days,
        v_end_by
        );

    UPDATE gluster_volumes
    SET snapshot_scheduled = true
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.insertglustervolumesnapshotschedule(v_volume_id uuid, v_job_id character varying, v_snapshot_name_prefix character varying, v_snapshot_description character varying, v_recurrence character varying, v_time_zone character varying, v_interval integer, v_start_date timestamp with time zone, v_execution_time time without time zone, v_days character varying, v_end_by timestamp with time zone) OWNER TO engine;

--
-- Name: insertglustervolumetransporttype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertglustervolumetransporttype(v_volume_id uuid, v_transport_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_volume_transport_types (
        volume_id,
        transport_type
        )
    VALUES (
        v_volume_id,
        v_transport_type
        );
END;$$;


ALTER FUNCTION public.insertglustervolumetransporttype(v_volume_id uuid, v_transport_type character varying) OWNER TO engine;

--
-- Name: insertgroup(uuid, character varying, character varying, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertgroup(v_id uuid, v_name character varying, v_domain character varying, v_distinguishedname character varying, v_external_id text, v_namespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO ad_groups (
        id,
        name,
        domain,
        distinguishedname,
        external_id,
        namespace
        )
    VALUES (
        v_id,
        v_name,
        v_domain,
        v_distinguishedname,
        v_external_id,
        v_namespace
        );
END;$$;


ALTER FUNCTION public.insertgroup(v_id uuid, v_name character varying, v_domain character varying, v_distinguishedname character varying, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: inserthostdevice(uuid, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying, boolean, character varying, text, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserthostdevice(v_host_id uuid, v_device_name character varying, v_parent_device_name character varying, v_capability character varying, v_iommu_group integer, v_product_name character varying, v_product_id character varying, v_vendor_name character varying, v_vendor_id character varying, v_physfn character varying, v_total_vfs integer, v_net_iface_name character varying, v_driver character varying, v_is_assignable boolean, v_address character varying, v_mdev_types text, v_block_path text, v_hostdev_spec_params text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    SET CONSTRAINTS ALL DEFERRED;

    INSERT INTO host_device (
        host_id,
        device_name,
        parent_device_name,
        capability,
        iommu_group,
        product_name,
        product_id,
        vendor_name,
        vendor_id,
        physfn,
        total_vfs,
        net_iface_name,
        driver,
        is_assignable,
        address,
        mdev_types,
        block_path,
        hostdev_spec_params
        )
    VALUES (
        v_host_id,
        v_device_name,
        v_parent_device_name,
        v_capability,
        v_iommu_group,
        v_product_name,
        v_product_id,
        v_vendor_name,
        v_vendor_id,
        v_physfn,
        v_total_vfs,
        v_net_iface_name,
        v_driver,
        v_is_assignable,
        v_address,
        v_mdev_types,
        v_block_path,
        v_hostdev_spec_params
        );
END;$$;


ALTER FUNCTION public.inserthostdevice(v_host_id uuid, v_device_name character varying, v_parent_device_name character varying, v_capability character varying, v_iommu_group integer, v_product_name character varying, v_product_id character varying, v_vendor_name character varying, v_vendor_id character varying, v_physfn character varying, v_total_vfs integer, v_net_iface_name character varying, v_driver character varying, v_is_assignable boolean, v_address character varying, v_mdev_types text, v_block_path text, v_hostdev_spec_params text) OWNER TO engine;

--
-- Name: inserthostnetworkqos(uuid, smallint, character varying, text, uuid, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserthostnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_out_average_linkshare integer, v_out_average_upperlimit integer, v_out_average_realtime integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO qos (
        id,
        qos_type,
        name,
        description,
        storage_pool_id,
        out_average_linkshare,
        out_average_upperlimit,
        out_average_realtime
        )
    VALUES (
        v_id,
        v_qos_type,
        v_name,
        v_description,
        v_storage_pool_id,
        v_out_average_linkshare,
        v_out_average_upperlimit,
        v_out_average_realtime
        );
END;$$;


ALTER FUNCTION public.inserthostnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_out_average_linkshare integer, v_out_average_upperlimit integer, v_out_average_realtime integer) OWNER TO engine;

--
-- Name: inserthostnicvfsconfig(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserthostnicvfsconfig(v_id uuid, v_nic_id uuid, v_is_all_networks_allowed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO host_nic_vfs_config (
        id,
        nic_id,
        is_all_networks_allowed
        )
    VALUES (
        v_id,
        v_nic_id,
        v_is_all_networks_allowed
        );
END;$$;


ALTER FUNCTION public.inserthostnicvfsconfig(v_id uuid, v_nic_id uuid, v_is_all_networks_allowed boolean) OWNER TO engine;

--
-- Name: insertimage(timestamp with time zone, uuid, uuid, bigint, uuid, integer, timestamp with time zone, uuid, integer, integer, uuid, boolean, smallint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertimage(v_creation_date timestamp with time zone, v_image_guid uuid, v_it_guid uuid, v_size bigint, v_parentid uuid, v_imagestatus integer, v_lastmodified timestamp with time zone, v_vm_snapshot_id uuid, v_volume_type integer, v_volume_format integer, v_image_group_id uuid, v_active boolean, v_volume_classification smallint, v_sequence_number integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO images (
        creation_date,
        image_guid,
        it_guid,
        size,
        ParentId,
        imageStatus,
        lastModified,
        vm_snapshot_id,
        volume_type,
        image_group_id,
        volume_format,
        active,
        volume_classification,
        sequence_number
        )
    VALUES (
        v_creation_date,
        v_image_guid,
        v_it_guid,
        v_size,
        v_ParentId,
        v_imageStatus,
        v_lastModified,
        v_vm_snapshot_id,
        v_volume_type,
        v_image_group_id,
        v_volume_format,
        v_active,
        v_volume_classification,
        v_sequence_number
        );
END;$$;


ALTER FUNCTION public.insertimage(v_creation_date timestamp with time zone, v_image_guid uuid, v_it_guid uuid, v_size bigint, v_parentid uuid, v_imagestatus integer, v_lastmodified timestamp with time zone, v_vm_snapshot_id uuid, v_volume_type integer, v_volume_format integer, v_image_group_id uuid, v_active boolean, v_volume_classification smallint, v_sequence_number integer) OWNER TO engine;

--
-- Name: insertimage_storage_domain_map(uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertimage_storage_domain_map(v_image_id uuid, v_storage_domain_id uuid, v_quota_id uuid, v_disk_profile_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO image_storage_domain_map (
        image_id,
        storage_domain_id,
        quota_id,
        disk_profile_id
        )
    VALUES (
        v_image_id,
        v_storage_domain_id,
        v_quota_id,
        v_disk_profile_id
        );
END;$$;


ALTER FUNCTION public.insertimage_storage_domain_map(v_image_id uuid, v_storage_domain_id uuid, v_quota_id uuid, v_disk_profile_id uuid) OWNER TO engine;

--
-- Name: insertimageuploads(uuid, integer, integer, integer, boolean, timestamp without time zone, character varying, uuid, uuid, uuid, character varying, character varying, bigint, bigint, integer, character varying, integer, integer, uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertimageuploads(v_command_id uuid, v_command_type integer, v_phase integer, v_type integer, v_active boolean, v_last_updated timestamp without time zone, v_message character varying, v_vds_id uuid, v_disk_id uuid, v_imaged_ticket_id uuid, v_proxy_uri character varying, v_daemon_uri character varying, v_bytes_sent bigint, v_bytes_total bigint, v_client_inactivity_timeout integer, v_timeout_policy character varying, v_image_format integer, v_backend integer, v_backup_id uuid, v_client_type integer, v_shallow boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO image_transfers(
        command_id,
        command_type,
        phase,
        type,
        active,
        last_updated,
        message,
        vds_id,
        disk_id,
        imaged_ticket_id,
        proxy_uri,
        daemon_uri,
        bytes_sent,
        bytes_total,
        client_inactivity_timeout,
        timeout_policy,
        image_format,
        backend,
        backup_id,
        client_type,
        shallow
        )
    VALUES (
        v_command_id,
        v_command_type,
        v_phase,
        v_type,
        v_active,
        v_last_updated,
        v_message,
        v_vds_id,
        v_disk_id,
        v_imaged_ticket_id,
        v_proxy_uri,
        v_daemon_uri,
        v_bytes_sent,
        v_bytes_total,
        v_client_inactivity_timeout,
        v_timeout_policy,
        v_image_format,
        v_backend,
        v_backup_id,
        v_client_type,
        v_shallow
        );
END;$$;


ALTER FUNCTION public.insertimageuploads(v_command_id uuid, v_command_type integer, v_phase integer, v_type integer, v_active boolean, v_last_updated timestamp without time zone, v_message character varying, v_vds_id uuid, v_disk_id uuid, v_imaged_ticket_id uuid, v_proxy_uri character varying, v_daemon_uri character varying, v_bytes_sent bigint, v_bytes_total bigint, v_client_inactivity_timeout integer, v_timeout_policy character varying, v_image_format integer, v_backend integer, v_backup_id uuid, v_client_type integer, v_shallow boolean) OWNER TO engine;

--
-- Name: insertiscsibond(uuid, character varying, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertiscsibond(v_id uuid, v_name character varying, v_description character varying, v_storage_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO iscsi_bonds (
        id,
        name,
        description,
        storage_pool_id
        )
    VALUES (
        v_id,
        v_name,
        v_description,
        v_storage_pool_id
        );
END;$$;


ALTER FUNCTION public.insertiscsibond(v_id uuid, v_name character varying, v_description character varying, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: insertjob(uuid, character varying, text, character varying, uuid, bigint, boolean, timestamp with time zone, timestamp with time zone, timestamp with time zone, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertjob(v_job_id uuid, v_action_type character varying, v_description text, v_status character varying, v_owner_id uuid, v_engine_session_seq_id bigint, v_visible boolean, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_last_update_time timestamp with time zone, v_correlation_id character varying, v_is_external boolean, v_is_auto_cleared boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO job (
        job_id,
        action_type,
        description,
        status,
        owner_id,
        engine_session_seq_id,
        visible,
        start_time,
        end_time,
        last_update_time,
        correlation_id,
        is_external,
        is_auto_cleared
        )
    VALUES (
        v_job_id,
        v_action_type,
        v_description,
        v_status,
        v_owner_id,
        v_engine_session_seq_id,
        v_visible,
        v_start_time,
        v_end_time,
        v_last_update_time,
        v_correlation_id,
        v_is_external,
        v_is_auto_cleared
        );
END;$$;


ALTER FUNCTION public.insertjob(v_job_id uuid, v_action_type character varying, v_description text, v_status character varying, v_owner_id uuid, v_engine_session_seq_id bigint, v_visible boolean, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_last_update_time timestamp with time zone, v_correlation_id character varying, v_is_external boolean, v_is_auto_cleared boolean) OWNER TO engine;

--
-- Name: insertjobparams(uuid, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertjobparams(v_id uuid, v_job_id uuid, v_params_class_name character varying, v_params_class_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_scheduler_job_params (
        id,
        job_id,
        params_class_name,
        params_class_value
        )
    VALUES (
        v_id,
        v_job_id,
        v_params_class_name,
        v_params_class_value
        );
END;$$;


ALTER FUNCTION public.insertjobparams(v_id uuid, v_job_id uuid, v_params_class_name character varying, v_params_class_value character varying) OWNER TO engine;

--
-- Name: insertjobsubjectentity(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertjobsubjectentity(v_job_id uuid, v_entity_id uuid, v_entity_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO job_subject_entity (
        job_id,
        entity_id,
        entity_type
        )
    VALUES (
        v_job_id,
        v_entity_id,
        v_entity_type
        );
END;$$;


ALTER FUNCTION public.insertjobsubjectentity(v_job_id uuid, v_entity_id uuid, v_entity_type character varying) OWNER TO engine;

--
-- Name: insertlibvirtsecret(uuid, text, integer, text, uuid, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertlibvirtsecret(v_secret_id uuid, v_secret_value text, v_secret_usage_type integer, v_secret_description text, v_provider_id uuid, v__create_date timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO libvirt_secrets (
        secret_id,
        secret_value,
        secret_usage_type,
        secret_description,
        provider_id,
        _create_date
        )
    VALUES (
        v_secret_id,
        v_secret_value,
        v_secret_usage_type,
        v_secret_description,
        v_provider_id,
        v__create_date
        );
END;$$;


ALTER FUNCTION public.insertlibvirtsecret(v_secret_id uuid, v_secret_value text, v_secret_usage_type integer, v_secret_description text, v_provider_id uuid, v__create_date timestamp with time zone) OWNER TO engine;

--
-- Name: insertlun_storage_server_connection_map(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertlun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO LUN_storage_server_connection_map (
        LUN_id,
        storage_server_connection
        )
    VALUES (
        v_LUN_id,
        v_storage_server_connection
        );
END;$$;


ALTER FUNCTION public.insertlun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) OWNER TO engine;

--
-- Name: insertluns(character varying, character varying, character varying, character varying, integer, character varying, character varying, integer, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertluns(v_lun_id character varying, v_physical_volume_id character varying, v_volume_group_id character varying, v_serial character varying, v_lun_mapping integer, v_vendor_id character varying, v_product_id character varying, v_device_size integer, v_discard_max_size bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO LUNs (
        LUN_id,
        physical_volume_id,
        volume_group_id,
        serial,
        lun_mapping,
        vendor_id,
        product_id,
        device_size,
        discard_max_size
        )
    VALUES (
        v_LUN_id,
        v_physical_volume_id,
        v_volume_group_id,
        v_serial,
        v_lun_mapping,
        v_vendor_id,
        v_product_id,
        v_device_size,
        v_discard_max_size
        );
END;$$;


ALTER FUNCTION public.insertluns(v_lun_id character varying, v_physical_volume_id character varying, v_volume_group_id character varying, v_serial character varying, v_lun_mapping integer, v_vendor_id character varying, v_product_id character varying, v_device_size integer, v_discard_max_size bigint) OWNER TO engine;

--
-- Name: insertmacpool(uuid, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertmacpool(v_id uuid, v_name character varying, v_allow_duplicate_mac_addresses boolean, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO mac_pools (
        id,
        name,
        allow_duplicate_mac_addresses,
        description
        )
    VALUES (
        v_id,
        v_name,
        v_allow_duplicate_mac_addresses,
        v_description
        );
END;$$;


ALTER FUNCTION public.insertmacpool(v_id uuid, v_name character varying, v_allow_duplicate_mac_addresses boolean, v_description character varying) OWNER TO engine;

--
-- Name: insertmacpoolrange(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertmacpoolrange(v_mac_pool_id uuid, v_from_mac character varying, v_to_mac character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO mac_pool_ranges (
        mac_pool_id,
        from_mac,
        to_mac
        )
    VALUES (
        v_mac_pool_id,
        v_from_mac,
        v_to_mac
        );
END;$$;


ALTER FUNCTION public.insertmacpoolrange(v_mac_pool_id uuid, v_from_mac character varying, v_to_mac character varying) OWNER TO engine;

--
-- Name: insertnameserver(uuid, character varying, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnameserver(v_dns_resolver_configuration_id uuid, v_address character varying, v_position smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO
    name_server(
      address,
      position,
      dns_resolver_configuration_id)
    VALUES (
      v_address,
      v_position,
      v_dns_resolver_configuration_id);

END;$$;


ALTER FUNCTION public.insertnameserver(v_dns_resolver_configuration_id uuid, v_address character varying, v_position smallint) OWNER TO engine;

--
-- Name: insertnetwork(character varying, character varying, text, uuid, character varying, character varying, character varying, character varying, integer, integer, boolean, uuid, integer, boolean, uuid, text, uuid, uuid, text, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnetwork(v_addr character varying, v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_vdsm_name character varying, v_subnet character varying, v_gateway character varying, v_type integer, v_vlan_id integer, v_stp boolean, v_storage_pool_id uuid, v_mtu integer, v_vm_network boolean, v_provider_network_provider_id uuid, v_provider_network_external_id text, v_provider_physical_network_id uuid, v_qos_id uuid, v_label text, v_dns_resolver_configuration_id uuid, v_port_isolation boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO network (
        addr,
        description,
        free_text_comment,
        id,
        name,
        vdsm_name,
        subnet,
        gateway,
        type,
        vlan_id,
        stp,
        storage_pool_id,
        mtu,
        vm_network,
        provider_network_provider_id,
        provider_network_external_id,
        provider_physical_network_id,
        qos_id,
        label,
        dns_resolver_configuration_id,
        port_isolation
        )
    VALUES (
        v_addr,
        v_description,
        v_free_text_comment,
        v_id,
        v_name,
        v_vdsm_name,
        v_subnet,
        v_gateway,
        v_type,
        v_vlan_id,
        v_stp,
        v_storage_pool_id,
        v_mtu,
        v_vm_network,
        v_provider_network_provider_id,
        v_provider_network_external_id,
        v_provider_physical_network_id,
        v_qos_id,
        v_label,
        v_dns_resolver_configuration_id,
        v_port_isolation
        );
END;$$;


ALTER FUNCTION public.insertnetwork(v_addr character varying, v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_vdsm_name character varying, v_subnet character varying, v_gateway character varying, v_type integer, v_vlan_id integer, v_stp boolean, v_storage_pool_id uuid, v_mtu integer, v_vm_network boolean, v_provider_network_provider_id uuid, v_provider_network_external_id text, v_provider_physical_network_id uuid, v_qos_id uuid, v_label text, v_dns_resolver_configuration_id uuid, v_port_isolation boolean) OWNER TO engine;

--
-- Name: insertnetwork_cluster(uuid, uuid, integer, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnetwork_cluster(v_cluster_id uuid, v_network_id uuid, v_status integer, v_is_display boolean, v_required boolean, v_migration boolean, v_management boolean, v_is_gluster boolean, v_default_route boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO network_cluster (
        cluster_id,
        network_id,
        status,
        is_display,
        required,
        migration,
        management,
        is_gluster,
        default_route
        )
    VALUES (
        v_cluster_id,
        v_network_id,
        v_status,
        v_is_display,
        v_required,
        v_migration,
        v_management,
        v_is_gluster,
        v_default_route
        );
END;$$;


ALTER FUNCTION public.insertnetwork_cluster(v_cluster_id uuid, v_network_id uuid, v_status integer, v_is_display boolean, v_required boolean, v_migration boolean, v_management boolean, v_is_gluster boolean, v_default_route boolean) OWNER TO engine;

--
-- Name: insertnetworkattachment(uuid, uuid, uuid, character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying, text, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnetworkattachment(v_id uuid, v_network_id uuid, v_nic_id uuid, v_boot_protocol character varying, v_address character varying, v_netmask character varying, v_gateway character varying, v_ipv6_boot_protocol character varying, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_custom_properties text, v_dns_resolver_configuration_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO network_attachments (
        id,
        network_id,
        nic_id,
        boot_protocol,
        address,
        netmask,
        gateway,
        ipv6_boot_protocol,
        ipv6_address,
        ipv6_prefix,
        ipv6_gateway,
        custom_properties,
        dns_resolver_configuration_id
        )
    VALUES (
        v_id,
        v_network_id,
        v_nic_id,
        v_boot_protocol,
        v_address,
        v_netmask,
        v_gateway,
        v_ipv6_boot_protocol,
        v_ipv6_address,
        v_ipv6_prefix,
        v_ipv6_gateway,
        v_custom_properties,
        v_dns_resolver_configuration_id
        );
END;$$;


ALTER FUNCTION public.insertnetworkattachment(v_id uuid, v_network_id uuid, v_nic_id uuid, v_boot_protocol character varying, v_address character varying, v_netmask character varying, v_gateway character varying, v_ipv6_boot_protocol character varying, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_custom_properties text, v_dns_resolver_configuration_id uuid) OWNER TO engine;

--
-- Name: insertnetworkqos(uuid, smallint, character varying, text, uuid, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_inbound_average integer, v_inbound_peak integer, v_inbound_burst integer, v_outbound_average integer, v_outbound_peak integer, v_outbound_burst integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO qos (
        id,
        qos_type,
        name,
        description,
        storage_pool_id,
        inbound_average,
        inbound_peak,
        inbound_burst,
        outbound_average,
        outbound_peak,
        outbound_burst
        )
    VALUES (
        v_id,
        v_qos_type,
        v_name,
        v_description,
        v_storage_pool_id,
        v_inbound_average,
        v_inbound_peak,
        v_inbound_burst,
        v_outbound_average,
        v_outbound_peak,
        v_outbound_burst
        );
END;$$;


ALTER FUNCTION public.insertnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_inbound_average integer, v_inbound_peak integer, v_inbound_burst integer, v_outbound_average integer, v_outbound_peak integer, v_outbound_burst integer) OWNER TO engine;

--
-- Name: insertnumanode(uuid, uuid, uuid, smallint, bigint, smallint, bigint, integer, numeric, numeric, numeric, integer, text, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnumanode(v_numa_node_id uuid, v_vds_id uuid, v_vm_id uuid, v_numa_node_index smallint, v_mem_total bigint, v_cpu_count smallint, v_mem_free bigint, v_usage_mem_percent integer, v_cpu_sys numeric, v_cpu_user numeric, v_cpu_idle numeric, v_usage_cpu_percent integer, v_distance text, v_hugepages text, v_numa_tune_mode character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO numa_node (
            numa_node_id,
            vds_id,
            vm_id,
            numa_node_index,
            mem_total,
            cpu_count,
            mem_free,
            usage_mem_percent,
            cpu_sys,
            cpu_user,
            cpu_idle,
            usage_cpu_percent,
            distance,
            hugepages,
            numa_tune_mode
            )
        VALUES (
            v_numa_node_id,
            v_vds_id,
            v_vm_id,
            v_numa_node_index,
            v_mem_total,
            v_cpu_count,
            v_mem_free,
            v_usage_mem_percent,
            v_cpu_sys,
            v_cpu_user,
            v_cpu_idle,
            v_usage_cpu_percent,
            v_distance,
            v_hugepages,
            v_numa_tune_mode
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertnumanode(v_numa_node_id uuid, v_vds_id uuid, v_vm_id uuid, v_numa_node_index smallint, v_mem_total bigint, v_cpu_count smallint, v_mem_free bigint, v_usage_mem_percent integer, v_cpu_sys numeric, v_cpu_user numeric, v_cpu_idle numeric, v_usage_cpu_percent integer, v_distance text, v_hugepages text, v_numa_tune_mode character varying) OWNER TO engine;

--
-- Name: insertnumanodecpu(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnumanodecpu(v_id uuid, v_numa_node_id uuid, v_cpu_core_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO numa_node_cpu_map (
            id,
            numa_node_id,
            cpu_core_id
            )
        VALUES (
            v_id,
            v_numa_node_id,
            v_cpu_core_id
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertnumanodecpu(v_id uuid, v_numa_node_id uuid, v_cpu_core_id integer) OWNER TO engine;

--
-- Name: insertnumanodemap(uuid, uuid, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertnumanodemap(v_id uuid, v_vm_numa_node_id uuid, v_vds_numa_node_index smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO vm_vds_numa_node_map (
            id,
            vm_numa_node_id,
            vds_numa_node_index
            )
        VALUES (
            v_id,
            v_vm_numa_node_id,
            v_vds_numa_node_index
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertnumanodemap(v_id uuid, v_vm_numa_node_id uuid, v_vds_numa_node_index smallint) OWNER TO engine;

--
-- Name: insertorupdateasynctasks(integer, integer, integer, uuid, uuid, uuid, uuid, uuid, uuid, timestamp with time zone, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertorupdateasynctasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_started_at timestamp with time zone, v_storage_pool_id uuid, v_async_task_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NOT EXISTS (
            SELECT 1
            FROM async_tasks
            WHERE async_tasks.task_id = v_task_id
            ) THEN
                  PERFORM Insertasync_tasks(
                      v_action_type,
                      v_result,
                      v_status,
                      v_user_id,
                      v_vdsm_task_id,
                      v_task_id,
                      v_step_id,
                      v_command_id,
                      v_root_command_id,
                      v_started_at,
                      v_storage_pool_id,
                      v_async_task_type);
             ELSE
                 PERFORM Updateasync_tasks(
                     v_action_type,
                     v_result,
                     v_status,
                     v_user_id,
                     v_vdsm_task_id,
                     v_task_id,
                     v_step_id,
                     v_command_id,
                     v_root_command_id,
                     v_storage_pool_id);
END

IF ;END;$$;


ALTER FUNCTION public.insertorupdateasynctasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_started_at timestamp with time zone, v_storage_pool_id uuid, v_async_task_type integer) OWNER TO engine;

--
-- Name: insertorupdatecommandentity(uuid, bigint, uuid, integer, uuid, uuid, text, text, character varying, timestamp with time zone, character varying, boolean, boolean, text, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertorupdatecommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_created_at timestamp with time zone, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    IF NOT EXISTS (
            SELECT 1
            FROM command_entities
            WHERE command_id = v_command_id
            ) THEN
                  PERFORM InsertCommandEntity(
                      v_user_id,
                      v_engine_session_seq_id,
                      v_command_id,
                      v_command_type,
                      v_parent_command_id,
                      v_root_command_id,
                      v_command_context,
                      v_command_parameters,
                      v_command_params_class,
                      v_created_at,
                      v_status,
                      v_executed,
                      v_callback_enabled,
                      v_return_value,
                      v_return_value_class,
                      v_data);
             ELSE
                 PERFORM UpdateCommandEntity(
                     v_user_id,
                     v_engine_session_seq_id,
                     v_command_id,
                     v_command_type,
                     v_parent_command_id,
                     v_root_command_id,
                     v_command_context,
                     v_command_parameters,
                     v_command_params_class,
                     v_status,
                     v_executed,
                     v_callback_enabled,
                     v_return_value,
                     v_return_value_class,
                     v_data);
    END IF;

END;$$;


ALTER FUNCTION public.insertorupdatecommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_created_at timestamp with time zone, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) OWNER TO engine;

--
-- Name: insertorupdateuser(character varying, character varying, character varying, character varying, character varying, character varying, uuid, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertorupdateuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE updated_rows INT;

BEGIN
    SELECT UpdateUserImpl(
        v_department,
        v_domain,
        v_email,
        v_name,
        v_note,
        v_surname,
        v_user_id,
        v_username,
        v_external_id,
        v_namespace)
    INTO updated_rows;

    IF (updated_rows = 0) THEN
        PERFORM InsertUser(
            v_department,
            v_domain,
            v_email,
            v_name,
            v_note,
            v_surname,
            v_user_id,
            v_username,
            v_external_id,
            v_namespace);
    END IF;
END;$$;


ALTER FUNCTION public.insertorupdateuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: insertovfdataforentities(uuid, character varying, character varying, integer, character varying, uuid, text, text, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertovfdataforentities(v_entity_guid uuid, v_entity_name character varying, v_entity_type character varying, v_architecture integer, v_lowest_comp_version character varying, v_storage_domain_id uuid, v_ovf_data text, v_ovf_extra_data text, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO unregistered_ovf_of_entities (
        entity_guid,
        entity_name,
        entity_type,
        architecture,
        lowest_comp_version,
        storage_domain_id,
        ovf_extra_data,
        ovf_data,
        status
        )
    VALUES (
        v_entity_guid,
        v_entity_name,
        v_entity_type,
        v_architecture,
        v_lowest_comp_version,
        v_storage_domain_id,
        v_ovf_extra_data,
        v_ovf_data,
        v_status
        );

    UPDATE unregistered_ovf_of_entities u
    SET ovf_data = vog.ovf_data
    FROM vm_ovf_generations vog
    WHERE vog.vm_guid = u.entity_guid
        AND u.entity_guid = v_entity_guid
        AND v_ovf_data IS NULL;
END;$$;


ALTER FUNCTION public.insertovfdataforentities(v_entity_guid uuid, v_entity_name character varying, v_entity_type character varying, v_architecture integer, v_lowest_comp_version character varying, v_storage_domain_id uuid, v_ovf_data text, v_ovf_extra_data text, v_status integer) OWNER TO engine;

--
-- Name: insertpermission(uuid, uuid, uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertpermission(v_ad_element_id uuid, v_id uuid, v_role_id uuid, v_object_id uuid, v_object_type_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO permissions (
        ad_element_id,
        id,
        role_id,
        object_id,
        object_type_id
        )
    VALUES (
        v_ad_element_id,
        v_id,
        v_role_id,
        v_object_id,
        v_object_type_id
        );
END;$$;


ALTER FUNCTION public.insertpermission(v_ad_element_id uuid, v_id uuid, v_role_id uuid, v_object_id uuid, v_object_type_id integer) OWNER TO engine;

--
-- Name: insertpolicyunit(uuid, character varying, text, boolean, smallint, text, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertpolicyunit(v_id uuid, v_name character varying, v_description text, v_is_internal boolean, v_type smallint, v_custom_properties_regex text, v_enabled boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO policy_units (
        id,
        name,
        description,
        is_internal,
        type,
        custom_properties_regex,
        enabled
        )
    VALUES (
        v_id,
        v_name,
        v_description,
        v_is_internal,
        v_type,
        v_custom_properties_regex,
        v_enabled
        );
END;$$;


ALTER FUNCTION public.insertpolicyunit(v_id uuid, v_name character varying, v_description text, v_is_internal boolean, v_type smallint, v_custom_properties_regex text, v_enabled boolean) OWNER TO engine;

--
-- Name: insertprovider(uuid, character varying, character varying, character varying, character varying, boolean, character varying, text, text, character varying, character varying, text, text, boolean, boolean, boolean, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertprovider(v_id uuid, v_name character varying, v_description character varying, v_url character varying, v_provider_type character varying, v_auth_required boolean, v_auth_username character varying, v_auth_password text, v_custom_properties text, v_tenant_name character varying DEFAULT NULL::character varying, v_plugin_type character varying DEFAULT NULL::character varying, v_additional_properties text DEFAULT NULL::text, v_auth_url text DEFAULT NULL::text, v_read_only boolean DEFAULT false, v_is_unmanaged boolean DEFAULT false, v_auto_sync boolean DEFAULT false, v_user_domain_name character varying DEFAULT NULL::character varying, v_project_name character varying DEFAULT NULL::character varying, v_project_domain_name character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO providers (
        id,
        name,
        description,
        url,
        provider_type,
        auth_required,
        auth_username,
        auth_password,
        custom_properties,
        tenant_name,
        plugin_type,
        additional_properties,
        auth_url,
        read_only,
        is_unmanaged,
        auto_sync,
        user_domain_name,
        project_name,
        project_domain_name
        )
    VALUES (
        v_id,
        v_name,
        v_description,
        v_url,
        v_provider_type,
        v_auth_required,
        v_auth_username,
        v_auth_password,
        v_custom_properties,
        v_tenant_name,
        v_plugin_type,
        v_additional_properties,
        v_auth_url,
        v_read_only,
        v_is_unmanaged,
        v_auto_sync,
        v_user_domain_name,
        v_project_name,
        v_project_domain_name
        );
END;$$;


ALTER FUNCTION public.insertprovider(v_id uuid, v_name character varying, v_description character varying, v_url character varying, v_provider_type character varying, v_auth_required boolean, v_auth_username character varying, v_auth_password text, v_custom_properties text, v_tenant_name character varying, v_plugin_type character varying, v_additional_properties text, v_auth_url text, v_read_only boolean, v_is_unmanaged boolean, v_auto_sync boolean, v_user_domain_name character varying, v_project_name character varying, v_project_domain_name character varying) OWNER TO engine;

--
-- Name: insertquota(uuid, uuid, character varying, character varying, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertquota(v_id uuid, v_storage_pool_id uuid, v_quota_name character varying, v_description character varying, v_threshold_cluster_percentage integer, v_threshold_storage_percentage integer, v_grace_cluster_percentage integer, v_grace_storage_percentage integer, v_is_default boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO quota (
        id,
        storage_pool_id,
        quota_name,
        description,
        threshold_cluster_percentage,
        threshold_storage_percentage,
        grace_cluster_percentage,
        grace_storage_percentage,
        is_default
        )
    VALUES (
        v_id,
        v_storage_pool_id,
        v_quota_name,
        v_description,
        v_threshold_cluster_percentage,
        v_threshold_storage_percentage,
        v_grace_cluster_percentage,
        v_grace_storage_percentage,
        v_is_default
        );
END;$$;


ALTER FUNCTION public.insertquota(v_id uuid, v_storage_pool_id uuid, v_quota_name character varying, v_description character varying, v_threshold_cluster_percentage integer, v_threshold_storage_percentage integer, v_grace_cluster_percentage integer, v_grace_storage_percentage integer, v_is_default boolean) OWNER TO engine;

--
-- Name: insertquotalimitation(uuid, uuid, uuid, uuid, integer, bigint, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertquotalimitation(v_id uuid, v_quota_id uuid, v_storage_id uuid, v_cluster_id uuid, v_virtual_cpu integer, v_mem_size_mb bigint, v_storage_size_gb bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO quota_limitation (
        id,
        quota_id,
        storage_id,
        cluster_id,
        virtual_cpu,
        mem_size_mb,
        storage_size_gb
        )
    VALUES (
        v_id,
        v_quota_id,
        v_storage_id,
        v_cluster_id,
        v_virtual_cpu,
        v_mem_size_mb,
        v_storage_size_gb
        );
END;$$;


ALTER FUNCTION public.insertquotalimitation(v_id uuid, v_quota_id uuid, v_storage_id uuid, v_cluster_id uuid, v_virtual_cpu integer, v_mem_size_mb bigint, v_storage_size_gb bigint) OWNER TO engine;

--
-- Name: insertrepo_domain_file_meta_data(uuid, character varying, character varying, bigint, timestamp with time zone, bigint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertrepo_domain_file_meta_data(v_repo_domain_id uuid, v_repo_image_id character varying, v_repo_image_name character varying, v_size bigint, v_date_created timestamp with time zone, v_last_refreshed bigint, v_file_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO repo_file_meta_data (
        repo_domain_id,
        repo_image_id,
        repo_image_name,
        size,
        date_created,
        last_refreshed,
        file_type
        )
    VALUES (
        v_repo_domain_id,
        v_repo_image_id,
        v_repo_image_name,
        v_size,
        v_date_created,
        v_last_refreshed,
        v_file_type
        );
END;$$;


ALTER FUNCTION public.insertrepo_domain_file_meta_data(v_repo_domain_id uuid, v_repo_image_id character varying, v_repo_image_name character varying, v_size bigint, v_date_created timestamp with time zone, v_last_refreshed bigint, v_file_type integer) OWNER TO engine;

--
-- Name: insertrole(character varying, uuid, character varying, boolean, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertrole(v_description character varying, v_id uuid, v_name character varying, v_is_readonly boolean, v_role_type integer, v_allows_viewing_children boolean, v_app_mode integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO roles (
        description,
        id,
        name,
        is_readonly,
        role_type,
        allows_viewing_children,
        app_mode
        )
    VALUES (
        v_description,
        v_id,
        v_name,
        v_is_readonly,
        v_role_type,
        v_allows_viewing_children,
        v_app_mode
        );
END;$$;


ALTER FUNCTION public.insertrole(v_description character varying, v_id uuid, v_name character varying, v_is_readonly boolean, v_role_type integer, v_allows_viewing_children boolean, v_app_mode integer) OWNER TO engine;

--
-- Name: insertschedulerjob(uuid, character varying, character varying, character varying, date, date, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertschedulerjob(v_job_id uuid, v_job_name character varying, v_job_class_name character varying, v_cron_schedule character varying, v_start_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_timezone character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO gluster_scheduler_job_details (
        job_id,
        job_name,
        job_class_name,
        cron_schedule,
        start_date,
        end_date,
        timezone
        )
    VALUES (
        v_job_id,
        v_job_name,
        v_job_class_name,
        v_cron_schedule,
        v_start_date,
        v_end_date,
        v_timezone
        );
END;$$;


ALTER FUNCTION public.insertschedulerjob(v_job_id uuid, v_job_name character varying, v_job_class_name character varying, v_cron_schedule character varying, v_start_date date, v_end_date date, v_timezone character varying) OWNER TO engine;

--
-- Name: insertsnapshot(uuid, uuid, character varying, character varying, character varying, timestamp with time zone, text, text, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertsnapshot(v_snapshot_id uuid, v_vm_id uuid, v_snapshot_type character varying, v_status character varying, v_description character varying, v_creation_date timestamp with time zone, v_app_list text, v_vm_configuration text, v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_changed_fields text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO snapshots (
        snapshot_id,
        status,
        vm_id,
        snapshot_type,
        description,
        creation_date,
        app_list,
        vm_configuration,
        memory_dump_disk_id,
        memory_metadata_disk_id,
        changed_fields
        )
    VALUES(
        v_snapshot_id,
        v_status,
        v_vm_id,
        v_snapshot_type,
        v_description,
        v_creation_date,
        v_app_list,
        v_vm_configuration,
        v_memory_dump_disk_id,
        v_memory_metadata_disk_id,
        v_changed_fields
        );
END; $$;


ALTER FUNCTION public.insertsnapshot(v_snapshot_id uuid, v_vm_id uuid, v_snapshot_type character varying, v_status character varying, v_description character varying, v_creation_date timestamp with time zone, v_app_list text, v_vm_configuration text, v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_changed_fields text) OWNER TO engine;

--
-- Name: insertstep(uuid, uuid, uuid, character varying, text, integer, character varying, smallint, timestamp with time zone, timestamp with time zone, character varying, uuid, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstep(v_step_id uuid, v_parent_step_id uuid, v_job_id uuid, v_step_type character varying, v_description text, v_step_number integer, v_status character varying, v_progress smallint, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_correlation_id character varying, v_external_id uuid, v_external_system_type character varying, v_is_external boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO step (
        step_id,
        parent_step_id,
        job_id,
        step_type,
        description,
        step_number,
        status,
        progress,
        start_time,
        end_time,
        correlation_id,
        external_id,
        external_system_type,
        is_external
        )
    VALUES (
        v_step_id,
        v_parent_step_id,
        v_job_id,
        v_step_type,
        v_description,
        v_step_number,
        v_status,
        v_progress,
        v_start_time,
        v_end_time,
        v_correlation_id,
        v_external_id,
        v_external_system_type,
        v_is_external
        );
END;$$;


ALTER FUNCTION public.insertstep(v_step_id uuid, v_parent_step_id uuid, v_job_id uuid, v_step_type character varying, v_description text, v_step_number integer, v_status character varying, v_progress smallint, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_correlation_id character varying, v_external_id uuid, v_external_system_type character varying, v_is_external boolean) OWNER TO engine;

--
-- Name: insertstepsubjectentity(uuid, uuid, character varying, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstepsubjectentity(v_step_id uuid, v_entity_id uuid, v_entity_type character varying, v_step_entity_weight smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO step_subject_entity (
        step_id,
        entity_id,
        entity_type,
        step_entity_weight
        )
    VALUES (
        v_step_id,
        v_entity_id,
        v_entity_type,
        v_step_entity_weight
        );
END;$$;


ALTER FUNCTION public.insertstepsubjectentity(v_step_id uuid, v_entity_id uuid, v_entity_type character varying, v_step_entity_weight smallint) OWNER TO engine;

--
-- Name: insertstorage_domain_dynamic(integer, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorage_domain_dynamic(v_available_disk_size integer, v_id uuid, v_used_disk_size integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_domain_dynamic (
        available_disk_size,
        id,
        used_disk_size
        )
    VALUES (
        v_available_disk_size,
        v_id,
        v_used_disk_size
        );
END;$$;


ALTER FUNCTION public.insertstorage_domain_dynamic(v_available_disk_size integer, v_id uuid, v_used_disk_size integer) OWNER TO engine;

--
-- Name: insertstorage_domain_static(uuid, character varying, character varying, character varying, text, integer, integer, character varying, bigint, boolean, boolean, character varying, character varying, integer, integer, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorage_domain_static(v_id uuid, v_storage character varying, v_storage_name character varying, v_storage_description character varying, v_storage_comment text, v_storage_type integer, v_storage_domain_type integer, v_storage_domain_format_type character varying, v_last_time_used_as_master bigint, v_wipe_after_delete boolean, v_discard_after_delete boolean, v_first_metadata_device character varying, v_vg_metadata_device character varying, v_warning_low_space_indicator integer, v_critical_space_action_blocker integer, v_warning_low_confirmed_space_indicator integer, v_backup boolean, v_block_size integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_domain_static (
        id,
        storage,
        storage_name,
        storage_description,
        storage_comment,
        storage_type,
        storage_domain_type,
        storage_domain_format_type,
        last_time_used_as_master,
        wipe_after_delete,
        discard_after_delete,
        first_metadata_device,
        vg_metadata_device,
        warning_low_space_indicator,
        critical_space_action_blocker,
        warning_low_confirmed_space_indicator,
        backup,
        block_size
        )
    VALUES (
        v_id,
        v_storage,
        v_storage_name,
        v_storage_description,
        v_storage_comment,
        v_storage_type,
        v_storage_domain_type,
        v_storage_domain_format_type,
        v_last_time_used_as_master,
        v_wipe_after_delete,
        v_discard_after_delete,
        v_first_metadata_device,
        v_vg_metadata_device,
        v_warning_low_space_indicator,
        v_critical_space_action_blocker,
        v_warning_low_confirmed_space_indicator,
        v_backup,
        v_block_size
        );
END;$$;


ALTER FUNCTION public.insertstorage_domain_static(v_id uuid, v_storage character varying, v_storage_name character varying, v_storage_description character varying, v_storage_comment text, v_storage_type integer, v_storage_domain_type integer, v_storage_domain_format_type character varying, v_last_time_used_as_master bigint, v_wipe_after_delete boolean, v_discard_after_delete boolean, v_first_metadata_device character varying, v_vg_metadata_device character varying, v_warning_low_space_indicator integer, v_critical_space_action_blocker integer, v_warning_low_confirmed_space_indicator integer, v_backup boolean, v_block_size integer) OWNER TO engine;

--
-- Name: insertstorage_pool(character varying, text, uuid, character varying, integer, boolean, integer, uuid, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorage_pool(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_status integer, v_is_local boolean, v_master_domain_version integer, v_spm_vds_id uuid, v_compatibility_version character varying, v_quota_enforcement_type integer, v_managed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_pool (
        description,
        free_text_comment,
        id,
        name,
        status,
        is_local,
        master_domain_version,
        spm_vds_id,
        compatibility_version,
        quota_enforcement_type,
        managed
        )
    VALUES (
        v_description,
        v_free_text_comment,
        v_id,
        v_name,
        v_status,
        v_is_local,
        v_master_domain_version,
        v_spm_vds_id,
        v_compatibility_version,
        v_quota_enforcement_type,
        v_managed
        );
END;$$;


ALTER FUNCTION public.insertstorage_pool(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_status integer, v_is_local boolean, v_master_domain_version integer, v_spm_vds_id uuid, v_compatibility_version character varying, v_quota_enforcement_type integer, v_managed boolean) OWNER TO engine;

--
-- Name: insertstorage_pool_iso_map(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorage_pool_iso_map(v_storage_id uuid, v_storage_pool_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_pool_iso_map (
        storage_id,
        storage_pool_id,
        status
        )
    VALUES (
        v_storage_id,
        v_storage_pool_id,
        v_status
        );
END;$$;


ALTER FUNCTION public.insertstorage_pool_iso_map(v_storage_id uuid, v_storage_pool_id uuid, v_status integer) OWNER TO engine;

--
-- Name: insertstorage_server_connections(character varying, character varying, character varying, character varying, character varying, text, integer, text, character varying, character varying, character varying, smallint, smallint, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorage_server_connections(v_connection character varying, v_id character varying, v_iqn character varying, v_port character varying, v_portal character varying, v_password text, v_storage_type integer, v_user_name text, v_mount_options character varying, v_vfs_type character varying, v_nfs_version character varying, v_nfs_timeo smallint, v_nfs_retrans smallint, v_gluster_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_server_connections (
        connection,
        id,
        iqn,
        port,
        portal,
        password,
        storage_type,
        user_name,
        mount_options,
        vfs_type,
        nfs_version,
        nfs_timeo,
        nfs_retrans,
        gluster_volume_id
        )
    VALUES (
        v_connection,
        v_id,
        v_iqn,
        v_port,
        v_portal,
        v_password,
        v_storage_type,
        v_user_name,
        v_mount_options,
        v_vfs_type,
        v_nfs_version,
        v_nfs_timeo,
        v_nfs_retrans,
        v_gluster_volume_id
        );
END;$$;


ALTER FUNCTION public.insertstorage_server_connections(v_connection character varying, v_id character varying, v_iqn character varying, v_port character varying, v_portal character varying, v_password text, v_storage_type integer, v_user_name text, v_mount_options character varying, v_vfs_type character varying, v_nfs_version character varying, v_nfs_timeo smallint, v_nfs_retrans smallint, v_gluster_volume_id uuid) OWNER TO engine;

--
-- Name: insertstoragedevice(uuid, text, character varying, character varying, uuid, text, character varying, text, character varying, text, bigint, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstoragedevice(v_id uuid, v_name text, v_device_uuid character varying, v_filesystem_uuid character varying, v_vds_id uuid, v_description text, v_device_type character varying, v_device_path text, v_filesystem_type character varying, v_mount_point text, v_size bigint, v_is_free boolean, v_is_gluster_brick boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_device (
        id,
        name,
        device_uuid,
        filesystem_uuid,
        vds_id,
        description,
        device_type,
        device_path,
        filesystem_type,
        mount_point,
        size,
        is_free,
        is_gluster_brick
        )
    VALUES (
        v_id,
        v_name,
        v_device_uuid,
        v_filesystem_uuid,
        v_vds_id,
        v_description,
        v_device_type,
        v_device_path,
        v_filesystem_type,
        v_mount_point,
        v_size,
        v_is_free,
        v_is_gluster_brick
        );
END;$$;


ALTER FUNCTION public.insertstoragedevice(v_id uuid, v_name text, v_device_uuid character varying, v_filesystem_uuid character varying, v_vds_id uuid, v_description text, v_device_type character varying, v_device_path text, v_filesystem_type character varying, v_mount_point text, v_size bigint, v_is_free boolean, v_is_gluster_brick boolean) OWNER TO engine;

--
-- Name: insertstoragedomaindr(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid, v_sync_schedule character varying, v_gluster_scheduler_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_domain_dr (
        storage_domain_id,
        georep_session_id,
        sync_schedule,
        gluster_scheduler_job_id
        )
    VALUES (
        v_storage_domain_id,
        v_georep_session_id,
        v_sync_schedule,
        v_gluster_scheduler_job_id
        );
END;$$;


ALTER FUNCTION public.insertstoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid, v_sync_schedule character varying, v_gluster_scheduler_job_id uuid) OWNER TO engine;

--
-- Name: insertstoragedomainovfinfo(uuid, integer, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstoragedomainovfinfo(v_storage_domain_id uuid, v_status integer, v_ovf_disk_id uuid, v_stored_ovfs_ids text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_domains_ovf_info (
        storage_domain_id,
        status,
        ovf_disk_id,
        stored_ovfs_ids
        )
    VALUES (
        v_storage_domain_id,
        v_status,
        v_ovf_disk_id,
        v_stored_ovfs_ids
        );
END;$$;


ALTER FUNCTION public.insertstoragedomainovfinfo(v_storage_domain_id uuid, v_status integer, v_ovf_disk_id uuid, v_stored_ovfs_ids text) OWNER TO engine;

--
-- Name: insertstorageqos(uuid, smallint, character varying, text, uuid, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorageqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_max_throughput integer, v_max_read_throughput integer, v_max_write_throughput integer, v_max_iops integer, v_max_read_iops integer, v_max_write_iops integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO qos (
        id,
        qos_type,
        name,
        description,
        storage_pool_id,
        max_throughput,
        max_read_throughput,
        max_write_throughput,
        max_iops,
        max_read_iops,
        max_write_iops
        )
    VALUES (
        v_id,
        v_qos_type,
        v_name,
        v_description,
        v_storage_pool_id,
        v_max_throughput,
        v_max_read_throughput,
        v_max_write_throughput,
        v_max_iops,
        v_max_read_iops,
        v_max_write_iops
        );
END;$$;


ALTER FUNCTION public.insertstorageqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_max_throughput integer, v_max_read_throughput integer, v_max_write_throughput integer, v_max_iops integer, v_max_read_iops integer, v_max_write_iops integer) OWNER TO engine;

--
-- Name: insertstorageserverconnectionextension(uuid, uuid, character varying, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertstorageserverconnectionextension(v_id uuid, v_vds_id uuid, v_iqn character varying, v_user_name text, v_password text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO storage_server_connection_extension (
        id,
        vds_id,
        iqn,
        user_name,
        password
        )
    VALUES (
        v_id,
        v_vds_id,
        v_iqn,
        v_user_name,
        v_password
        );
END;$$;


ALTER FUNCTION public.insertstorageserverconnectionextension(v_id uuid, v_vds_id uuid, v_iqn character varying, v_user_name text, v_password text) OWNER TO engine;

--
-- Name: insertsupportedclusterfeature(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertsupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid, v_is_enabled boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO supported_cluster_features (
        cluster_id,
        feature_id,
        is_enabled
        )
    VALUES (
        v_cluster_id,
        v_feature_id,
        v_is_enabled
        );
END;$$;


ALTER FUNCTION public.insertsupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid, v_is_enabled boolean) OWNER TO engine;

--
-- Name: insertsupportedhostfeature(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertsupportedhostfeature(v_host_id uuid, v_feature_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO supported_host_features (
        host_id,
        feature_name
        )
    VALUES (
        v_host_id,
        v_feature_name
        );
END;$$;


ALTER FUNCTION public.insertsupportedhostfeature(v_host_id uuid, v_feature_name character varying) OWNER TO engine;

--
-- Name: inserttags(character varying, uuid, character varying, uuid, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags(v_description character varying, v_tag_id uuid, v_tag_name character varying, v_parent_id uuid, v_readonly boolean, v_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags (
        tag_id,
        description,
        tag_name,
        parent_id,
        readonly,
        type
        )
    VALUES (
        v_tag_id,
        v_description,
        v_tag_name,
        v_parent_id,
        v_readonly,
        v_type
        );
END;$$;


ALTER FUNCTION public.inserttags(v_description character varying, v_tag_id uuid, v_tag_name character varying, v_parent_id uuid, v_readonly boolean, v_type integer) OWNER TO engine;

--
-- Name: inserttags_user_group_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags_user_group_map(v_group_id uuid, v_tag_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags_user_group_map (
        group_id,
        tag_id
        )
    VALUES (
        v_group_id,
        v_tag_id
        );
END;$$;


ALTER FUNCTION public.inserttags_user_group_map(v_group_id uuid, v_tag_id uuid) OWNER TO engine;

--
-- Name: inserttags_user_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags_user_map(v_tag_id uuid, v_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags_user_map (
        tag_id,
        user_id
        )
    VALUES (
        v_tag_id,
        v_user_id
        );
END;$$;


ALTER FUNCTION public.inserttags_user_map(v_tag_id uuid, v_user_id uuid) OWNER TO engine;

--
-- Name: inserttags_vds_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags_vds_map(v_tag_id uuid, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags_vds_map (
        tag_id,
        vds_id
        )
    VALUES (
        v_tag_id,
        v_vds_id
        );
END;$$;


ALTER FUNCTION public.inserttags_vds_map(v_tag_id uuid, v_vds_id uuid) OWNER TO engine;

--
-- Name: inserttags_vm_map(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags_vm_map(v_tag_id uuid, v_vm_id uuid, v_defaultdisplaytype integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags_vm_map (
        tag_id,
        vm_id,
        DefaultDisplayType
        )
    VALUES (
        v_tag_id,
        v_vm_id,
        v_DefaultDisplayType
        );
END;$$;


ALTER FUNCTION public.inserttags_vm_map(v_tag_id uuid, v_vm_id uuid, v_defaultdisplaytype integer) OWNER TO engine;

--
-- Name: inserttags_vm_pool_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inserttags_vm_pool_map(v_tag_id uuid, v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO tags_vm_pool_map (
        tag_id,
        vm_pool_id
        )
    VALUES (
        v_tag_id,
        v_vm_pool_id
        );
END;$$;


ALTER FUNCTION public.inserttags_vm_pool_map(v_tag_id uuid, v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: insertunregistereddisk(uuid, uuid, character varying, character varying, uuid, timestamp with time zone, timestamp with time zone, integer, integer, bigint, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertunregistereddisk(v_disk_id uuid, v_image_id uuid, v_disk_alias character varying, v_disk_description character varying, v_storage_domain_id uuid, v_creation_date timestamp with time zone, v_last_modified timestamp with time zone, v_volume_type integer, v_volume_format integer, v_actual_size bigint, v_size bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO unregistered_disks (
        disk_id,
        image_id,
        disk_alias,
        disk_description,
        storage_domain_id,
        creation_date,
        last_modified,
        volume_type,
        volume_format,
        actual_size,
        size
        )
    VALUES (
        v_disk_id,
        v_image_id,
        v_disk_alias,
        v_disk_description,
        v_storage_domain_id,
        v_creation_date,
        v_last_modified,
        v_volume_type,
        v_volume_format,
        v_actual_size,
        v_size
        );
END;$$;


ALTER FUNCTION public.insertunregistereddisk(v_disk_id uuid, v_image_id uuid, v_disk_alias character varying, v_disk_description character varying, v_storage_domain_id uuid, v_creation_date timestamp with time zone, v_last_modified timestamp with time zone, v_volume_type integer, v_volume_format integer, v_actual_size bigint, v_size bigint) OWNER TO engine;

--
-- Name: insertunregistereddiskstovms(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertunregistereddiskstovms(v_disk_id uuid, v_entity_id uuid, v_entity_name character varying, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO unregistered_disks_to_vms (
        disk_id,
        entity_id,
        entity_name,
        storage_domain_id
        )
    VALUES (
        v_disk_id,
        v_entity_id,
        v_entity_name,
        v_storage_domain_id
        );
END;$$;


ALTER FUNCTION public.insertunregistereddiskstovms(v_disk_id uuid, v_entity_id uuid, v_entity_name character varying, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: insertuser(character varying, character varying, character varying, character varying, character varying, character varying, uuid, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO users (
        department,
        domain,
        email,
        name,
        note,
        surname,
        user_id,
        username,
        external_id,
        namespace
        )
    VALUES (
        v_department,
        v_domain,
        v_email,
        v_name,
        v_note,
        v_surname,
        v_user_id,
        v_username,
        v_external_id,
        v_namespace
        );
END;$$;


ALTER FUNCTION public.insertuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: insertuserprofileproperty(uuid, uuid, text, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertuserprofileproperty(v_user_id uuid, v_property_id uuid, v_property_name text, v_property_type text, v_property_content text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO user_profiles (
        user_id,
        property_id,
        property_name,
        property_type,
        property_content
        )
    VALUES (
        v_user_id,
        v_property_id,
        v_property_name,
        v_property_type,
        v_property_content::jsonb
        );
END;$$;


ALTER FUNCTION public.insertuserprofileproperty(v_user_id uuid, v_property_id uuid, v_property_name text, v_property_type text, v_property_content text) OWNER TO engine;

--
-- Name: insertvdcoption(character varying, text, text, character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvdcoption(v_option_name character varying, v_option_value text, v_default_value text, v_version character varying, INOUT v_option_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vdc_options (
        option_name,
        option_value,
	default_value,
        version
        )
    VALUES (
        v_option_name,
        v_option_value,
	v_default_value,
        v_version
        );

    v_option_id := CURRVAL('vdc_options_seq');
END;$$;


ALTER FUNCTION public.insertvdcoption(v_option_name character varying, v_option_value text, v_default_value text, v_version character varying, INOUT v_option_id integer) OWNER TO engine;

--
-- Name: insertvds_interface(character varying, character varying, integer, character varying, boolean, uuid, boolean, character varying, character varying, character varying, character varying, character varying, integer, character varying, integer, integer, uuid, character varying, integer, integer, boolean, text, integer, character varying, integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvds_interface(v_addr character varying, v_bond_name character varying, v_bond_type integer, v_gateway character varying, v_ipv4_default_route boolean, v_id uuid, v_is_bond boolean, v_reported_switch_type character varying, v_bond_opts character varying, v_mac_addr character varying, v_name character varying, v_network_name character varying, v_speed integer, v_subnet character varying, v_boot_protocol integer, v_type integer, v_vds_id uuid, v_base_interface character varying, v_vlan_id integer, v_mtu integer, v_bridged boolean, v_labels text, v_ipv6_boot_protocol integer, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_ad_partner_mac character varying, v_ad_aggregator_id integer, v_bond_active_slave character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vds_interface (
        addr,
        bond_name,
        bond_type,
        gateway,
        ipv4_default_route,
        id,
        is_bond,
        reported_switch_type,
        bond_opts,
        mac_addr,
        name,
        network_name,
        speed,
        subnet,
        boot_protocol,
        type,
        VDS_ID,
        base_interface,
        vlan_id,
        mtu,
        bridged,
        labels,
        ipv6_address,
        ipv6_gateway,
        ipv6_prefix,
        ipv6_boot_protocol,
        ad_partner_mac,
        ad_aggregator_id,
        bond_active_slave
        )
    VALUES (
        v_addr,
        v_bond_name,
        v_bond_type,
        v_gateway,
        v_ipv4_default_route,
        v_id,
        v_is_bond,
        v_reported_switch_type,
        v_bond_opts,
        v_mac_addr,
        v_name,
        v_network_name,
        v_speed,
        v_subnet,
        v_boot_protocol,
        v_type,
        v_vds_id,
        v_base_interface,
        v_vlan_id,
        v_mtu,
        v_bridged,
        v_labels,
        v_ipv6_address,
        v_ipv6_gateway,
        v_ipv6_prefix,
        v_ipv6_boot_protocol,
        v_ad_partner_mac,
        v_ad_aggregator_id,
        v_bond_active_slave
        );
END;$$;


ALTER FUNCTION public.insertvds_interface(v_addr character varying, v_bond_name character varying, v_bond_type integer, v_gateway character varying, v_ipv4_default_route boolean, v_id uuid, v_is_bond boolean, v_reported_switch_type character varying, v_bond_opts character varying, v_mac_addr character varying, v_name character varying, v_network_name character varying, v_speed integer, v_subnet character varying, v_boot_protocol integer, v_type integer, v_vds_id uuid, v_base_interface character varying, v_vlan_id integer, v_mtu integer, v_bridged boolean, v_labels text, v_ipv6_boot_protocol integer, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_ad_partner_mac character varying, v_ad_aggregator_id integer, v_bond_active_slave character varying) OWNER TO engine;

--
-- Name: insertvds_interface_statistics(uuid, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, integer, double precision, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvds_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vds_interface_statistics (
        id,
        rx_drop,
        rx_rate,
        rx_total,
        rx_offset,
        tx_drop,
        tx_rate,
        tx_total,
        tx_offset,
        vds_id,
        iface_status,
        sample_time
        )
    VALUES (
        v_id,
        v_rx_drop,
        v_rx_rate,
        v_rx_total,
        v_rx_offset,
        v_tx_drop,
        v_tx_rate,
        v_tx_total,
        v_tx_offset,
        v_vds_id,
        v_iface_status,
        v_sample_time
        );
END;$$;


ALTER FUNCTION public.insertvds_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vds_id uuid) OWNER TO engine;

--
-- Name: insertvds_spm_id_map(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvds_spm_id_map(v_storage_pool_id uuid, v_vds_id uuid, v_vds_spm_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vds_spm_id_map (
        storage_pool_id,
        vds_id,
        vds_spm_id
        )
    VALUES (
        v_storage_pool_id,
        v_vds_id,
        v_vds_spm_id
        );
END;$$;


ALTER FUNCTION public.insertvds_spm_id_map(v_storage_pool_id uuid, v_vds_id uuid, v_vds_spm_id integer) OWNER TO engine;

--
-- Name: insertvdsdynamic(integer, integer, character varying, numeric, character varying, boolean, integer, integer, integer, uuid, integer, integer, integer, integer, integer, integer, integer, integer, character varying, character varying, character varying, character varying, integer, character varying, integer, integer, integer, boolean, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, text, character varying, character varying, character varying, character varying, character varying, character varying, text, text, boolean, smallint, integer, smallint, boolean, character varying, text, boolean, boolean, text, boolean, boolean, jsonb, boolean, jsonb, boolean, boolean, boolean, character varying, jsonb, character varying, boolean, boolean, character varying, boolean, boolean, jsonb, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvdsdynamic(v_cpu_cores integer, v_cpu_threads integer, v_cpu_model character varying, v_cpu_speed_mh numeric, v_if_total_speed character varying, v_kvm_enabled boolean, v_mem_commited integer, v_physical_mem_mb integer, v_status integer, v_vds_id uuid, v_vm_active integer, v_vm_count integer, v_vms_cores_count integer, v_vm_migrating integer, v_incoming_migrations integer, v_outgoing_migrations integer, v_reserved_mem integer, v_guest_overhead integer, v_rpm_version character varying, v_software_version character varying, v_version_name character varying, v_build_name character varying, v_previous_status integer, v_cpu_flags character varying, v_pending_vcpus_count integer, v_pending_vmem_size integer, v_cpu_sockets integer, v_net_config_dirty boolean, v_supported_cluster_levels character varying, v_supported_engines character varying, v_host_os character varying, v_kvm_version character varying, v_libvirt_version character varying, v_spice_version character varying, v_gluster_version character varying, v_librbd1_version character varying, v_glusterfs_cli_version character varying, v_openvswitch_version character varying, v_kernel_version character varying, v_iscsi_initiator_name character varying, v_transparent_hugepages_state integer, v_hooks text, v_hw_manufacturer character varying, v_hw_product_name character varying, v_hw_version character varying, v_hw_serial_number character varying, v_hw_uuid character varying, v_hw_family character varying, v_hbas text, v_supported_emulated_machines text, v_controlled_by_pm_policy boolean, v_kdump_status smallint, v_selinux_enforce_mode integer, v_auto_numa_balancing smallint, v_is_numa_supported boolean, v_supported_rng_sources character varying, v_online_cpus text, v_is_update_available boolean, v_is_hostdev_enabled boolean, v_kernel_args text, v_hosted_engine_configured boolean, v_in_fence_flow boolean, v_kernel_features jsonb, v_vnc_encryption_enabled boolean, v_connector_info jsonb, v_backup_enabled boolean, v_cold_backup_enabled boolean, v_clear_bitmaps_enabled boolean, v_supported_domain_versions character varying, v_supported_block_size jsonb, v_tsc_frequency character varying, v_tsc_scaling boolean, v_fips_enabled boolean, v_boot_uuid character varying, v_cd_change_pdiv boolean, v_ovn_configured boolean, v_cpu_topology jsonb, v_vdsm_cpus_affinity character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO vds_dynamic (
            cpu_cores,
            cpu_threads,
            cpu_model,
            cpu_speed_mh,
            if_total_speed,
            kvm_enabled,
            mem_commited,
            physical_mem_mb,
            status,
            vds_id,
            vm_active,
            vm_count,
            vm_migrating,
            incoming_migrations,
            outgoing_migrations,
            reserved_mem,
            guest_overhead,
            rpm_version,
            software_version,
            version_name,
            build_name,
            previous_status,
            cpu_flags,
            vms_cores_count,
            pending_vcpus_count,
            pending_vmem_size,
            cpu_sockets,
            net_config_dirty,
            supported_cluster_levels,
            supported_engines,
            host_os,
            kvm_version,
            libvirt_version,
            spice_version,
            gluster_version,
            librbd1_version,
            glusterfs_cli_version,
            openvswitch_version,
            kernel_version,
            iscsi_initiator_name,
            transparent_hugepages_state,
            hooks,
            hw_manufacturer,
            hw_product_name,
            hw_version,
            hw_serial_number,
            hw_uuid,
            hw_family,
            hbas,
            supported_emulated_machines,
            controlled_by_pm_policy,
            kdump_status,
            selinux_enforce_mode,
            auto_numa_balancing,
            is_numa_supported,
            supported_rng_sources,
            online_cpus,
            is_update_available,
            is_hostdev_enabled,
            kernel_args,
            hosted_engine_configured,
            in_fence_flow,
            kernel_features,
            vnc_encryption_enabled,
            connector_info,
            backup_enabled,
            cold_backup_enabled,
            clear_bitmaps_enabled,
            supported_domain_versions,
            supported_block_size,
            tsc_frequency,
            tsc_scaling,
            fips_enabled,
            boot_uuid,
            cd_change_pdiv,
            ovn_configured,
            cpu_topology,
            vdsm_cpus_affinity
            )
        VALUES (
            v_cpu_cores,
            v_cpu_threads,
            v_cpu_model,
            v_cpu_speed_mh,
            v_if_total_speed,
            v_kvm_enabled,
            v_mem_commited,
            v_physical_mem_mb,
            v_status,
            v_vds_id,
            v_vm_active,
            v_vm_count,
            v_vm_migrating,
            v_incoming_migrations,
            v_outgoing_migrations,
            v_reserved_mem,
            v_guest_overhead,
            v_rpm_version,
            v_software_version,
            v_version_name,
            v_build_name,
            v_previous_status,
            v_cpu_flags,
            v_vms_cores_count,
            v_pending_vcpus_count,
            v_pending_vmem_size,
            v_cpu_sockets,
            v_net_config_dirty,
            v_supported_cluster_levels,
            v_supported_engines,
            v_host_os,
            v_kvm_version,
            v_libvirt_version,
            v_spice_version,
            v_gluster_version,
            v_librbd1_version,
            v_glusterfs_cli_version,
            v_openvswitch_version,
            v_kernel_version,
            v_iscsi_initiator_name,
            v_transparent_hugepages_state,
            v_hooks,
            v_hw_manufacturer,
            v_hw_product_name,
            v_hw_version,
            v_hw_serial_number,
            v_hw_uuid,
            v_hw_family,
            v_hbas,
            v_supported_emulated_machines,
            v_controlled_by_pm_policy,
            v_kdump_status,
            v_selinux_enforce_mode,
            v_auto_numa_balancing,
            v_is_numa_supported,
            v_supported_rng_sources,
            v_online_cpus,
            v_is_update_available,
            v_is_hostdev_enabled,
            v_kernel_args,
            v_hosted_engine_configured,
            v_in_fence_flow,
            v_kernel_features,
            v_vnc_encryption_enabled,
            v_connector_info,
            v_backup_enabled,
            v_cold_backup_enabled,
            v_clear_bitmaps_enabled,
            v_supported_domain_versions,
            v_supported_block_size,
            v_tsc_frequency,
            v_tsc_scaling,
            v_fips_enabled,
            v_boot_uuid,
            v_cd_change_pdiv,
            v_ovn_configured,
            v_cpu_topology,
            v_vdsm_cpus_affinity
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertvdsdynamic(v_cpu_cores integer, v_cpu_threads integer, v_cpu_model character varying, v_cpu_speed_mh numeric, v_if_total_speed character varying, v_kvm_enabled boolean, v_mem_commited integer, v_physical_mem_mb integer, v_status integer, v_vds_id uuid, v_vm_active integer, v_vm_count integer, v_vms_cores_count integer, v_vm_migrating integer, v_incoming_migrations integer, v_outgoing_migrations integer, v_reserved_mem integer, v_guest_overhead integer, v_rpm_version character varying, v_software_version character varying, v_version_name character varying, v_build_name character varying, v_previous_status integer, v_cpu_flags character varying, v_pending_vcpus_count integer, v_pending_vmem_size integer, v_cpu_sockets integer, v_net_config_dirty boolean, v_supported_cluster_levels character varying, v_supported_engines character varying, v_host_os character varying, v_kvm_version character varying, v_libvirt_version character varying, v_spice_version character varying, v_gluster_version character varying, v_librbd1_version character varying, v_glusterfs_cli_version character varying, v_openvswitch_version character varying, v_kernel_version character varying, v_iscsi_initiator_name character varying, v_transparent_hugepages_state integer, v_hooks text, v_hw_manufacturer character varying, v_hw_product_name character varying, v_hw_version character varying, v_hw_serial_number character varying, v_hw_uuid character varying, v_hw_family character varying, v_hbas text, v_supported_emulated_machines text, v_controlled_by_pm_policy boolean, v_kdump_status smallint, v_selinux_enforce_mode integer, v_auto_numa_balancing smallint, v_is_numa_supported boolean, v_supported_rng_sources character varying, v_online_cpus text, v_is_update_available boolean, v_is_hostdev_enabled boolean, v_kernel_args text, v_hosted_engine_configured boolean, v_in_fence_flow boolean, v_kernel_features jsonb, v_vnc_encryption_enabled boolean, v_connector_info jsonb, v_backup_enabled boolean, v_cold_backup_enabled boolean, v_clear_bitmaps_enabled boolean, v_supported_domain_versions character varying, v_supported_block_size jsonb, v_tsc_frequency character varying, v_tsc_scaling boolean, v_fips_enabled boolean, v_boot_uuid character varying, v_cd_change_pdiv boolean, v_ovn_configured boolean, v_cpu_topology jsonb, v_vdsm_cpus_affinity character varying) OWNER TO engine;

--
-- Name: insertvdsstatic(text, uuid, character varying, character varying, integer, uuid, character varying, boolean, integer, boolean, character varying, boolean, integer, character varying, character varying, character varying, integer, character varying, boolean, uuid, text, text, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvdsstatic(v_free_text_comment text, v_vds_id uuid, v_host_name character varying, v_vds_unique_id character varying, v_port integer, v_cluster_id uuid, v_vds_name character varying, v_server_ssl_enabled boolean, v_vds_type integer, v_pm_enabled boolean, v_pm_proxy_preferences character varying, v_pm_detect_kdump boolean, v_vds_spm_priority integer, v_sshkeyfingerprint character varying, v_ssh_public_key character varying, v_console_address character varying, v_ssh_port integer, v_ssh_username character varying, v_disable_auto_pm boolean, v_host_provider_id uuid, v_kernel_cmdline text, v_last_stored_kernel_cmdline text, v_vgpu_placement integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF v_vds_unique_id IS NULL
        OR NOT EXISTS (
            SELECT vds_name
            FROM vds_static
            WHERE vds_unique_id = v_vds_unique_id
            ) THEN
    BEGIN
        INSERT INTO vds_static (
            vds_id,
            host_name,
            free_text_comment,
            vds_unique_id,
            port,
            cluster_id,
            vds_name,
            server_SSL_enabled,
            vds_type,
            pm_enabled,
            pm_proxy_preferences,
            pm_detect_kdump,
            vds_spm_priority,
            sshKeyFingerprint,
            ssh_public_key,
            console_address,
            ssh_port,
            ssh_username,
            disable_auto_pm,
            host_provider_id,
            kernel_cmdline,
            last_stored_kernel_cmdline,
            vgpu_placement
            )
        VALUES (
            v_vds_id,
            v_host_name,
            v_free_text_comment,
            v_vds_unique_id,
            v_port,
            v_cluster_id,
            v_vds_name,
            v_server_SSL_enabled,
            v_vds_type,
            v_pm_enabled,
            v_pm_proxy_preferences,
            v_pm_detect_kdump,
            v_vds_spm_priority,
            v_sshKeyFingerprint,
            v_ssh_public_key,
            v_console_address,
            v_ssh_port,
            v_ssh_username,
            v_disable_auto_pm,
            v_host_provider_id,
            v_kernel_cmdline,
            v_last_stored_kernel_cmdline,
            v_vgpu_placement
            );
    END;
END IF;

    RETURN;
END;$$;


ALTER FUNCTION public.insertvdsstatic(v_free_text_comment text, v_vds_id uuid, v_host_name character varying, v_vds_unique_id character varying, v_port integer, v_cluster_id uuid, v_vds_name character varying, v_server_ssl_enabled boolean, v_vds_type integer, v_pm_enabled boolean, v_pm_proxy_preferences character varying, v_pm_detect_kdump boolean, v_vds_spm_priority integer, v_sshkeyfingerprint character varying, v_ssh_public_key character varying, v_console_address character varying, v_ssh_port integer, v_ssh_username character varying, v_disable_auto_pm boolean, v_host_provider_id uuid, v_kernel_cmdline text, v_last_stored_kernel_cmdline text, v_vgpu_placement integer) OWNER TO engine;

--
-- Name: insertvdsstatistics(numeric, numeric, numeric, numeric, integer, integer, integer, uuid, bigint, bigint, bigint, bigint, integer, bigint, boolean, integer, bigint, integer, boolean, boolean, boolean, boolean, timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvdsstatistics(v_cpu_idle numeric, v_cpu_load numeric, v_cpu_sys numeric, v_cpu_user numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_vds_id uuid, v_mem_free bigint, v_mem_shared bigint, v_swap_free bigint, v_swap_total bigint, v_ksm_cpu_percent integer, v_ksm_pages bigint, v_ksm_state boolean, v_anonymous_hugepages integer, v_boot_time bigint, v_ha_score integer, v_ha_configured boolean, v_ha_active boolean, v_ha_global_maintenance boolean, v_ha_local_maintenance boolean, v_cpu_over_commit_time_stamp timestamp with time zone, v_hugepages text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO vds_statistics (
            cpu_idle,
            cpu_load,
            cpu_sys,
            cpu_user,
            usage_cpu_percent,
            usage_mem_percent,
            usage_network_percent,
            vds_id,
            mem_free,
            mem_shared,
            swap_free,
            swap_total,
            ksm_cpu_percent,
            ksm_pages,
            ksm_state,
            anonymous_hugepages,
            boot_time,
            ha_score,
            ha_configured,
            ha_active,
            ha_global_maintenance,
            ha_local_maintenance,
            cpu_over_commit_time_stamp,
            hugepages
            )
        VALUES (
            v_cpu_idle,
            v_cpu_load,
            v_cpu_sys,
            v_cpu_user,
            v_usage_cpu_percent,
            v_usage_mem_percent,
            v_usage_network_percent,
            v_vds_id,
            v_mem_free,
            v_mem_shared,
            v_swap_free,
            v_swap_total,
            v_ksm_cpu_percent,
            v_ksm_pages,
            v_ksm_state,
            v_anonymous_hugepages,
            v_boot_time,
            v_ha_score,
            v_ha_configured,
            v_ha_active,
            v_ha_global_maintenance,
            v_ha_local_maintenance,
            v_cpu_over_commit_time_stamp,
            v_hugepages
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertvdsstatistics(v_cpu_idle numeric, v_cpu_load numeric, v_cpu_sys numeric, v_cpu_user numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_vds_id uuid, v_mem_free bigint, v_mem_shared bigint, v_swap_free bigint, v_swap_total bigint, v_ksm_cpu_percent integer, v_ksm_pages bigint, v_ksm_state boolean, v_anonymous_hugepages integer, v_boot_time bigint, v_ha_score integer, v_ha_configured boolean, v_ha_active boolean, v_ha_global_maintenance boolean, v_ha_local_maintenance boolean, v_cpu_over_commit_time_stamp timestamp with time zone, v_hugepages text) OWNER TO engine;

--
-- Name: insertvfsconfiglabel(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvfsconfiglabel(v_vfs_config_id uuid, v_label text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vfs_config_labels (
        vfs_config_id,
        label
        )
    VALUES (
        v_vfs_config_id,
        v_label
        );
END;$$;


ALTER FUNCTION public.insertvfsconfiglabel(v_vfs_config_id uuid, v_label text) OWNER TO engine;

--
-- Name: insertvfsconfignetwork(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvfsconfignetwork(v_vfs_config_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vfs_config_networks (
        vfs_config_id,
        network_id
        )
    VALUES (
        v_vfs_config_id,
        v_network_id
        );
END;$$;


ALTER FUNCTION public.insertvfsconfignetwork(v_vfs_config_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: insertvm_interface_statistics(uuid, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, integer, double precision, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvm_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_interface_statistics (
        id,
        rx_drop,
        rx_rate,
        rx_total,
        rx_offset,
        tx_drop,
        tx_rate,
        tx_total,
        tx_offset,
        vm_id,
        iface_status,
        sample_time
        )
    VALUES (
        v_id,
        v_rx_drop,
        v_rx_rate,
        v_rx_total,
        v_rx_offset,
        v_tx_drop,
        v_tx_rate,
        v_tx_total,
        v_tx_offset,
        v_vm_id,
        v_iface_status,
        v_sample_time
        );
END;$$;


ALTER FUNCTION public.insertvm_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vm_id uuid) OWNER TO engine;

--
-- Name: insertvm_pool_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvm_pool_map(v_vm_guid uuid, v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_pool_map (
        vm_guid,
        vm_pool_id
        )
    VALUES (
        v_vm_guid,
        v_vm_pool_id
        );
END;$$;


ALTER FUNCTION public.insertvm_pool_map(v_vm_guid uuid, v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: insertvm_pools(character varying, text, uuid, character varying, integer, boolean, character varying, integer, uuid, smallint, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvm_pools(v_vm_pool_description character varying, v_vm_pool_comment text, v_vm_pool_id uuid, v_vm_pool_name character varying, v_vm_pool_type integer, v_stateful boolean, v_parameters character varying, v_prestarted_vms integer, v_cluster_id uuid, v_max_assigned_vms_per_user smallint, v_spice_proxy character varying, v_is_auto_storage_select boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_pools (
        vm_pool_id,
        vm_pool_description,
        vm_pool_comment,
        vm_pool_name,
        vm_pool_type,
        stateful,
        parameters,
        prestarted_vms,
        cluster_id,
        max_assigned_vms_per_user,
        spice_proxy,
        is_auto_storage_select
        )
    VALUES (
        v_vm_pool_id,
        v_vm_pool_description,
        v_vm_pool_comment,
        v_vm_pool_name,
        v_vm_pool_type,
        v_stateful,
        v_parameters,
        v_prestarted_vms,
        v_cluster_id,
        v_max_assigned_vms_per_user,
        v_spice_proxy,
        v_is_auto_storage_select
        );
END;$$;


ALTER FUNCTION public.insertvm_pools(v_vm_pool_description character varying, v_vm_pool_comment text, v_vm_pool_id uuid, v_vm_pool_name character varying, v_vm_pool_type integer, v_stateful boolean, v_parameters character varying, v_prestarted_vms integer, v_cluster_id uuid, v_max_assigned_vms_per_user smallint, v_spice_proxy character varying, v_is_auto_storage_select boolean) OWNER TO engine;

--
-- Name: insertvmbackup(uuid, uuid, uuid, uuid, uuid, text, timestamp with time zone, timestamp with time zone, character varying, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmbackup(v_backup_id uuid, v_from_checkpoint_id uuid, v_to_checkpoint_id uuid, v_vm_id uuid, v_host_id uuid, v_phase text, v__create_date timestamp with time zone, v__update_date timestamp with time zone, v_description character varying, v_backup_type character varying, v_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_backups (
        backup_id,
        from_checkpoint_id,
        to_checkpoint_id,
        vm_id,
        host_id,
        phase,
        _create_date,
        _update_date,
        description,
        backup_type,
        snapshot_id
        )
    VALUES (
        v_backup_id,
        v_from_checkpoint_id,
        v_to_checkpoint_id,
        v_vm_id,
        v_host_id,
        v_phase,
        v__create_date,
        v__update_date,
        v_description,
        v_backup_type,
        v_snapshot_id
        );
END;$$;


ALTER FUNCTION public.insertvmbackup(v_backup_id uuid, v_from_checkpoint_id uuid, v_to_checkpoint_id uuid, v_vm_id uuid, v_host_id uuid, v_phase text, v__create_date timestamp with time zone, v__update_date timestamp with time zone, v_description character varying, v_backup_type character varying, v_snapshot_id uuid) OWNER TO engine;

--
-- Name: insertvmbackupdiskmap(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmbackupdiskmap(v_backup_id uuid, v_disk_id uuid, v_disk_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO vm_backup_disk_map (
            backup_id,
            disk_id,
            disk_snapshot_id
            )
        VALUES (
            v_backup_id,
            v_disk_id,
            v_disk_snapshot_id
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertvmbackupdiskmap(v_backup_id uuid, v_disk_id uuid, v_disk_snapshot_id uuid) OWNER TO engine;

--
-- Name: insertvmcheckpoint(uuid, uuid, uuid, timestamp with time zone, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmcheckpoint(v_checkpoint_id uuid, v_vm_id uuid, v_parent_id uuid, v__create_date timestamp with time zone, v_state text, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_checkpoints (
        checkpoint_id,
        vm_id,
        parent_id,
        _create_date,
        state,
        description
        )
    VALUES (
        v_checkpoint_id,
        v_vm_id,
        v_parent_id,
        v__create_date,
        v_state,
        v_description
        );
END;$$;


ALTER FUNCTION public.insertvmcheckpoint(v_checkpoint_id uuid, v_vm_id uuid, v_parent_id uuid, v__create_date timestamp with time zone, v_state text, v_description character varying) OWNER TO engine;

--
-- Name: insertvmcheckpointdiskmap(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmcheckpointdiskmap(v_checkpoint_id uuid, v_disk_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        INSERT INTO vm_checkpoint_disk_map (
            checkpoint_id,
            disk_id
            )
        VALUES (
            v_checkpoint_id,
            v_disk_id
            );
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.insertvmcheckpointdiskmap(v_checkpoint_id uuid, v_disk_id uuid) OWNER TO engine;

--
-- Name: insertvmdevice(uuid, uuid, character varying, character varying, character varying, text, boolean, boolean, boolean, character varying, text, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmdevice(v_device_id uuid, v_vm_id uuid, v_device character varying, v_type character varying, v_address character varying, v_spec_params text, v_is_managed boolean, v_is_plugged boolean, v_is_readonly boolean, v_alias character varying, v_custom_properties text, v_snapshot_id uuid, v_logical_name character varying, v_host_device character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_device (
        device_id,
        vm_id,
        device,
        type,
        address,
        spec_params,
        is_managed,
        is_plugged,
        is_readonly,
        alias,
        custom_properties,
        snapshot_id,
        logical_name,
        host_device
        )
    VALUES (
        v_device_id,
        v_vm_id,
        v_device,
        v_type,
        v_address,
        v_spec_params,
        v_is_managed,
        v_is_plugged,
        v_is_readonly,
        v_alias,
        v_custom_properties,
        v_snapshot_id,
        v_logical_name,
        v_host_device
        );
END;$$;


ALTER FUNCTION public.insertvmdevice(v_device_id uuid, v_vm_id uuid, v_device character varying, v_type character varying, v_address character varying, v_spec_params text, v_is_managed boolean, v_is_plugged boolean, v_is_readonly boolean, v_alias character varying, v_custom_properties text, v_snapshot_id uuid, v_logical_name character varying, v_host_device character varying) OWNER TO engine;

--
-- Name: insertvmdynamic(text, text, character varying, character varying, uuid, character varying, uuid, uuid, integer, uuid, character varying, character varying, character varying, timestamp with time zone, timestamp with time zone, bigint, timestamp with time zone, boolean, integer, integer, integer, character varying, integer, integer, integer, character varying, integer, numeric, character varying, boolean, boolean, character varying, character varying, character varying, integer, integer, integer, integer, character varying, integer, character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, text, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmdynamic(v_app_list text, v_guest_cur_user_name text, v_console_cur_user_name character varying, v_runtime_name character varying, v_console_user_id uuid, v_guest_os character varying, v_migrating_to_vds uuid, v_run_on_vds uuid, v_status integer, v_vm_guid uuid, v_vm_host character varying, v_vm_ip character varying, v_vm_fqdn character varying, v_last_start_time timestamp with time zone, v_boot_time timestamp with time zone, v_downtime bigint, v_last_stop_time timestamp with time zone, v_acpi_enable boolean, v_session integer, v_boot_sequence integer, v_utc_diff integer, v_client_ip character varying, v_guest_requested_memory integer, v_exit_status integer, v_pause_status integer, v_exit_message character varying, v_guest_agent_nics_hash integer, v_last_watchdog_event numeric, v_last_watchdog_action character varying, v_is_run_once boolean, v_volatile_run boolean, v_cpu_name character varying, v_emulated_machine character varying, v_current_cd character varying, v_exit_reason integer, v_guest_cpu_count integer, v_spice_port integer, v_spice_tls_port integer, v_spice_ip character varying, v_vnc_port integer, v_vnc_ip character varying, v_ovirt_guest_agent_status integer, v_qemu_guest_agent_status integer, v_guest_timezone_offset integer, v_guest_timezone_name character varying, v_guestos_arch integer, v_guestos_codename character varying, v_guestos_distribution character varying, v_guestos_kernel_version character varying, v_guestos_type character varying, v_guestos_version character varying, v_guest_containers text, v_current_cpu_pinning character varying, v_current_sockets integer, v_current_cores integer, v_current_threads integer, v_current_numa_pinning character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_dynamic (
        app_list,
        guest_cur_user_name,
        console_cur_user_name,
        runtime_name,
        console_user_id,
        guest_os,
        migrating_to_vds,
        run_on_vds,
        status,
        vm_guid,
        vm_host,
        vm_ip,
        last_start_time,
        boot_time,
        downtime,
        last_stop_time,
        acpi_enable,
        session,
        boot_sequence,
        utc_diff,
        client_ip,
        guest_requested_memory,
        exit_status,
        pause_status,
        exit_message,
        guest_agent_nics_hash,
        last_watchdog_event,
        last_watchdog_action,
        is_run_once,
        volatile_run,
        vm_fqdn,
        cpu_name,
        emulated_machine,
        current_cd,
        exit_reason,
        guest_cpu_count,
        spice_port,
        spice_tls_port,
        spice_ip,
        vnc_port,
        vnc_ip,
        ovirt_guest_agent_status,
        qemu_guest_agent_status,
        guest_timezone_offset,
        guest_timezone_name,
        guestos_arch,
        guestos_codename,
        guestos_distribution,
        guestos_kernel_version,
        guestos_type,
        guestos_version,
        guest_containers,
        current_cpu_pinning,
        current_sockets,
        current_cores,
        current_threads,
        current_numa_pinning
        )
    VALUES (
        v_app_list,
        v_guest_cur_user_name,
        v_console_cur_user_name,
        v_runtime_name,
        v_console_user_id,
        v_guest_os,
        v_migrating_to_vds,
        v_run_on_vds,
        v_status,
        v_vm_guid,
        v_vm_host,
        v_vm_ip,
        v_last_start_time,
        v_boot_time,
        v_downtime,
        v_last_stop_time,
        v_acpi_enable,
        v_session,
        v_boot_sequence,
        v_utc_diff,
        v_client_ip,
        v_guest_requested_memory,
        v_exit_status,
        v_pause_status,
        v_exit_message,
        v_guest_agent_nics_hash,
        v_last_watchdog_event,
        v_last_watchdog_action,
        v_is_run_once,
        v_volatile_run,
        v_vm_fqdn,
        v_cpu_name,
        v_emulated_machine,
        v_current_cd,
        v_exit_reason,
        v_guest_cpu_count,
        v_spice_port,
        v_spice_tls_port,
        v_spice_ip,
        v_vnc_port,
        v_vnc_ip,
        v_ovirt_guest_agent_status,
        v_qemu_guest_agent_status,
        v_guest_timezone_offset,
        v_guest_timezone_name,
        v_guestos_arch,
        v_guestos_codename,
        v_guestos_distribution,
        v_guestos_kernel_version,
        v_guestos_type,
        v_guestos_version,
        v_guest_containers,
        v_current_cpu_pinning,
        v_current_sockets,
        v_current_cores,
        v_current_threads,
        v_current_numa_pinning
        );
END;$$;


ALTER FUNCTION public.insertvmdynamic(v_app_list text, v_guest_cur_user_name text, v_console_cur_user_name character varying, v_runtime_name character varying, v_console_user_id uuid, v_guest_os character varying, v_migrating_to_vds uuid, v_run_on_vds uuid, v_status integer, v_vm_guid uuid, v_vm_host character varying, v_vm_ip character varying, v_vm_fqdn character varying, v_last_start_time timestamp with time zone, v_boot_time timestamp with time zone, v_downtime bigint, v_last_stop_time timestamp with time zone, v_acpi_enable boolean, v_session integer, v_boot_sequence integer, v_utc_diff integer, v_client_ip character varying, v_guest_requested_memory integer, v_exit_status integer, v_pause_status integer, v_exit_message character varying, v_guest_agent_nics_hash integer, v_last_watchdog_event numeric, v_last_watchdog_action character varying, v_is_run_once boolean, v_volatile_run boolean, v_cpu_name character varying, v_emulated_machine character varying, v_current_cd character varying, v_exit_reason integer, v_guest_cpu_count integer, v_spice_port integer, v_spice_tls_port integer, v_spice_ip character varying, v_vnc_port integer, v_vnc_ip character varying, v_ovirt_guest_agent_status integer, v_qemu_guest_agent_status integer, v_guest_timezone_offset integer, v_guest_timezone_name character varying, v_guestos_arch integer, v_guestos_codename character varying, v_guestos_distribution character varying, v_guestos_kernel_version character varying, v_guestos_type character varying, v_guestos_version character varying, v_guest_containers text, v_current_cpu_pinning character varying, v_current_sockets integer, v_current_cores integer, v_current_threads integer, v_current_numa_pinning character varying) OWNER TO engine;

--
-- Name: insertvmguestagentinterface(uuid, character varying, character varying, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmguestagentinterface(v_vm_id uuid, v_interface_name character varying, v_mac_address character varying, v_ipv4_addresses text, v_ipv6_addresses text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_guest_agent_interfaces (
        vm_id,
        interface_name,
        mac_address,
        ipv4_addresses,
        ipv6_addresses
        )
    VALUES (
        v_vm_id,
        v_interface_name,
        v_mac_address,
        v_ipv4_addresses,
        v_ipv6_addresses
        );
END;$$;


ALTER FUNCTION public.insertvmguestagentinterface(v_vm_id uuid, v_interface_name character varying, v_mac_address character varying, v_ipv4_addresses text, v_ipv6_addresses text) OWNER TO engine;

--
-- Name: insertvmicon(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmicon(v_id uuid, v_data_url text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_icons (
        id,
        data_url
        )
    VALUES (
        v_id,
        v_data_url
        );
END;$$;


ALTER FUNCTION public.insertvmicon(v_id uuid, v_data_url text) OWNER TO engine;

--
-- Name: insertvmicondefault(uuid, integer, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmicondefault(v_id uuid, v_os_id integer, v_small_icon_id uuid, v_large_icon_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_icon_defaults (
        id,
        os_id,
        small_icon_id,
        large_icon_id
        )
    VALUES (
        v_id,
        v_os_id,
        v_small_icon_id,
        v_large_icon_id
        );
END;$$;


ALTER FUNCTION public.insertvmicondefault(v_id uuid, v_os_id integer, v_small_icon_id uuid, v_large_icon_id uuid) OWNER TO engine;

--
-- Name: insertvminit(uuid, text, text, text, boolean, character varying, text, text, text, text, character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvminit(v_vm_id uuid, v_host_name text, v_domain text, v_authorized_keys text, v_regenerate_keys boolean, v_time_zone character varying, v_dns_servers text, v_dns_search_domains text, v_networks text, v_password text, v_winkey character varying, v_custom_script text, v_input_locale character varying, v_ui_language character varying, v_system_locale character varying, v_user_locale character varying, v_user_name character varying, v_active_directory_ou character varying, v_org_name character varying, v_cloud_init_network_protocol character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_init (
        vm_id,
        host_name,
        domain,
        authorized_keys,
        regenerate_keys,
        time_zone,
        dns_servers,
        dns_search_domains,
        networks,
        password,
        winkey,
        custom_script,
        input_locale,
        ui_language,
        system_locale,
        user_locale,
        user_name,
        active_directory_ou,
        org_name,
        cloud_init_network_protocol
        )
    VALUES (
        v_vm_id,
        v_host_name,
        v_domain,
        v_authorized_keys,
        v_regenerate_keys,
        v_time_zone,
        v_dns_servers,
        v_dns_search_domains,
        v_networks,
        v_password,
        v_winkey,
        v_custom_script,
        v_input_locale,
        v_ui_language,
        v_system_locale,
        v_user_locale,
        v_user_name,
        v_active_directory_ou,
        v_org_name,
        v_cloud_init_network_protocol
        );
END;$$;


ALTER FUNCTION public.insertvminit(v_vm_id uuid, v_host_name text, v_domain text, v_authorized_keys text, v_regenerate_keys boolean, v_time_zone character varying, v_dns_servers text, v_dns_search_domains text, v_networks text, v_password text, v_winkey character varying, v_custom_script text, v_input_locale character varying, v_ui_language character varying, v_system_locale character varying, v_user_locale character varying, v_user_name character varying, v_active_directory_ou character varying, v_org_name character varying, v_cloud_init_network_protocol character varying) OWNER TO engine;

--
-- Name: insertvminterface(uuid, character varying, character varying, integer, uuid, uuid, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvminterface(v_id uuid, v_mac_addr character varying, v_name character varying, v_speed integer, v_vnic_profile_id uuid, v_vm_guid uuid, v_type integer, v_linked boolean, v_synced boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_interface (
        id,
        mac_addr,
        name,
        speed,
        vnic_profile_id,
        vm_guid,
        type,
        linked,
        synced
        )
    VALUES (
        v_id,
        v_mac_addr,
        v_name,
        v_speed,
        v_vnic_profile_id,
        v_vm_guid,
        v_type,
        v_linked,
        v_synced
        );
END;$$;


ALTER FUNCTION public.insertvminterface(v_id uuid, v_mac_addr character varying, v_name character varying, v_speed integer, v_vnic_profile_id uuid, v_vm_guid uuid, v_type integer, v_linked boolean, v_synced boolean) OWNER TO engine;

--
-- Name: insertvminterfacefilterparameter(uuid, character varying, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvminterfacefilterparameter(v_id uuid, v_name character varying, v_value character varying, v_vm_interface_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_interface_filter_parameters (
        id,
        name,
        value,
        vm_interface_id
        )
    VALUES (
        v_id,
        v_name,
        v_value,
        v_vm_interface_id
        );
END;$$;


ALTER FUNCTION public.insertvminterfacefilterparameter(v_id uuid, v_name character varying, v_value character varying, v_vm_interface_id uuid) OWNER TO engine;

--
-- Name: insertvmjobs(uuid, uuid, integer, integer, integer, integer, bigint, bigint, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmjobs(v_vm_job_id uuid, v_vm_id uuid, v_job_state integer, v_job_type integer, v_block_job_type integer, v_bandwidth integer, v_cursor_cur bigint, v_cursor_end bigint, v_image_group_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_jobs (
        vm_job_id,
        vm_id,
        job_state,
        job_type,
        block_job_type,
        bandwidth,
        cursor_cur,
        cursor_end,
        image_group_id
        )
    VALUES (
        v_vm_job_id,
        v_vm_id,
        v_job_state,
        v_job_type,
        v_block_job_type,
        v_bandwidth,
        v_cursor_cur,
        v_cursor_end,
        v_image_group_id
        );
END;$$;


ALTER FUNCTION public.insertvmjobs(v_vm_job_id uuid, v_vm_id uuid, v_job_state integer, v_job_type integer, v_block_job_type integer, v_bandwidth integer, v_cursor_cur bigint, v_cursor_end bigint, v_image_group_id uuid) OWNER TO engine;

--
-- Name: insertvmstatic(character varying, text, integer, integer, integer, integer, uuid, uuid, character varying, uuid, timestamp with time zone, integer, boolean, boolean, integer, integer, integer, integer, character varying, boolean, boolean, boolean, boolean, character varying, text, integer, integer, integer, integer, integer, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, integer, uuid, character varying, boolean, boolean, character varying, boolean, uuid, uuid, uuid, uuid, character varying, integer, integer, smallint, character varying, boolean, boolean, boolean, uuid, boolean, boolean, boolean, character varying, integer, character varying, uuid, uuid, character varying, character varying, character varying, uuid, uuid, boolean, integer, boolean, character varying, boolean, integer, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmstatic(v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_os integer, v_cluster_id uuid, v_vm_guid uuid, v_vm_name character varying, v_vmt_guid uuid, v_creation_date timestamp with time zone, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_is_initialized boolean, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_usb_policy integer, v_time_zone character varying, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_dedicated_vm_for_vds text, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_migration_support integer, v_predefined_properties character varying, v_userdefined_properties character varying, v_min_allocated_mem integer, v_quota_id uuid, v_cpu_pinning character varying, v_host_cpu_flags boolean, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_instance_type_id uuid, v_image_type_id uuid, v_original_template_id uuid, v_original_template_name character varying, v_migration_downtime integer, v_template_version_number integer, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_namespace character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_val UUID;
BEGIN
-- lock template for child count update
select vm_guid into v_val FROM vm_static WHERE vm_guid = v_vmt_guid for update;

INSERT INTO vm_static(description,
                      free_text_comment,
                      mem_size_mb,
                      max_memory_size_mb,
                      num_of_io_threads,
                      os,
                      cluster_id,
                      vm_guid,
                      vm_name,
                      vmt_guid,
                      creation_date,
                      num_of_monitors,
                      allow_console_reconnect,
                      is_initialized,
                      num_of_sockets,
                      cpu_per_socket,
                      threads_per_cpu,
                      usb_policy,
                      time_zone,
                      auto_startup,
                      is_stateless,
                      default_boot_sequence,
                      vm_type,
                      nice_level,
                      cpu_shares,
                      default_display_type,
                      priority,
                      iso_path,
                      origin,
                      initrd_url,
                      kernel_url,
                      kernel_params,
                      migration_support,
                      predefined_properties,
                      userdefined_properties,
                      min_allocated_mem,
                      entity_type,
                      quota_id,
                      cpu_pinning,
                      is_smartcard_enabled,
                      is_delete_protected,
                      sso_method,
                      host_cpu_flags,
                      tunnel_migration,
                      vnc_keyboard_layout,
                      is_run_and_pause,
                      created_by_user_id,
                      instance_type_id,
                      image_type_id,
                      original_template_id,
                      original_template_name,
                      migration_downtime,
                      template_version_number,
                      serial_number_policy,
                      custom_serial_number,
                      is_boot_menu_enabled,
                      is_spice_file_transfer_enabled,
                      is_spice_copy_paste_enabled,
                      cpu_profile_id,
                      is_auto_converge,
                      is_migrate_compressed,
                      is_migrate_encrypted,
                      custom_emulated_machine,
                      bios_type,
                      custom_cpu_name,
                      small_icon_id,
                      large_icon_id,
                      console_disconnect_action,
                      resume_behavior,
                      custom_compatibility_version,
                      migration_policy_id,
                      lease_sd_id,
                      multi_queues_enabled,
                      virtio_scsi_multi_queues,
                      use_tsc_frequency,
                      namespace,
                      balloon_enabled,
                      console_disconnect_action_delay,
                      cpu_pinning_policy,
                      parallel_migrations)
    VALUES(v_description,
           v_free_text_comment,
           v_mem_size_mb,
           v_max_memory_size_mb,
           v_num_of_io_threads,
           v_os,
           v_cluster_id,
           v_vm_guid,
           v_vm_name,
           v_vmt_guid,
           v_creation_date,
           v_num_of_monitors,
           v_allow_console_reconnect,
           v_is_initialized,
           v_num_of_sockets,
           v_cpu_per_socket,
           v_threads_per_cpu,
           v_usb_policy,
           v_time_zone,
           v_auto_startup,
           v_is_stateless,
           v_default_boot_sequence,
           v_vm_type,
           v_nice_level,
           v_cpu_shares,
           v_default_display_type,
           v_priority,
           v_iso_path,
           v_origin,
           v_initrd_url,
           v_kernel_url,
           v_kernel_params,
           v_migration_support,
           v_predefined_properties,
           v_userdefined_properties,
           v_min_allocated_mem,
           'VM',
           v_quota_id,
           v_cpu_pinning,
           v_is_smartcard_enabled,
           v_is_delete_protected,
           v_sso_method,
           v_host_cpu_flags,
           v_tunnel_migration,
           v_vnc_keyboard_layout,
           v_is_run_and_pause,
           v_created_by_user_id,
           v_instance_type_id,
           v_image_type_id,
           v_original_template_id,
           v_original_template_name,
           v_migration_downtime,
           v_template_version_number,
           v_serial_number_policy,
           v_custom_serial_number,
           v_is_boot_menu_enabled,
           v_is_spice_file_transfer_enabled,
           v_is_spice_copy_paste_enabled,
           v_cpu_profile_id,
           v_is_auto_converge,
           v_is_migrate_compressed,
           v_is_migrate_encrypted,
           v_custom_emulated_machine,
           v_bios_type,
           v_custom_cpu_name,
           v_small_icon_id,
           v_large_icon_id,
           v_console_disconnect_action,
           v_resume_behavior,
           v_custom_compatibility_version,
           v_migration_policy_id,
           v_lease_sd_id,
           v_multi_queues_enabled,
           v_virtio_scsi_multi_queues,
           v_use_tsc_frequency,
           v_namespace,
           v_balloon_enabled,
           v_console_disconnect_action_delay,
           v_cpu_pinning_policy,
           v_parallel_migrations);

    -- perform deletion from vm_ovf_generations to ensure that no record exists when performing insert to avoid PK violation.
    DELETE
    FROM vm_ovf_generations gen
    WHERE gen.vm_guid = v_vm_guid
        AND v_origin != 4;
    INSERT INTO vm_ovf_generations(vm_guid, storage_pool_id)
        SELECT
            v_vm_guid,
            storage_pool_id
        FROM cluster vg
        WHERE vg.cluster_id = v_cluster_id
           AND v_origin != 4;

    -- add connections to dedicated hosts
    PERFORM InsertDedicatedHostsToVm(
        v_vm_guid,
        v_dedicated_vm_for_vds);

    -- set child_count for the template
    UPDATE vm_static
    SET child_count = child_count+1
    WHERE vm_guid = v_vmt_guid;

END; $$;


ALTER FUNCTION public.insertvmstatic(v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_os integer, v_cluster_id uuid, v_vm_guid uuid, v_vm_name character varying, v_vmt_guid uuid, v_creation_date timestamp with time zone, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_is_initialized boolean, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_usb_policy integer, v_time_zone character varying, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_dedicated_vm_for_vds text, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_migration_support integer, v_predefined_properties character varying, v_userdefined_properties character varying, v_min_allocated_mem integer, v_quota_id uuid, v_cpu_pinning character varying, v_host_cpu_flags boolean, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_instance_type_id uuid, v_image_type_id uuid, v_original_template_id uuid, v_original_template_name character varying, v_migration_downtime integer, v_template_version_number integer, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_namespace character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: insertvmstatistics(numeric, numeric, numeric, integer, integer, integer, text, uuid, bigint, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmstatistics(v_cpu_sys numeric, v_cpu_user numeric, v_elapsed_time numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_disks_usage text, v_vm_guid uuid, v_guest_mem_buffered bigint, v_guest_mem_cached bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_statistics (
        cpu_sys,
        cpu_user,
        elapsed_time,
        usage_cpu_percent,
        usage_mem_percent,
        usage_network_percent,
        disks_usage,
        vm_guid,
        guest_mem_buffered,
        guest_mem_cached
        )
    VALUES (
        v_cpu_sys,
        v_cpu_user,
        v_elapsed_time,
        v_usage_cpu_percent,
        v_usage_mem_percent,
        v_usage_network_percent,
        v_disks_usage,
        v_vm_guid,
        v_guest_mem_buffered,
        v_guest_mem_cached
        );
END;$$;


ALTER FUNCTION public.insertvmstatistics(v_cpu_sys numeric, v_cpu_user numeric, v_elapsed_time numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_disks_usage text, v_vm_guid uuid, v_guest_mem_buffered bigint, v_guest_mem_cached bigint) OWNER TO engine;

--
-- Name: insertvmtemplate(integer, timestamp with time zone, character varying, text, integer, integer, integer, character varying, integer, integer, integer, integer, uuid, uuid, integer, boolean, integer, integer, character varying, integer, integer, integer, integer, integer, integer, boolean, boolean, boolean, boolean, character varying, boolean, character varying, integer, character varying, character varying, character varying, uuid, integer, text, boolean, character varying, integer, boolean, uuid, character varying, integer, uuid, character varying, smallint, character varying, boolean, boolean, boolean, uuid, boolean, boolean, boolean, boolean, character varying, character varying, character varying, integer, character varying, uuid, uuid, character varying, character varying, character varying, uuid, uuid, boolean, integer, boolean, boolean, character varying, boolean, integer, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvmtemplate(v_child_count integer, v_creation_date timestamp with time zone, v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_name character varying, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_os integer, v_vmt_guid uuid, v_cluster_id uuid, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_status integer, v_usb_policy integer, v_time_zone character varying, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_is_disabled boolean, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_quota_id uuid, v_migration_support integer, v_dedicated_vm_for_vds text, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_min_allocated_mem integer, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_template_type character varying, v_migration_downtime integer, v_base_template_id uuid, v_template_version_name character varying, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_host_cpu_flags boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_predefined_properties character varying, v_userdefined_properties character varying, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_is_template_sealed boolean, v_cpu_pinning character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
v_template_version_number INTEGER;
BEGIN
  -- get current max version and use next
  SELECT max(template_version_number) + 1 into v_template_version_number
  from vm_static
  where vmt_guid = v_base_template_id
        and entity_type = 'TEMPLATE';

  -- if no versions exist it might return null, so this is a new base template
  if v_template_version_number is null then
    v_template_version_number = 1;
  end if;

    INSERT
    INTO vm_static(
        child_count,
        creation_date,
        description,
        free_text_comment,
        mem_size_mb,
        max_memory_size_mb,
        num_of_io_threads,
        vm_name,
        num_of_sockets,
        cpu_per_socket,
        threads_per_cpu,
        os,
        vm_guid,
        cluster_id,
        num_of_monitors,
        allow_console_reconnect,
        template_status,
        usb_policy,
        time_zone,
        vm_type,
        nice_level,
        cpu_shares,
        default_boot_sequence,
        default_display_type,
        priority,
        auto_startup,
        is_stateless,
        iso_path,
        origin,
        initrd_url,
        kernel_url,
        kernel_params,
        entity_type,
        quota_id,
        migration_support,
        is_disabled,
        is_smartcard_enabled,
        is_delete_protected,
        sso_method,
        tunnel_migration,
        vnc_keyboard_layout,
        min_allocated_mem,
        is_run_and_pause,
        created_by_user_id,
        migration_downtime,
        template_version_number,
        vmt_guid,
        template_version_name,
        serial_number_policy,
        custom_serial_number,
        is_boot_menu_enabled,
        is_spice_file_transfer_enabled,
        is_spice_copy_paste_enabled,
        cpu_profile_id,
        host_cpu_flags,
        is_auto_converge,
        is_migrate_compressed,
        is_migrate_encrypted,
        predefined_properties,
        userdefined_properties,
        custom_emulated_machine,
        bios_type,
        custom_cpu_name,
        small_icon_id,
        large_icon_id,
        console_disconnect_action,
        resume_behavior,
        custom_compatibility_version,
        migration_policy_id,
        lease_sd_id,
        multi_queues_enabled,
        virtio_scsi_multi_queues,
        use_tsc_frequency,
        is_template_sealed,
        cpu_pinning,
        balloon_enabled,
        console_disconnect_action_delay,
        cpu_pinning_policy,
        parallel_migrations)
    VALUES(
        v_child_count,
        v_creation_date,
        v_description,
        v_free_text_comment,
        v_mem_size_mb,
        v_max_memory_size_mb,
        v_num_of_io_threads,
        v_name,
        v_num_of_sockets,
        v_cpu_per_socket,
        v_threads_per_cpu,
        v_os,
        v_vmt_guid,
        v_cluster_id,
        v_num_of_monitors,
        v_allow_console_reconnect,
        v_status,
        v_usb_policy,
        v_time_zone,
        v_vm_type,
        v_nice_level,
        v_cpu_shares,
        v_default_boot_sequence,
        v_default_display_type,
        v_priority,
        v_auto_startup,
        v_is_stateless,
        v_iso_path,
        v_origin,
        v_initrd_url,
        v_kernel_url,
        v_kernel_params,
        v_template_type,
        v_quota_id,
        v_migration_support,
        v_is_disabled,
        v_is_smartcard_enabled,
        v_is_delete_protected,
        v_sso_method,
        v_tunnel_migration,
        v_vnc_keyboard_layout,
        v_min_allocated_mem,
        v_is_run_and_pause,
        v_created_by_user_id,
        v_migration_downtime,
        v_template_version_number,
        v_base_template_id,
        v_template_version_name,
        v_serial_number_policy,
        v_custom_serial_number,
        v_is_boot_menu_enabled,
        v_is_spice_file_transfer_enabled,
        v_is_spice_copy_paste_enabled,
        v_cpu_profile_id,
        v_host_cpu_flags,
        v_is_auto_converge,
        v_is_migrate_compressed,
        v_is_migrate_encrypted,
        v_predefined_properties,
        v_userdefined_properties,
        v_custom_emulated_machine,
        v_bios_type,
        v_custom_cpu_name,
        v_small_icon_id,
        v_large_icon_id,
        v_console_disconnect_action,
        v_resume_behavior,
        v_custom_compatibility_version,
        v_migration_policy_id,
        v_lease_sd_id,
        v_multi_queues_enabled,
        v_virtio_scsi_multi_queues,
        v_use_tsc_frequency,
        v_is_template_sealed,
        v_cpu_pinning,
        v_balloon_enabled,
        v_console_disconnect_action_delay,
        v_cpu_pinning_policy,
        v_parallel_migrations);
    -- perform deletion from vm_ovf_generations to ensure that no record exists when performing insert to avoid PK violation.
    DELETE FROM vm_ovf_generations gen WHERE gen.vm_guid = v_vmt_guid;
    INSERT INTO vm_ovf_generations(
        vm_guid,
        storage_pool_id)
    VALUES (
        v_vmt_guid,
        (SELECT storage_pool_id
         FROM cluster vg
         WHERE vg.cluster_id = v_cluster_id));

    -- add connections to dedicated hosts
    PERFORM InsertDedicatedHostsToVm(
        v_vmt_guid,
        v_dedicated_vm_for_vds);

END; $$;


ALTER FUNCTION public.insertvmtemplate(v_child_count integer, v_creation_date timestamp with time zone, v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_name character varying, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_os integer, v_vmt_guid uuid, v_cluster_id uuid, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_status integer, v_usb_policy integer, v_time_zone character varying, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_is_disabled boolean, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_quota_id uuid, v_migration_support integer, v_dedicated_vm_for_vds text, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_min_allocated_mem integer, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_template_type character varying, v_migration_downtime integer, v_base_template_id uuid, v_template_version_name character varying, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_host_cpu_flags boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_predefined_properties character varying, v_userdefined_properties character varying, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_is_template_sealed boolean, v_cpu_pinning character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: insertvnicprofile(uuid, character varying, uuid, uuid, boolean, boolean, boolean, text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.insertvnicprofile(v_id uuid, v_name character varying, v_network_id uuid, v_network_qos_id uuid, v_port_mirroring boolean, v_passthrough boolean, v_migratable boolean, v_custom_properties text, v_description text, v_network_filter_id uuid, v_failover_vnic_profile_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vnic_profiles (
        id,
        name,
        network_id,
        network_qos_id,
        port_mirroring,
        passthrough,
        migratable,
        custom_properties,
        description,
        network_filter_id,
        failover_vnic_profile_id
        )
    VALUES (
        v_id,
        v_name,
        v_network_id,
        v_network_qos_id,
        v_port_mirroring,
        v_passthrough,
        v_migratable,
        v_custom_properties,
        v_description,
        v_network_filter_id,
        v_failover_vnic_profile_id
        );
END;$$;


ALTER FUNCTION public.insertvnicprofile(v_id uuid, v_name character varying, v_network_id uuid, v_network_qos_id uuid, v_port_mirroring boolean, v_passthrough boolean, v_migratable boolean, v_custom_properties text, v_description text, v_network_filter_id uuid, v_failover_vnic_profile_id uuid) OWNER TO engine;

--
-- Name: inst_add_glance_provider(uuid, character varying, character varying, character varying, uuid, boolean, character varying, text, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inst_add_glance_provider(v_provider_id uuid, v_provider_name character varying, v_provider_description character varying, v_provider_url character varying, v_storage_domain_id uuid, v_auth_required boolean DEFAULT false, v_auth_username character varying DEFAULT NULL::character varying, v_auth_password text DEFAULT NULL::text, v_auth_url text DEFAULT NULL::text, v_tenant_name character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Adding the Glance provider
    INSERT INTO providers (
        id,
        name,
        description,
        url,
        provider_type,
        auth_required,
        auth_username,
        auth_password,
        auth_url,
        tenant_name
        )
    SELECT v_provider_id,
        v_provider_name,
        v_provider_description,
        v_provider_url,
        'OPENSTACK_IMAGE',
        v_auth_required,
        v_auth_username,
        v_auth_password,
        v_auth_url,
        v_tenant_name
    WHERE NOT EXISTS (
            SELECT id
            FROM providers
            WHERE id = v_provider_id
            );

    -- Adding a proper storage domain static entry
    INSERT INTO storage_domain_static (
        id,
        storage,
        storage_name,
        storage_domain_type,
        storage_type,
        storage_domain_format_type,
        recoverable
        )
    SELECT v_storage_domain_id,
        v_provider_id,
        v_provider_name,
        4,
        8,
        0,
        true
    WHERE NOT EXISTS (
            SELECT id
            FROM storage_domain_static
            WHERE id = v_storage_domain_id
            );

    -- Adding a proper storage domain dynamic entry
    INSERT INTO storage_domain_dynamic (
        id,
        available_disk_size,
        used_disk_size
        )
    SELECT v_storage_domain_id,
        NULL,
        NULL
    WHERE NOT EXISTS (
            SELECT id
            FROM storage_domain_dynamic
            WHERE id = v_storage_domain_id
            );
END;$$;


ALTER FUNCTION public.inst_add_glance_provider(v_provider_id uuid, v_provider_name character varying, v_provider_description character varying, v_provider_url character varying, v_storage_domain_id uuid, v_auth_required boolean, v_auth_username character varying, v_auth_password text, v_auth_url text, v_tenant_name character varying) OWNER TO engine;

--
-- Name: inst_add_iso_storage_domain(uuid, character varying, uuid, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inst_add_iso_storage_domain(v_storage_domain_id uuid, v_name character varying, v_connection_id uuid, v_connection character varying, v_available integer, v_used integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
    IF NOT EXISTS (
            SELECT 1
            FROM storage_server_connections
            WHERE connection = v_connection
            ) THEN
        -- Insert storage server connection info
        perform Insertstorage_server_connections(v_connection, cast(v_connection_id AS VARCHAR(250)), NULL, NULL, NULL, NULL, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        -- Insert storage domain static info
        perform Insertstorage_domain_static(v_storage_domain_id, cast(v_connection_id AS VARCHAR(250)), v_name, v_name, '', 1, 2, '0', 0, FALSE, FALSE, CAST(NULL AS VARCHAR(100)), CAST(NULL AS VARCHAR(100)), CAST(NULL AS INT), CAST(NULL AS INT), FALSE);

    -- Insert storage domain dynamic  info
    perform Insertstorage_domain_dynamic(v_available, v_storage_domain_id, v_used);
    END IF;

    exception when others then RAISE EXCEPTION 'NUM:%, DETAILS:%',
        SQLSTATE,
        SQLERRM;
    END;$$;


ALTER FUNCTION public.inst_add_iso_storage_domain(v_storage_domain_id uuid, v_name character varying, v_connection_id uuid, v_connection character varying, v_available integer, v_used integer) OWNER TO engine;

--
-- Name: inst_update_default_storage_pool_type(boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inst_update_default_storage_pool_type(v_is_local boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_pool
    SET is_local = v_is_local,
        _update_date = LOCALTIMESTAMP
    WHERE storage_pool.name = 'Default'
        AND NOT EXISTS (
            SELECT 1
            FROM storage_domains
            WHERE storage_domains.storage_pool_name = 'Default'
            );
END;$$;


ALTER FUNCTION public.inst_update_default_storage_pool_type(v_is_local boolean) OWNER TO engine;

--
-- Name: inst_update_service_type(uuid, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.inst_update_service_type(v_cluster_id uuid, v_virt_service boolean, v_gluster_service boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster
    SET virt_service = v_virt_service,
        gluster_service = v_gluster_service
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.inst_update_service_type(v_cluster_id uuid, v_virt_service boolean, v_gluster_service boolean) OWNER TO engine;

--
-- Name: invalidateallcheckpointsbyvmid(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.invalidateallcheckpointsbyvmid(v_vm_id uuid, v_state text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_checkpoints
    SET state = v_state
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.invalidateallcheckpointsbyvmid(v_vm_id uuid, v_state text) OWNER TO engine;

--
-- Name: isanyvmrunonvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.isanyvmrunonvds(v_vds_id uuid) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT vm_guid
            FROM vm_dynamic
            WHERE run_on_vds = v_vds_id
           );
END;$$;


ALTER FUNCTION public.isanyvmrunonvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: isdiskincludedincheckpoint(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.isdiskincludedincheckpoint(v_disk_id uuid) RETURNS SETOF public.booleanresulttype
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT EXISTS (
            SELECT 1
            FROM vm_checkpoint_disk_map
            WHERE disk_id = v_disk_id
           );
END;$$;


ALTER FUNCTION public.isdiskincludedincheckpoint(v_disk_id uuid) OWNER TO engine;

--
-- Name: ismemballoonenabled(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.ismemballoonenabled(v_vm_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE result boolean := false;

BEGIN
    IF EXISTS (
            SELECT 1
            FROM vm_device
            WHERE vm_id = v_vm_id
                AND type = 'balloon'
                AND device = 'memballoon'
            ) THEN result := true;
    END IF;
        RETURN result;
END;$$;


ALTER FUNCTION public.ismemballoonenabled(v_vm_id uuid) OWNER TO engine;

--
-- Name: isquotainuse(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.isquotainuse(v_quota_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE result boolean := FALSE;

BEGIN
    IF EXISTS (
            SELECT quota_id
            FROM image_storage_domain_map
            WHERE quota_id = v_quota_id

            UNION

            SELECT quota_id
            FROM vm_static
            WHERE quota_id = v_quota_id
            ) THEN result := TRUE;
    END IF;
    RETURN result;
END;$$;


ALTER FUNCTION public.isquotainuse(v_quota_id uuid) OWNER TO engine;

--
-- Name: isvmiconexist(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.isvmiconexist(v_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN (
            SELECT EXISTS (
                    SELECT 1
                    FROM vm_icons
                    WHERE id = v_id
                    )
            );
END;$$;


ALTER FUNCTION public.isvmiconexist(v_id uuid) OWNER TO engine;

--
-- Name: vm_ovf_generations; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_ovf_generations (
    vm_guid uuid NOT NULL,
    storage_pool_id uuid,
    ovf_generation bigint DEFAULT 0,
    ovf_data text
);


ALTER TABLE public.vm_ovf_generations OWNER TO engine;

--
-- Name: loadovfdataforids(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.loadovfdataforids(v_ids character varying) RETURNS SETOF public.vm_ovf_generations
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM vm_ovf_generations ovf
    WHERE ovf.vm_guid IN (
            SELECT *
            FROM fnSplitterUuid(v_ids)
            );
END;$$;


ALTER FUNCTION public.loadovfdataforids(v_ids character varying) OWNER TO engine;

--
-- Name: storage_domains_ovf_info; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.storage_domains_ovf_info (
    storage_domain_id uuid,
    status integer DEFAULT 0,
    ovf_disk_id uuid NOT NULL,
    stored_ovfs_ids text,
    last_updated timestamp with time zone
);


ALTER TABLE public.storage_domains_ovf_info OWNER TO engine;

--
-- Name: loadstoragedomaininfobydiskid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.loadstoragedomaininfobydiskid(v_disk_id uuid) RETURNS SETOF public.storage_domains_ovf_info
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains_ovf_info ovf
    WHERE ovf.ovf_disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.loadstoragedomaininfobydiskid(v_disk_id uuid) OWNER TO engine;

--
-- Name: loadstoragedomaininfobydomainid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.loadstoragedomaininfobydomainid(v_storage_domain_id uuid) RETURNS SETOF public.storage_domains_ovf_info
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY

    SELECT *
    FROM storage_domains_ovf_info ovf
    WHERE ovf.storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.loadstoragedomaininfobydomainid(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: loadstoragedomainsforovfids(text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.loadstoragedomainsforovfids(v_ovfs_ids text) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY

    SELECT ovf.storage_domain_id
    FROM storage_domains_ovf_info ovf
    WHERE string_to_array(ovf.stored_ovfs_ids, ',') && string_to_array(v_ovfs_ids, ',');
END;$$;


ALTER FUNCTION public.loadstoragedomainsforovfids(v_ovfs_ids text) OWNER TO engine;

--
-- Name: logenginebackupevent(character varying, timestamp with time zone, integer, text, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.logenginebackupevent(v_scope character varying, v_done_at timestamp with time zone, v_status integer, v_output_message text, v_fqdn character varying, v_log_path text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF v_status = - 1 THEN
        INSERT INTO engine_backup_log (
            scope,
            done_at,
            is_passed,
            output_message,
            fqdn,
            log_path
            )
        VALUES (
            v_scope,
            v_done_at,
            false,
            v_output_message,
            v_fqdn,
            v_log_path
            );

    INSERT INTO audit_log (
        log_time,
        log_type_name,
        log_type,
        severity,
        message
        )
    VALUES (
        v_done_at,
        'ENGINE_BACKUP_FAILED',
        9026,
        2,
        v_output_message
        );

    ELSIF v_status = 0 THEN

    INSERT INTO audit_log (
        log_time,
        log_type_name,
        log_type,
        severity,
        message
        )
    VALUES (
        v_done_at,
        'ENGINE_BACKUP_STARTED',
        9024,
        0,
        v_output_message
        );

    ELSIF v_status = 1 THEN

    INSERT INTO engine_backup_log (
        scope,
        done_at,
        is_passed,
        output_message,
        fqdn,
        log_path
        )
    VALUES (
        v_scope,
        v_done_at,
        true,
        v_output_message,
        v_fqdn,
        v_log_path
        );

    -- Clean alerts
    PERFORM DeleteBackupRelatedAlerts();

    INSERT INTO audit_log (
        log_time,
        log_type_name,
        log_type,
        severity,
        message
        )
    VALUES (
        v_done_at,
        'ENGINE_BACKUP_COMPLETED',
        9025,
        0,
        v_output_message
        );
    END IF;

END;$$;


ALTER FUNCTION public.logenginebackupevent(v_scope character varying, v_done_at timestamp with time zone, v_status integer, v_output_message text, v_fqdn character varying, v_log_path text) OWNER TO engine;

--
-- Name: markhostdevicesusedbyvmid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.markhostdevicesusedbyvmid(v_vm_id uuid, v_host_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE host_device
    SET vm_id = v_vm_id
    WHERE host_id = v_host_id
        AND device_name IN (
            SELECT device
            FROM vm_device
            WHERE vm_id = v_vm_id
                AND type = 'hostdev'
            );
END;$$;


ALTER FUNCTION public.markhostdevicesusedbyvmid(v_vm_id uuid, v_host_id uuid) OWNER TO engine;

--
-- Name: nullifyqosforstoragedomain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.nullifyqosforstoragedomain(v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE disk_profiles
    SET qos_id = NULL
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.nullifyqosforstoragedomain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: remove_entities_from_storage_domain(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.remove_entities_from_storage_domain(v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE v_ids UUID[];
BEGIN
    BEGIN
        -- Creating a temporary table which will give all the images and the disks which resids on only the specified storage domain. (copied template disks on multiple storage domains will not be part of this table)
        CREATE TEMPORARY TABLE STORAGE_DOMAIN_MAP_TABLE ON COMMIT DROP AS

        SELECT image_guid AS image_id,
            disk_id
        FROM images_storage_domain_view
        WHERE storage_id = v_storage_domain_id

        EXCEPT

        SELECT image_guid AS image_id,
            disk_id
        FROM images_storage_domain_view
        WHERE storage_id != v_storage_domain_id;

        exception when others then

        TRUNCATE TABLE STORAGE_DOMAIN_MAP_TABLE;

        INSERT INTO STORAGE_DOMAIN_MAP_TABLE
        SELECT image_guid AS image_id,
            disk_id
        FROM images_storage_domain_view
        WHERE storage_id = v_storage_domain_id

        EXCEPT

        SELECT image_guid AS image_id,
            disk_id
        FROM images_storage_domain_view
        WHERE storage_id != v_storage_domain_id;
    END;

    BEGIN
        -- All the VMs/Templates which have disks both on the specified domain and other domains.
        CREATE TEMPORARY TABLE ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE ON COMMIT DROP AS

        SELECT DISTINCT vm_static.vm_guid
        FROM vm_static
        INNER JOIN (
            -- Join vm_static only with VMs and Templates that have images on the storage domain v_storage_domain_id
            SELECT vm_static.vm_guid
            FROM vm_static
            INNER JOIN vm_device vd
                ON vd.vm_id = vm_static.vm_guid
            INNER JOIN images i
                ON i.image_group_id = vd.device_id
            INNER JOIN STORAGE_DOMAIN_MAP_TABLE
                ON i.image_guid = STORAGE_DOMAIN_MAP_TABLE.image_id
            ) vm_guids_with_disks_on_storage_domain
            ON vm_static.vm_guid = vm_guids_with_disks_on_storage_domain.vm_guid
        -- With all the VMs which have images on the storage domain, get all of their images and check if there is an image on another storage domain.
        INNER JOIN vm_device vd
            ON vd.vm_id = vm_static.vm_guid
        INNER JOIN images i
            ON i.image_group_id = vd.device_id
        INNER JOIN image_storage_domain_map
            ON i.image_guid = image_storage_domain_map.image_id
        WHERE image_storage_domain_map.storage_domain_id != v_storage_domain_id;

        exception when others then

        TRUNCATE TABLE ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE;

        INSERT INTO ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
        SELECT DISTINCT vm_static.vm_guid
        FROM vm_static
        INNER JOIN (
            SELECT vm_static.vm_guid
            FROM vm_static
            INNER JOIN vm_device vd
                ON vd.vm_id = vm_static.vm_guid
            INNER JOIN images i
                ON i.image_group_id = vd.device_id
            INNER JOIN STORAGE_DOMAIN_MAP_TABLE
                ON i.image_guid = STORAGE_DOMAIN_MAP_TABLE.image_id
            ) vm_guids_with_disks_on_storage_domain
            ON vm_static.vm_guid = vm_guids_with_disks_on_storage_domain.vm_guid
        INNER JOIN vm_device vd
            ON vd.vm_id = vm_static.vm_guid
        INNER JOIN images i
            ON i.image_group_id = vd.device_id
        INNER JOIN image_storage_domain_map
            ON i.image_guid = image_storage_domain_map.image_id
        WHERE image_storage_domain_map.storage_domain_id != v_storage_domain_id;

        -- Add VMs with direct luns as part of entity ids with disks on other storage domains.
        INSERT INTO ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
        SELECT DISTINCT vm_static.vm_guid
        FROM vm_static
        INNER JOIN vm_device vd
            ON vd.vm_id = vm_static.vm_guid
        INNER JOIN disk_lun_map dlm
            ON dlm.disk_id = vd.device_id;
    END;

    BEGIN
        -- Templates with any images residing on only the specified storage domain
        CREATE TEMPORARY TABLE TEMPLATES_IDS_TEMPORARY_TABLE ON COMMIT DROP AS

        SELECT vm_device.vm_id AS vm_guid
        FROM images_storage_domain_view
        INNER JOIN vm_device
            ON vm_device.device_id = images_storage_domain_view.disk_id
        INNER JOIN STORAGE_DOMAIN_MAP_TABLE
            ON STORAGE_DOMAIN_MAP_TABLE.image_id = images_storage_domain_view.image_guid
        WHERE entity_type = 'TEMPLATE'
            AND storage_id = v_storage_domain_id
            AND vm_device.vm_id NOT IN (
                SELECT vm_guid
                FROM ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
                );

        exception when others then

        TRUNCATE TABLE TEMPLATES_IDS_TEMPORARY_TABLE;

        INSERT INTO TEMPLATES_IDS_TEMPORARY_TABLE
        SELECT vm_device.vm_id AS vm_guid
        FROM images_storage_domain_view
        INNER JOIN vm_device
            ON vm_device.device_id = images_storage_domain_view.disk_id
        INNER JOIN STORAGE_DOMAIN_MAP_TABLE
            ON STORAGE_DOMAIN_MAP_TABLE.image_id = images_storage_domain_view.image_guid
        WHERE entity_type = 'TEMPLATE'
            AND storage_id = v_storage_domain_id
            AND vm_device.vm_id NOT IN (
                SELECT vm_guid
                FROM ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
                );
    END;

    -- Add also Template Versions based on the selected templates
    INSERT INTO TEMPLATES_IDS_TEMPORARY_TABLE
    SELECT vm_guid
    FROM vm_static
    WHERE vmt_guid IN (
            SELECT vm_guid
            FROM TEMPLATES_IDS_TEMPORARY_TABLE
            )
        AND entity_type = 'TEMPLATE';

    BEGIN
        -- Vms which resides on the storage domain
        CREATE TEMPORARY TABLE VM_IDS_TEMPORARY_TABLE ON COMMIT DROP AS

        SELECT vm_id,
            vm_images_view.entity_type AS entity_type
        FROM vm_images_view
        INNER JOIN vm_device
            ON vm_device.device_id = vm_images_view.disk_id
        WHERE v_storage_domain_id IN (
                SELECT *
                FROM fnsplitteruuid(storage_id)
                )
            AND vm_id NOT IN (
                SELECT vm_guid
                FROM ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
                );

        exception when others then

        TRUNCATE TABLE VM_IDS_TEMPORARY_TABLE;

        INSERT INTO VM_IDS_TEMPORARY_TABLE
        SELECT vm_id,
            vm_images_view.entity_type AS entity_type
        FROM vm_images_view
        INNER JOIN vm_device
            ON vm_device.device_id = vm_images_view.disk_id
        WHERE v_storage_domain_id IN (
                SELECT *
                FROM fnsplitteruuid(storage_id)
                )
            AND vm_id NOT IN (
                SELECT vm_guid
                FROM ENTITY_IDS_ON_OTHER_STORAGE_DOMAINS_TEMPORARY_TABLE
                );
    END;

    v_ids := array_agg(vm_id::UUID) AS vm_guid FROM VM_IDS_TEMPORARY_TABLE WHERE entity_type <> 'TEMPLATE';
    PERFORM DeletePermissionsByEntityIds(v_ids);

    DELETE
    FROM snapshots
    WHERE vm_id IN (
            SELECT vm_id AS vm_guid
            FROM VM_IDS_TEMPORARY_TABLE
            );

    DELETE
    FROM image_storage_domain_map
    WHERE storage_domain_id = v_storage_domain_id;

    DELETE
    FROM images
    WHERE image_guid IN (
            SELECT image_id
            FROM STORAGE_DOMAIN_MAP_TABLE
            );

    DELETE
    FROM vm_interface
    WHERE vm_guid IN (
            SELECT vm_guid
            FROM TEMPLATES_IDS_TEMPORARY_TABLE
            );

    v_ids := array_agg(vm_guid::UUID) FROM TEMPLATES_IDS_TEMPORARY_TABLE;
    PERFORM DeletePermissionsByEntityIds(v_ids);

    DELETE
    FROM vm_static
    WHERE vm_guid IN (
            SELECT vm_id AS vm_guid
            FROM VM_IDS_TEMPORARY_TABLE
            WHERE entity_type <> 'TEMPLATE'
            );

    -- Delete devices which are related to VMs/Templates with Multiple Storage Domain (VMs/Templates which has not removed)
    DELETE
    FROM vm_device
    WHERE device_id IN (
            SELECT disk_id
            FROM STORAGE_DOMAIN_MAP_TABLE
            );

    -- Delete pools and snapshots of pools based on templates from the storage domain to be removed
    DELETE
    FROM snapshots
    WHERE vm_id IN (
            SELECT vm_guid
            FROM vm_static
            WHERE vmt_guid IN (
                    SELECT vm_guid
                    FROM TEMPLATES_IDS_TEMPORARY_TABLE
                    )
            );

    DELETE
    FROM vm_static
    WHERE vmt_guid IN (
            SELECT vm_guid
            FROM TEMPLATES_IDS_TEMPORARY_TABLE
            );

    DELETE
    FROM vm_static
    WHERE vm_guid IN (
            SELECT vm_guid
            FROM TEMPLATES_IDS_TEMPORARY_TABLE
            );

    -- Deletes the disks which the only storage domain they are reside on, is the storage domain.
    DELETE
    FROM base_disks
    WHERE disk_id IN (
            SELECT disk_id
            FROM STORAGE_DOMAIN_MAP_TABLE
            );

    -- Deletes the disks's permissions which the only storage domain they are reside on, is the storage domain.
    v_ids := array_agg(disk_id::UUID) FROM STORAGE_DOMAIN_MAP_TABLE;
    PERFORM DeletePermissionsByEntityIds(v_ids);
END;$$;


ALTER FUNCTION public.remove_entities_from_storage_domain(v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: remove_nvram_data(); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.remove_nvram_data() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF OLD.bios_type = 4 AND NEW.bios_type != 4 THEN
        DELETE FROM vm_nvram_data
        WHERE vm_id = OLD.vm_guid;
    END IF;
    RETURN NEW;
END;$$;


ALTER FUNCTION public.remove_nvram_data() OWNER TO engine;

--
-- Name: removeallunmanageddevicesbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removeallunmanageddevicesbyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    DELETE FROM vm_device
    WHERE vm_id = v_vm_id
        AND NOT is_managed;
END;$$;


ALTER FUNCTION public.removeallunmanageddevicesbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: removeallvmtagsbyvmid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removeallvmtagsbyvmid(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM tags_vm_map
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.removeallvmtagsbyvmid(v_vm_id uuid) OWNER TO engine;

--
-- Name: removeauditlogbybrickidlogtype(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removeauditlogbybrickidlogtype(v_brick_id uuid, v_audit_log_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE audit_log
    SET deleted = true
    WHERE brick_id = v_brick_id
        AND log_type = v_audit_log_type;
END;$$;


ALTER FUNCTION public.removeauditlogbybrickidlogtype(v_brick_id uuid, v_audit_log_type integer) OWNER TO engine;

--
-- Name: removeconnectionfromiscsibond(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removeconnectionfromiscsibond(v_iscsi_bond_id uuid, v_connection_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM iscsi_bonds_storage_connections_map
    WHERE iscsi_bond_id = v_iscsi_bond_id
        AND connection_id = v_connection_id;
END;$$;


ALTER FUNCTION public.removeconnectionfromiscsibond(v_iscsi_bond_id uuid, v_connection_id character varying) OWNER TO engine;

--
-- Name: removediskfromunregistered(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removediskfromunregistered(v_disk_id uuid, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM unregistered_disks
    WHERE (disk_id = v_disk_id
        OR v_disk_id IS NULL)
        AND (
            storage_domain_id = v_storage_domain_id
            OR v_storage_domain_id IS NULL
            );
END;$$;


ALTER FUNCTION public.removediskfromunregistered(v_disk_id uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: removediskfromunregisteredrelatedtovm(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removediskfromunregisteredrelatedtovm(v_vm_id uuid, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM unregistered_disks
    WHERE disk_id IN (SELECT disk_id
                      FROM unregistered_disks_to_vms
                      WHERE entity_id = v_vm_id)
        AND (
            storage_domain_id = v_storage_domain_id
            OR v_storage_domain_id IS NULL
            );
END;$$;


ALTER FUNCTION public.removediskfromunregisteredrelatedtovm(v_vm_id uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: removeentityfromunregistered(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removeentityfromunregistered(v_entity_guid uuid, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM unregistered_ovf_of_entities
    WHERE entity_guid = v_entity_guid
        AND (
            storage_domain_id = v_storage_domain_id
            OR v_storage_domain_id IS NULL
            );
END;$$;


ALTER FUNCTION public.removeentityfromunregistered(v_entity_guid uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: removefinishedkdumpstatusforvds(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removefinishedkdumpstatusforvds(v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vds_kdump_status
    WHERE vds_id = v_vds_id
        AND status = 'finished';
END;$$;


ALTER FUNCTION public.removefinishedkdumpstatusforvds(v_vds_id uuid) OWNER TO engine;

--
-- Name: removememoryfromsnapshotbysnapshotid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removememoryfromsnapshotbysnapshotid(v_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET    memory_dump_disk_id = NULL,
           memory_metadata_disk_id = NULL
    WHERE  snapshot_id = v_snapshot_id;
END; $$;


ALTER FUNCTION public.removememoryfromsnapshotbysnapshotid(v_snapshot_id uuid) OWNER TO engine;

--
-- Name: removememoryfromsnapshotbyvmidandtype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removememoryfromsnapshotbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET    memory_dump_disk_id = NULL,
           memory_metadata_disk_id = NULL
    WHERE  vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type;
END; $$;


ALTER FUNCTION public.removememoryfromsnapshotbyvmidandtype(v_vm_id uuid, v_snapshot_type character varying) OWNER TO engine;

--
-- Name: removenetworkattachmentbynetworkid(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removenetworkattachmentbynetworkid(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM network_attachments na
    WHERE na.network_id = v_id;
END;$$;


ALTER FUNCTION public.removenetworkattachmentbynetworkid(v_id uuid) OWNER TO engine;

--
-- Name: removenetworkfromiscsibond(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removenetworkfromiscsibond(v_iscsi_bond_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM iscsi_bonds_networks_map
    WHERE iscsi_bond_id = v_iscsi_bond_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.removenetworkfromiscsibond(v_iscsi_bond_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: removesupportedhostfeature(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.removesupportedhostfeature(v_host_id uuid, v_feature_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM supported_host_features
    WHERE host_id = v_host_id
        AND feature_name = v_feature_name;
END;$$;


ALTER FUNCTION public.removesupportedhostfeature(v_host_id uuid, v_feature_name character varying) OWNER TO engine;

--
-- Name: set_network_exclusively_as_default_role_network(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.set_network_exclusively_as_default_role_network(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET default_route = true
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;

    IF FOUND THEN
        UPDATE network_cluster
        SET default_route = false
        WHERE cluster_id = v_cluster_id
            AND network_id != v_network_id;
    END IF;

END;$$;


ALTER FUNCTION public.set_network_exclusively_as_default_role_network(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: set_network_exclusively_as_display(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.set_network_exclusively_as_display(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET is_display = true
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;

    IF FOUND THEN
        UPDATE network_cluster
        SET is_display = false
        WHERE cluster_id = v_cluster_id
            AND network_id != v_network_id;
    END IF;

END;$$;


ALTER FUNCTION public.set_network_exclusively_as_display(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: set_network_exclusively_as_gluster(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.set_network_exclusively_as_gluster(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET is_gluster = COALESCE(network_id = v_network_id, false)
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.set_network_exclusively_as_gluster(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: set_network_exclusively_as_management(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.set_network_exclusively_as_management(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET management = true
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;

    IF FOUND THEN
        UPDATE network_cluster
        SET management = false
        WHERE cluster_id = v_cluster_id
            AND network_id != v_network_id;
    END IF;

END;$$;


ALTER FUNCTION public.set_network_exclusively_as_management(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: set_network_exclusively_as_migration(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.set_network_exclusively_as_migration(v_cluster_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET migration = true
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;

    IF FOUND THEN
        UPDATE network_cluster
        SET migration = false
        WHERE cluster_id = v_cluster_id
            AND network_id != v_network_id;
    END IF;

END;$$;


ALTER FUNCTION public.set_network_exclusively_as_migration(v_cluster_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: setaffinitygroupsforhost(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setaffinitygroupsforhost(v_host_id uuid, v_groups uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Remove existing entries for the host
    DELETE FROM affinity_group_members
    WHERE vds_id IS NOT NULL
        AND vds_id = v_host_id;

    -- Add the current entries for the host
    INSERT INTO affinity_group_members (
        affinity_group_id,
        vds_id
    )
    SELECT unnest(v_groups), v_host_id;
END;$$;


ALTER FUNCTION public.setaffinitygroupsforhost(v_host_id uuid, v_groups uuid[]) OWNER TO engine;

--
-- Name: setaffinitygroupsforvm(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setaffinitygroupsforvm(v_vm_id uuid, v_groups uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Remove existing entries for the VM
    DELETE FROM affinity_group_members
    WHERE vm_id IS NOT NULL
        AND vm_id = v_vm_id;

    -- Add the current entries for the VM
    INSERT INTO affinity_group_members (
        affinity_group_id,
        vm_id
    )
    SELECT unnest(v_groups), v_vm_id;
END;$$;


ALTER FUNCTION public.setaffinitygroupsforvm(v_vm_id uuid, v_groups uuid[]) OWNER TO engine;

--
-- Name: setallauditlogalerts(integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setallauditlogalerts(v_severity integer, v_value boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN


    UPDATE audit_log
    SET deleted = v_value
    FROM ( SELECT * FROM audit_log
           WHERE severity = v_severity
               AND deleted != v_value
           FOR UPDATE) AS s
    WHERE audit_log.audit_log_id = s.audit_log_id;

END;$$;


ALTER FUNCTION public.setallauditlogalerts(v_severity integer, v_value boolean) OWNER TO engine;

--
-- Name: setclusterupgraderunning(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setclusterupgraderunning(v_cluster_id uuid, v_correlation_id character varying, OUT v_updated boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE c_id UUID;
BEGIN
    SELECT cluster_id INTO c_id
    FROM cluster
    WHERE cluster_id = v_cluster_id
        AND upgrade_running = false
    FOR UPDATE;

    IF FOUND THEN
        UPDATE cluster
        SET upgrade_running = true,
            upgrade_correlation_id = v_correlation_id,
            upgrade_percent_complete = 0
        WHERE cluster_id = c_id;
    END IF;

    v_updated := FOUND;
END;$$;


ALTER FUNCTION public.setclusterupgraderunning(v_cluster_id uuid, v_correlation_id character varying, OUT v_updated boolean) OWNER TO engine;

--
-- Name: sethashbyvmguid(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.sethashbyvmguid(v_vm_guid uuid, v_hash character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET hash = v_hash
    WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.sethashbyvmguid(v_vm_guid uuid, v_hash character varying) OWNER TO engine;

--
-- Name: settounknown(uuid[], integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.settounknown(v_vm_ids uuid[], v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET status = v_status
    WHERE vm_guid = ANY(v_vm_ids)
        AND run_on_vds IS NOT NULL;
END;$$;


ALTER FUNCTION public.settounknown(v_vm_ids uuid[], v_status integer) OWNER TO engine;

--
-- Name: setvmidonhostdevice(uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setvmidonhostdevice(v_host_id uuid, v_device_name character varying, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE host_device
    SET vm_id = v_vm_id
    WHERE host_id = v_host_id
        AND device_name = v_device_name;
END;$$;


ALTER FUNCTION public.setvmidonhostdevice(v_host_id uuid, v_device_name character varying, v_vm_id uuid) OWNER TO engine;

--
-- Name: setvminterfacessyncedforvm(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setvminterfacessyncedforvm(v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_interface
    SET synced = true
    WHERE vm_interface.vm_guid = v_vm_id;

END;$$;


ALTER FUNCTION public.setvminterfacessyncedforvm(v_vm_id uuid) OWNER TO engine;

--
-- Name: setvmpoolbeingdestroyed(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.setvmpoolbeingdestroyed(v_vm_pool_id uuid, v_is_being_destroyed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_pools
    SET is_being_destroyed = v_is_being_destroyed
    WHERE vm_pool_id = v_vm_pool_id;
END;$$;


ALTER FUNCTION public.setvmpoolbeingdestroyed(v_vm_pool_id uuid, v_is_being_destroyed boolean) OWNER TO engine;

--
-- Name: sso_oauth_client_exists(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.sso_oauth_client_exists(v_client_id character varying) RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$

BEGIN
    IF EXISTS (
            SELECT 1
            FROM sso_clients
            WHERE client_id = v_client_id
            ) THEN
        RETURN QUERY
        SELECT 1;
    ELSE

        RETURN QUERY
        SELECT 0;
    END IF;

END;$$;


ALTER FUNCTION public.sso_oauth_client_exists(v_client_id character varying) OWNER TO engine;

--
-- Name: sso_oauth_register_client(character varying, character varying, character varying, character varying, character varying, text, character varying, boolean, boolean, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.sso_oauth_register_client(v_client_id character varying, v_client_secret character varying, v_scope character varying, v_certificate_location character varying DEFAULT NULL::character varying, v_callback_prefix character varying DEFAULT NULL::character varying, v_description text DEFAULT 'oVirt Engine'::text, v_email character varying DEFAULT ''::character varying, v_encrypted_userinfo boolean DEFAULT true, v_trusted boolean DEFAULT true, v_notification_callback character varying DEFAULT NULL::character varying, v_notification_callback_protocol character varying DEFAULT 'TLSv1'::character varying, v_notification_callback_verify_host boolean DEFAULT true, v_notification_callback_verify_chain boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    -- Adding the sso client
    INSERT INTO sso_clients (
        client_id,
        client_secret,
        scope,
        certificate_location,
        callback_prefix,
        description,
        email,
        encrypted_userinfo,
        trusted,
        notification_callback,
        notification_callback_protocol,
        notification_callback_verify_host,
        notification_callback_verify_chain
        )
    VALUES (
        v_client_id,
        v_client_secret,
        v_scope,
        v_certificate_location,
        v_callback_prefix,
        v_description,
        v_email,
        v_encrypted_userinfo,
        v_trusted,
        v_notification_callback,
        v_notification_callback_protocol,
        v_notification_callback_verify_host,
        v_notification_callback_verify_chain
        );
END;$$;


ALTER FUNCTION public.sso_oauth_register_client(v_client_id character varying, v_client_secret character varying, v_scope character varying, v_certificate_location character varying, v_callback_prefix character varying, v_description text, v_email character varying, v_encrypted_userinfo boolean, v_trusted boolean, v_notification_callback character varying, v_notification_callback_protocol character varying, v_notification_callback_verify_host boolean, v_notification_callback_verify_chain boolean) OWNER TO engine;

--
-- Name: sso_oauth_unregister_client(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.sso_oauth_unregister_client(v_client_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    -- Removing the sso client
    DELETE
    FROM sso_clients
    WHERE client_id = v_client_id;
END;$$;


ALTER FUNCTION public.sso_oauth_unregister_client(v_client_id character varying) OWNER TO engine;

--
-- Name: update_oauth_client(character varying, character varying, character varying, character varying, text, character varying, boolean, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.update_oauth_client(v_client_id character varying, v_scope character varying, v_certificate_location character varying DEFAULT NULL::character varying, v_callback_prefix character varying DEFAULT NULL::character varying, v_description text DEFAULT 'oVirt Engine'::text, v_email character varying DEFAULT ''::character varying, v_encrypted_userinfo boolean DEFAULT true, v_trusted boolean DEFAULT true, v_notification_callback character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE sso_clients
    SET scope = v_scope,
        certificate_location = v_certificate_location,
        callback_prefix = v_callback_prefix,
        description = v_description,
        email = v_email,
        encrypted_userinfo = v_encrypted_userinfo,
        trusted = v_trusted,
        notification_callback = v_notification_callback
    WHERE client_id = v_client_id;
END;$$;


ALTER FUNCTION public.update_oauth_client(v_client_id character varying, v_scope character varying, v_certificate_location character varying, v_callback_prefix character varying, v_description text, v_email character varying, v_encrypted_userinfo boolean, v_trusted boolean, v_notification_callback character varying) OWNER TO engine;

--
-- Name: update_oauth_client_callback_prefix(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.update_oauth_client_callback_prefix(v_client_id character varying, v_callback_prefix character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE sso_clients
    SET callback_prefix = v_callback_prefix
    WHERE client_id = v_client_id;
END;$$;


ALTER FUNCTION public.update_oauth_client_callback_prefix(v_client_id character varying, v_callback_prefix character varying) OWNER TO engine;

--
-- Name: updateaffinitygroupwithmembers(uuid, character varying, character varying, uuid, boolean, boolean, boolean, boolean, boolean, boolean, bigint, uuid[], uuid[], uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateaffinitygroupwithmembers(v_id uuid, v_name character varying, v_description character varying, v_cluster_id uuid, v_vm_positive boolean, v_vm_enforcing boolean, v_vds_positive boolean, v_vds_enforcing boolean, v_vms_affinity_enabled boolean, v_vds_affinity_enabled boolean, v_priority bigint, v_vm_ids uuid[], v_vds_ids uuid[], v_vm_label_ids uuid[], v_host_label_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM DeleteAffinityGroup(v_id);

    PERFORM InsertAffinityGroupWithMembers(
        v_id,
        v_name,
        v_description,
        v_cluster_id,
        v_vm_positive,
        v_vm_enforcing,
        v_vds_positive,
        v_vds_enforcing,
        v_vms_affinity_enabled,
        v_vds_affinity_enabled,
        v_priority,
        v_vm_ids,
        v_vds_ids,
        v_vm_label_ids,
        v_host_label_ids);
END;$$;


ALTER FUNCTION public.updateaffinitygroupwithmembers(v_id uuid, v_name character varying, v_description character varying, v_cluster_id uuid, v_vm_positive boolean, v_vm_enforcing boolean, v_vds_positive boolean, v_vds_enforcing boolean, v_vms_affinity_enabled boolean, v_vds_affinity_enabled boolean, v_priority bigint, v_vm_ids uuid[], v_vds_ids uuid[], v_vm_label_ids uuid[], v_host_label_ids uuid[]) OWNER TO engine;

--
-- Name: updateasync_tasks(integer, integer, integer, uuid, uuid, uuid, uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateasync_tasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_storage_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE async_tasks
    SET action_type = v_action_type,
        result = v_result,
        status = v_status,
        step_id = v_step_id,
        command_id = v_command_id,
        root_command_id = v_root_command_id,
        vdsm_task_id = v_vdsm_task_id,
        storage_pool_id = v_storage_pool_id
    WHERE task_id = v_task_id;
END;$$;


ALTER FUNCTION public.updateasync_tasks(v_action_type integer, v_result integer, v_status integer, v_user_id uuid, v_vdsm_task_id uuid, v_task_id uuid, v_step_id uuid, v_command_id uuid, v_root_command_id uuid, v_storage_pool_id uuid) OWNER TO engine;

--
-- Name: updatebasedisk(uuid, boolean, character varying, character varying, character varying, boolean, integer, smallint, character varying, smallint, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatebasedisk(v_disk_id uuid, v_wipe_after_delete boolean, v_propagate_errors character varying, v_disk_alias character varying, v_disk_description character varying, v_shareable boolean, v_sgio integer, v_disk_storage_type smallint, v_cinder_volume_type character varying, v_disk_content_type smallint, v_backup character varying, v_backup_mode character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE base_disks
    SET wipe_after_delete = v_wipe_after_delete,
        propagate_errors = v_propagate_errors,
        disk_alias = v_disk_alias,
        disk_description = v_disk_description,
        shareable = v_shareable,
        sgio = v_sgio,
        disk_storage_type = v_disk_storage_type,
        cinder_volume_type = v_cinder_volume_type,
        disk_content_type = v_disk_content_type,
        backup = v_backup,
        backup_mode = v_backup_mode
    WHERE disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.updatebasedisk(v_disk_id uuid, v_wipe_after_delete boolean, v_propagate_errors character varying, v_disk_alias character varying, v_disk_description character varying, v_shareable boolean, v_sgio integer, v_disk_storage_type smallint, v_cinder_volume_type character varying, v_disk_content_type smallint, v_backup character varying, v_backup_mode character varying) OWNER TO engine;

--
-- Name: updatebookmark(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatebookmark(v_bookmark_id uuid, v_bookmark_name character varying, v_bookmark_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE bookmarks
    SET bookmark_name = v_bookmark_name,
        bookmark_value = v_bookmark_value
    WHERE bookmark_Id = v_bookmark_id;
END;$$;


ALTER FUNCTION public.updatebookmark(v_bookmark_id uuid, v_bookmark_name character varying, v_bookmark_value character varying) OWNER TO engine;

--
-- Name: updatecinderstorage(uuid, jsonb, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecinderstorage(v_storage_domain_id uuid, v_driver_options jsonb, v_driver_sensitive_options text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cinder_storage
    SET driver_options = v_driver_options,
        driver_sensitive_options = v_driver_sensitive_options
    WHERE storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.updatecinderstorage(v_storage_domain_id uuid, v_driver_options jsonb, v_driver_sensitive_options text) OWNER TO engine;

--
-- Name: updatecluster(character varying, text, character varying, uuid, character varying, text, text, uuid, integer, boolean, character varying, boolean, integer, boolean, boolean, boolean, boolean, character varying, boolean, integer, boolean, boolean, uuid, text, boolean, integer, smallint, character varying, boolean, smallint, character varying, character varying, boolean, boolean, smallint, boolean, boolean, boolean, boolean, character varying, boolean, character varying, integer, uuid, uuid, character varying, boolean, boolean, integer, uuid, integer, smallint, boolean, boolean, boolean, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecluster(v_description character varying, v_free_text_comment text, v_name character varying, v_cluster_id uuid, v_cpu_name character varying, v_cpu_flags text, v_cpu_verb text, v_storage_pool_id uuid, v_max_vds_memory_over_commit integer, v_count_threads_as_cores boolean, v_compatibility_version character varying, v_transparent_hugepages boolean, v_migrate_on_error integer, v_virt_service boolean, v_gluster_service boolean, v_gluster_cli_based_snapshot_scheduled boolean, v_tunnel_migration boolean, v_emulated_machine character varying, v_detect_emulated_machine boolean, v_bios_type integer, v_trusted_service boolean, v_ha_reservation boolean, v_cluster_policy_id uuid, v_cluster_policy_custom_properties text, v_enable_balloon boolean, v_architecture integer, v_optimization_type smallint, v_spice_proxy character varying, v_enable_ksm boolean, v_serial_number_policy smallint, v_custom_serial_number character varying, v_additional_rng_sources character varying, v_skip_fencing_if_sd_active boolean, v_skip_fencing_if_connectivity_broken boolean, v_hosts_with_broken_connectivity_threshold smallint, v_fencing_enabled boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_gluster_tuned_profile character varying, v_ksm_merge_across_nodes boolean, v_migration_bandwidth_limit_type character varying, v_custom_migration_bandwidth_limit integer, v_migration_policy_id uuid, v_mac_pool_id uuid, v_switch_type character varying, v_skip_fencing_if_gluster_bricks_up boolean, v_skip_fencing_if_gluster_quorum_not_met boolean, v_firewall_type integer, v_default_network_provider_id uuid, v_log_max_memory_used_threshold integer, v_log_max_memory_used_threshold_type smallint, v_vnc_encryption_enabled boolean, v_smt_disabled boolean, v_managed boolean, v_fips_mode smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster
    SET description = v_description,
        free_text_comment = v_free_text_comment,
        name = v_name,
        cpu_name = v_cpu_name,
        cpu_flags = v_cpu_flags,
        cpu_verb = v_cpu_verb,
        storage_pool_id = v_storage_pool_id,
        _update_date = LOCALTIMESTAMP,
        max_vds_memory_over_commit = v_max_vds_memory_over_commit,
        count_threads_as_cores = v_count_threads_as_cores,
        compatibility_version = v_compatibility_version,
        transparent_hugepages = v_transparent_hugepages,
        migrate_on_error = v_migrate_on_error,
        virt_service = v_virt_service,
        gluster_service = v_gluster_service,
        tunnel_migration = v_tunnel_migration,
        gluster_cli_based_snapshot_scheduled = v_gluster_cli_based_snapshot_scheduled,
        emulated_machine = v_emulated_machine,
        detect_emulated_machine = v_detect_emulated_machine,
        bios_type = v_bios_type,
        trusted_service = v_trusted_service,
        ha_reservation = v_ha_reservation,
        cluster_policy_id = v_cluster_policy_id,
        cluster_policy_custom_properties = v_cluster_policy_custom_properties,
        enable_balloon = v_enable_balloon,
        architecture = v_architecture,
        optimization_type = v_optimization_type,
        spice_proxy = v_spice_proxy,
        enable_ksm = v_enable_ksm,
        serial_number_policy = v_serial_number_policy,
        custom_serial_number = v_custom_serial_number,
        additional_rng_sources = v_additional_rng_sources,
        skip_fencing_if_sd_active = v_skip_fencing_if_sd_active,
        skip_fencing_if_connectivity_broken = v_skip_fencing_if_connectivity_broken,
        hosts_with_broken_connectivity_threshold = v_hosts_with_broken_connectivity_threshold,
        fencing_enabled = v_fencing_enabled,
        is_auto_converge = v_is_auto_converge,
        is_migrate_compressed = v_is_migrate_compressed,
        is_migrate_encrypted = v_is_migrate_encrypted,
        gluster_tuned_profile = v_gluster_tuned_profile,
        ksm_merge_across_nodes = v_ksm_merge_across_nodes,
        migration_bandwidth_limit_type = v_migration_bandwidth_limit_type,
        custom_migration_bandwidth_limit = v_custom_migration_bandwidth_limit,
        migration_policy_id = v_migration_policy_id,
        mac_pool_id = v_mac_pool_id,
        switch_type = v_switch_type,
        skip_fencing_if_gluster_bricks_up = v_skip_fencing_if_gluster_bricks_up,
        skip_fencing_if_gluster_quorum_not_met = v_skip_fencing_if_gluster_quorum_not_met,
        firewall_type = v_firewall_type,
        default_network_provider_id = v_default_network_provider_id,
        log_max_memory_used_threshold = v_log_max_memory_used_threshold,
        log_max_memory_used_threshold_type = v_log_max_memory_used_threshold_type,
        vnc_encryption_enabled = v_vnc_encryption_enabled,
        smt_disabled = v_smt_disabled,
        managed = v_managed,
        fips_mode = v_fips_mode,
        parallel_migrations = v_parallel_migrations
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.updatecluster(v_description character varying, v_free_text_comment text, v_name character varying, v_cluster_id uuid, v_cpu_name character varying, v_cpu_flags text, v_cpu_verb text, v_storage_pool_id uuid, v_max_vds_memory_over_commit integer, v_count_threads_as_cores boolean, v_compatibility_version character varying, v_transparent_hugepages boolean, v_migrate_on_error integer, v_virt_service boolean, v_gluster_service boolean, v_gluster_cli_based_snapshot_scheduled boolean, v_tunnel_migration boolean, v_emulated_machine character varying, v_detect_emulated_machine boolean, v_bios_type integer, v_trusted_service boolean, v_ha_reservation boolean, v_cluster_policy_id uuid, v_cluster_policy_custom_properties text, v_enable_balloon boolean, v_architecture integer, v_optimization_type smallint, v_spice_proxy character varying, v_enable_ksm boolean, v_serial_number_policy smallint, v_custom_serial_number character varying, v_additional_rng_sources character varying, v_skip_fencing_if_sd_active boolean, v_skip_fencing_if_connectivity_broken boolean, v_hosts_with_broken_connectivity_threshold smallint, v_fencing_enabled boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_gluster_tuned_profile character varying, v_ksm_merge_across_nodes boolean, v_migration_bandwidth_limit_type character varying, v_custom_migration_bandwidth_limit integer, v_migration_policy_id uuid, v_mac_pool_id uuid, v_switch_type character varying, v_skip_fencing_if_gluster_bricks_up boolean, v_skip_fencing_if_gluster_quorum_not_met boolean, v_firewall_type integer, v_default_network_provider_id uuid, v_log_max_memory_used_threshold integer, v_log_max_memory_used_threshold_type smallint, v_vnc_encryption_enabled boolean, v_smt_disabled boolean, v_managed boolean, v_fips_mode smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: updateclusteremulatedmachine(uuid, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateclusteremulatedmachine(v_cluster_id uuid, v_emulated_machine character varying, v_detect_emulated_machine boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster
    SET emulated_machine = v_emulated_machine,
        detect_emulated_machine = v_detect_emulated_machine
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.updateclusteremulatedmachine(v_cluster_id uuid, v_emulated_machine character varying, v_detect_emulated_machine boolean) OWNER TO engine;

--
-- Name: updateclusterfeature(uuid, character varying, character varying, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateclusterfeature(v_feature_id uuid, v_feature_name character varying, v_version character varying, v_category integer, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster_features
    SET feature_name = v_feature_name,
        version = v_version,
        description = v_description,
        category = v_category
    WHERE feature_id = v_feature_id;
END;$$;


ALTER FUNCTION public.updateclusterfeature(v_feature_id uuid, v_feature_name character varying, v_version character varying, v_category integer, v_description text) OWNER TO engine;

--
-- Name: updateclusterpolicy(uuid, character varying, character varying, boolean, boolean, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateclusterpolicy(v_id uuid, v_name character varying, v_description character varying, v_is_locked boolean, v_is_default boolean, v_custom_properties text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cluster_policies
    SET name = v_name,
        description = v_description,
        is_locked = v_is_locked,
        is_default = v_is_default,
        custom_properties = v_custom_properties
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateclusterpolicy(v_id uuid, v_name character varying, v_description character varying, v_is_locked boolean, v_is_default boolean, v_custom_properties text) OWNER TO engine;

--
-- Name: updateclusterupgradeprogress(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateclusterupgradeprogress(v_cluster_id uuid, v_upgrade_percent_complete integer, OUT v_updated boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE c_id UUID;
BEGIN
    SELECT cluster_id INTO c_id
    FROM cluster
    WHERE cluster_id = v_cluster_id
        AND upgrade_running = true
    FOR UPDATE;

    IF FOUND THEN
        UPDATE cluster
        SET upgrade_percent_complete = v_upgrade_percent_complete
        WHERE cluster_id = c_id;
    END IF;

    v_updated := FOUND;
END;$$;


ALTER FUNCTION public.updateclusterupgradeprogress(v_cluster_id uuid, v_upgrade_percent_complete integer, OUT v_updated boolean) OWNER TO engine;

--
-- Name: updatecommandentity(uuid, bigint, uuid, integer, uuid, uuid, text, text, character varying, character varying, boolean, boolean, text, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE command_entities
    SET command_type = v_command_type,
        user_id = v_user_id,
        engine_session_seq_id = v_engine_session_seq_id,
        parent_command_id = v_parent_command_id,
        root_command_id = v_root_command_id,
        command_context = v_command_context,
        command_parameters = v_command_parameters,
        command_params_class = v_command_params_class,
        status = v_status,
        executed = v_executed,
        callback_enabled = v_callback_enabled,
        return_value = v_return_value,
        return_value_class = v_return_value_class,
        data = v_data
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.updatecommandentity(v_user_id uuid, v_engine_session_seq_id bigint, v_command_id uuid, v_command_type integer, v_parent_command_id uuid, v_root_command_id uuid, v_command_context text, v_command_parameters text, v_command_params_class character varying, v_status character varying, v_executed boolean, v_callback_enabled boolean, v_return_value text, v_return_value_class character varying, v_data text) OWNER TO engine;

--
-- Name: updatecommandentityexecuted(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecommandentityexecuted(v_command_id uuid, v_executed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE command_entities
    SET executed = v_executed
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.updatecommandentityexecuted(v_command_id uuid, v_executed boolean) OWNER TO engine;

--
-- Name: updatecommandentitynotified(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecommandentitynotified(v_command_id uuid, v_callback_notified boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE command_entities
    SET callback_notified = v_callback_notified
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.updatecommandentitynotified(v_command_id uuid, v_callback_notified boolean) OWNER TO engine;

--
-- Name: updatecommandentitystatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecommandentitystatus(v_command_id uuid, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
    UPDATE command_entities
    SET status = v_status
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.updatecommandentitystatus(v_command_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: updateconfigbyclusteridandname(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateconfigbyclusteridandname(v_cluster_id uuid, v_param_name character varying, v_param_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_snapshot_config
    SET param_value = v_param_value,
        _update_date = LOCALTIMESTAMP
    WHERE cluster_id = v_cluster_id
        AND volume_id IS NULL
        AND param_name = v_param_name;
END;$$;


ALTER FUNCTION public.updateconfigbyclusteridandname(v_cluster_id uuid, v_param_name character varying, v_param_value character varying) OWNER TO engine;

--
-- Name: updateconfigbyvolumeididandname(uuid, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateconfigbyvolumeididandname(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying, v_param_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_snapshot_config
    SET param_value = v_param_value,
        _update_date = LOCALTIMESTAMP
    WHERE cluster_id = v_cluster_id
        AND volume_id = v_volume_id
        AND param_name = v_param_name;
END;$$;


ALTER FUNCTION public.updateconfigbyvolumeididandname(v_cluster_id uuid, v_volume_id uuid, v_param_name character varying, v_param_value character varying) OWNER TO engine;

--
-- Name: updatecpuflags(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecpuflags(v_vds_id uuid, v_cpu_flags character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET cpu_flags = v_cpu_flags
    WHERE vds_id = v_vds_id;
END;$$;


ALTER FUNCTION public.updatecpuflags(v_vds_id uuid, v_cpu_flags character varying) OWNER TO engine;

--
-- Name: updatecpuprofile(uuid, character varying, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecpuprofile(v_id uuid, v_name character varying, v_cluster_id uuid, v_qos_id uuid, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE cpu_profiles
    SET id = v_id,
        name = v_name,
        cluster_id = v_cluster_id,
        qos_id = v_qos_id,
        description = v_description,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatecpuprofile(v_id uuid, v_name character varying, v_cluster_id uuid, v_qos_id uuid, v_description text) OWNER TO engine;

--
-- Name: updatecpuqos(uuid, smallint, character varying, text, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecpuqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_cpu_limit integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE qos
    SET qos_type = v_qos_type,
        name = v_name,
        description = v_description,
        storage_pool_id = v_storage_pool_id,
        cpu_limit = v_cpu_limit,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatecpuqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_cpu_limit integer) OWNER TO engine;

--
-- Name: updatecustom_actions(integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatecustom_actions(v_action_id integer, v_action_name character varying, v_path character varying, v_tab integer, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE custom_actions
    SET action_name = v_action_name,
        path = v_path,
        tab = v_tab,
        description = v_description
    WHERE action_id = v_action_id;
END;$$;


ALTER FUNCTION public.updatecustom_actions(v_action_id integer, v_action_name character varying, v_path character varying, v_tab integer, v_description character varying) OWNER TO engine;

--
-- Name: updatededicatedhoststovm(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatededicatedhoststovm(v_vm_guid uuid, v_dedicated_vm_for_vds text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE
    FROM vm_host_pinning_map
    WHERE vm_id = v_vm_guid;

    PERFORM InsertDedicatedHostsToVm(v_vm_guid, v_dedicated_vm_for_vds);
END;$$;


ALTER FUNCTION public.updatededicatedhoststovm(v_vm_guid uuid, v_dedicated_vm_for_vds text) OWNER TO engine;

--
-- Name: updatedisk_image_dynamic(uuid, bigint, bigint, bigint, bigint, bigint, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatedisk_image_dynamic(v_image_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE disk_image_dynamic
    SET read_rate = v_read_rate,
        read_ops = v_read_ops,
        write_rate = v_write_rate,
        write_ops = v_write_ops,
        actual_size = v_actual_size,
        read_latency_seconds = v_read_latency_seconds,
        write_latency_seconds = v_write_latency_seconds,
        flush_latency_seconds = v_flush_latency_seconds,
        _update_date = LOCALTIMESTAMP
    WHERE image_id = v_image_id;
END;$$;


ALTER FUNCTION public.updatedisk_image_dynamic(v_image_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) OWNER TO engine;

--
-- Name: updatedisk_image_dynamic_by_disk_id_and_vm_id(uuid, uuid, bigint, bigint, bigint, bigint, bigint, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatedisk_image_dynamic_by_disk_id_and_vm_id(v_image_group_id uuid, v_vm_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE disk_image_dynamic
    SET read_rate = v_read_rate,
        read_ops = v_read_ops,
        write_rate = v_write_rate,
        write_ops = v_write_ops,
        actual_size = v_actual_size,
        read_latency_seconds = v_read_latency_seconds,
        write_latency_seconds = v_write_latency_seconds,
        flush_latency_seconds = v_flush_latency_seconds,
        _update_date = LOCALTIMESTAMP
    WHERE image_id IN (
            SELECT DISTINCT image_guid
            FROM images
            WHERE image_group_id = v_image_group_id
                AND active = true
            )
        AND EXISTS (
            SELECT 1
            FROM vm_device vmd
            WHERE vmd.vm_id = v_vm_id
                AND vmd.device_id = v_image_group_id
                AND vmd.snapshot_id IS NULL
            );
END;$$;


ALTER FUNCTION public.updatedisk_image_dynamic_by_disk_id_and_vm_id(v_image_group_id uuid, v_vm_id uuid, v_read_rate bigint, v_read_ops bigint, v_write_rate bigint, v_write_ops bigint, v_actual_size bigint, v_read_latency_seconds numeric, v_write_latency_seconds numeric, v_flush_latency_seconds numeric) OWNER TO engine;

--
-- Name: updatediskprofile(uuid, character varying, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatediskprofile(v_id uuid, v_name character varying, v_storage_domain_id uuid, v_qos_id uuid, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE disk_profiles
    SET id = v_id,
        name = v_name,
        storage_domain_id = v_storage_domain_id,
        qos_id = v_qos_id,
        description = v_description,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatediskprofile(v_id uuid, v_name character varying, v_storage_domain_id uuid, v_qos_id uuid, v_description text) OWNER TO engine;

--
-- Name: updatediskprofilebyimagegroupid(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatediskprofilebyimagegroupid(v_image_group_id uuid, v_storage_domain_id uuid, v_disk_profile_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE image_storage_domain_map AS isdm
    SET disk_profile_id = v_disk_profile_id
    FROM images AS i
    WHERE i.image_group_id = v_image_group_id
        AND i.image_guid = isdm.image_id
        AND storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.updatediskprofilebyimagegroupid(v_image_group_id uuid, v_storage_domain_id uuid, v_disk_profile_id uuid) OWNER TO engine;

--
-- Name: updatediskvmelement(uuid, uuid, boolean, boolean, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatediskvmelement(v_disk_id uuid, v_vm_id uuid, v_is_boot boolean, v_pass_discard boolean, v_disk_interface character varying, v_is_using_scsi_reservation boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE disk_vm_element
    SET disk_id = v_disk_id,
        vm_id = v_vm_id,
        is_boot = v_is_boot,
        pass_discard = v_pass_discard,
        disk_interface = v_disk_interface,
        is_using_scsi_reservation = v_is_using_scsi_reservation
    WHERE disk_id = v_disk_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.updatediskvmelement(v_disk_id uuid, v_vm_id uuid, v_is_boot boolean, v_pass_discard boolean, v_disk_interface character varying, v_is_using_scsi_reservation boolean) OWNER TO engine;

--
-- Name: updatednsresolverconfiguration(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatednsresolverconfiguration(v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE dns_resolver_configuration
    SET id = v_id
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatednsresolverconfiguration(v_id uuid) OWNER TO engine;

--
-- Name: updatedwhhistorytimekeeping(character varying, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatedwhhistorytimekeeping(v_var_name character varying, v_var_value character varying, v_var_datetime timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE dwh_history_timekeeping
    SET var_value = v_var_value,
        var_datetime = v_var_datetime
    WHERE var_name = v_var_name;
END;$$;


ALTER FUNCTION public.updatedwhhistorytimekeeping(v_var_name character varying, v_var_value character varying, v_var_datetime timestamp with time zone) OWNER TO engine;

--
-- Name: updateexternallease(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateexternallease(v_lease_id uuid, v_storage_domain_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE external_leases
    SET storage_domain_id = v_storage_domain_id
    WHERE lease_id = v_lease_id;
END;$$;


ALTER FUNCTION public.updateexternallease(v_lease_id uuid, v_storage_domain_id uuid) OWNER TO engine;

--
-- Name: updateexternalvariable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateexternalvariable(v_var_name character varying, v_var_value character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE external_variable
    SET var_value = v_var_value,
        _update_date = LOCALTIMESTAMP
    WHERE var_name = v_var_name;

    RETURN found;
END;$$;


ALTER FUNCTION public.updateexternalvariable(v_var_name character varying, v_var_value character varying) OWNER TO engine;

--
-- Name: updatefenceagent(uuid, uuid, integer, character varying, character varying, character varying, text, text, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatefenceagent(v_guid uuid, v_vds_id uuid, v_agent_order integer, v_ip character varying, v_type character varying, v_agent_user character varying, v_agent_password text, v_options text, v_encrypt_options boolean, v_port integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE fence_agents
    SET vds_id = v_vds_id,
        agent_order = v_agent_order,
        ip = v_ip,
        type = v_type,
        agent_user = v_agent_user,
        agent_password = v_agent_password,
        port = v_port,
        options = v_options,
        encrypt_options = v_encrypt_options
    WHERE id = v_guid;
END;$$;


ALTER FUNCTION public.updatefenceagent(v_guid uuid, v_vds_id uuid, v_agent_order integer, v_ip character varying, v_type character varying, v_agent_user character varying, v_agent_password text, v_options text, v_encrypt_options boolean, v_port integer) OWNER TO engine;

--
-- Name: updateglusterbricktaskbyserveridbrickdir(uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterbricktaskbyserveridbrickdir(v_server_id uuid, v_brick_dir character varying, v_task_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET task_id = v_task_id,
        _update_date = LOCALTIMESTAMP
    WHERE server_id = v_server_id
        AND brick_dir = v_brick_dir;
END;$$;


ALTER FUNCTION public.updateglusterbricktaskbyserveridbrickdir(v_server_id uuid, v_brick_dir character varying, v_task_id uuid) OWNER TO engine;

--
-- Name: updateglusterclusterservice(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterclusterservice(v_cluster_id uuid, v_service_type character varying, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_cluster_services
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE cluster_id = v_cluster_id
        AND service_type = v_service_type;
END;$$;


ALTER FUNCTION public.updateglusterclusterservice(v_cluster_id uuid, v_service_type character varying, v_status character varying) OWNER TO engine;

--
-- Name: updateglustergeorepsession(uuid, character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustergeorepsession(v_session_id uuid, v_status character varying, v_slave_host_uuid uuid, v_slave_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_georep_session
    SET status = v_status,
        slave_host_uuid = v_slave_host_uuid,
        slave_volume_id = v_slave_volume_id,
        _update_date = LOCALTIMESTAMP
    WHERE session_id = v_session_id;
END;$$;


ALTER FUNCTION public.updateglustergeorepsession(v_session_id uuid, v_status character varying, v_slave_host_uuid uuid, v_slave_volume_id uuid) OWNER TO engine;

--
-- Name: updateglustergeorepsessionconfig(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustergeorepsessionconfig(v_session_id uuid, v_config_key character varying, v_config_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_georep_config
    SET config_value = v_config_value,
        _update_date = LOCALTIMESTAMP
    WHERE session_id = v_session_id
        AND config_key = v_config_key;
END;$$;


ALTER FUNCTION public.updateglustergeorepsessionconfig(v_session_id uuid, v_config_key character varying, v_config_value character varying) OWNER TO engine;

--
-- Name: updateglustergeorepsessiondetail(uuid, uuid, character varying, uuid, character varying, character varying, character varying, bigint, bigint, bigint, bigint, timestamp without time zone, timestamp without time zone, timestamp without time zone, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustergeorepsessiondetail(v_session_id uuid, v_master_brick_id uuid, v_slave_host_name character varying, v_slave_host_uuid uuid, v_status character varying, v_checkpoint_status character varying, v_crawl_status character varying, v_data_pending bigint, v_entry_pending bigint, v_meta_pending bigint, v_failures bigint, v_last_synced_at timestamp without time zone, v_checkpoint_time timestamp without time zone, v_checkpoint_completed_time timestamp without time zone, v_is_checkpoint_completed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_georep_session_details
    SET slave_host_name = v_slave_host_name,
        slave_host_uuid = v_slave_host_uuid,
        status = v_status,
        checkpoint_status = v_checkpoint_status,
        crawl_status = v_crawl_status,
        data_pending = v_data_pending,
        entry_pending = v_entry_pending,
        meta_pending = v_meta_pending,
        failures = v_failures,
        last_synced_at = v_last_synced_at,
        checkpoint_time = v_checkpoint_time,
        checkpoint_completed_time = v_checkpoint_completed_time,
        is_checkpoint_completed = v_is_checkpoint_completed,
        _update_date = LOCALTIMESTAMP
    WHERE session_id = v_session_id
        AND master_brick_id = v_master_brick_id;
END;$$;


ALTER FUNCTION public.updateglustergeorepsessiondetail(v_session_id uuid, v_master_brick_id uuid, v_slave_host_name character varying, v_slave_host_uuid uuid, v_status character varying, v_checkpoint_status character varying, v_crawl_status character varying, v_data_pending bigint, v_entry_pending bigint, v_meta_pending bigint, v_failures bigint, v_last_synced_at timestamp without time zone, v_checkpoint_time timestamp without time zone, v_checkpoint_completed_time timestamp without time zone, v_is_checkpoint_completed boolean) OWNER TO engine;

--
-- Name: updateglusterglobalvolumeoption(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterglobalvolumeoption(v_cluster_id uuid, v_option_key character varying, v_option_val character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_global_volume_options
    SET option_val = v_option_val
    WHERE cluster_id = v_cluster_id
        AND option_key = v_option_key;
END;$$;


ALTER FUNCTION public.updateglusterglobalvolumeoption(v_cluster_id uuid, v_option_key character varying, v_option_val character varying) OWNER TO engine;

--
-- Name: updateglusterhook(uuid, character varying, character varying, character varying, text, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterhook(v_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying, v_content text, v_conflict_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_hooks
    SET hook_status = v_hook_status,
        content_type = v_content_type,
        checksum = v_checksum,
        content = v_content,
        conflict_status = v_conflict_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterhook(v_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying, v_content text, v_conflict_status integer) OWNER TO engine;

--
-- Name: updateglusterhookconflictstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterhookconflictstatus(v_id uuid, v_conflict_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_hooks
    SET conflict_status = v_conflict_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterhookconflictstatus(v_id uuid, v_conflict_status integer) OWNER TO engine;

--
-- Name: updateglusterhookcontent(uuid, character varying, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterhookcontent(v_id uuid, v_checksum character varying, v_content text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_hooks
    SET checksum = v_checksum,
        content = v_content,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterhookcontent(v_id uuid, v_checksum character varying, v_content text) OWNER TO engine;

--
-- Name: updateglusterhookcontenttype(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterhookcontenttype(v_id uuid, v_content_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_hooks
    SET content_type = v_content_type,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterhookcontenttype(v_id uuid, v_content_type character varying) OWNER TO engine;

--
-- Name: updateglusterhookstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterhookstatus(v_id uuid, v_hook_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_hooks
    SET hook_status = v_hook_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterhookstatus(v_id uuid, v_hook_status character varying) OWNER TO engine;

--
-- Name: updateglusterserver(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserver(v_server_id uuid, v_gluster_server_uuid uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server
    SET gluster_server_uuid = v_gluster_server_uuid
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.updateglusterserver(v_server_id uuid, v_gluster_server_uuid uuid) OWNER TO engine;

--
-- Name: updateglusterserverhook(uuid, uuid, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverhook(v_hook_id uuid, v_server_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server_hooks
    SET hook_status = v_hook_status,
        content_type = v_content_type,
        checksum = v_checksum,
        _update_date = LOCALTIMESTAMP
    WHERE hook_id = v_hook_id
        AND server_id = v_server_id;

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id = v_hook_id;
END;$$;


ALTER FUNCTION public.updateglusterserverhook(v_hook_id uuid, v_server_id uuid, v_hook_status character varying, v_content_type character varying, v_checksum character varying) OWNER TO engine;

--
-- Name: updateglusterserverhookchecksum(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverhookchecksum(v_hook_id uuid, v_server_id uuid, v_checksum character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server_hooks
    SET checksum = v_checksum,
        _update_date = LOCALTIMESTAMP
    WHERE hook_id = v_hook_id
        AND server_id = v_server_id;
END;$$;


ALTER FUNCTION public.updateglusterserverhookchecksum(v_hook_id uuid, v_server_id uuid, v_checksum character varying) OWNER TO engine;

--
-- Name: updateglusterserverhookstatus(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverhookstatus(v_hook_id uuid, v_server_id uuid, v_hook_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server_hooks
    SET hook_status = v_hook_status,
        _update_date = LOCALTIMESTAMP
    WHERE hook_id = v_hook_id
        AND server_id = v_server_id;

    UPDATE gluster_hooks
    SET _update_date = LOCALTIMESTAMP
    WHERE id = v_hook_id;
END;$$;


ALTER FUNCTION public.updateglusterserverhookstatus(v_hook_id uuid, v_server_id uuid, v_hook_status character varying) OWNER TO engine;

--
-- Name: updateglusterserverknownaddresses(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverknownaddresses(v_server_id uuid, v_known_addresses character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server
    SET known_addresses = v_known_addresses
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.updateglusterserverknownaddresses(v_server_id uuid, v_known_addresses character varying) OWNER TO engine;

--
-- Name: updateglusterserverpeerstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverpeerstatus(v_server_id uuid, v_peer_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server
    SET peer_status = v_peer_status
    WHERE server_id = v_server_id;
END;$$;


ALTER FUNCTION public.updateglusterserverpeerstatus(v_server_id uuid, v_peer_status character varying) OWNER TO engine;

--
-- Name: updateglusterserverservice(uuid, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverservice(v_id uuid, v_pid integer, v_status character varying, v_message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server_services
    SET pid = v_pid,
        status = v_status,
        message = v_message,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglusterserverservice(v_id uuid, v_pid integer, v_status character varying, v_message character varying) OWNER TO engine;

--
-- Name: updateglusterserverservicebyserveridandservicetype(uuid, uuid, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglusterserverservicebyserveridandservicetype(v_server_id uuid, v_service_id uuid, v_pid integer, v_status character varying, v_message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_server_services
    SET pid = v_pid,
        status = v_status,
        message = v_message,
        _update_date = LOCALTIMESTAMP
    WHERE server_id = v_server_id
        AND service_id = v_service_id;
END;$$;


ALTER FUNCTION public.updateglusterserverservicebyserveridandservicetype(v_server_id uuid, v_service_id uuid, v_pid integer, v_status character varying, v_message character varying) OWNER TO engine;

--
-- Name: updateglustervolume(uuid, uuid, character varying, character varying, character varying, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolume(v_id uuid, v_cluster_id uuid, v_vol_name character varying, v_vol_type character varying, v_status character varying, v_replica_count integer, v_stripe_count integer, v_disperse_count integer, v_redundancy_count integer, v_is_arbiter boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET cluster_id = v_cluster_id,
        vol_name = v_vol_name,
        vol_type = v_vol_type,
        status = v_status,
        replica_count = v_replica_count,
        stripe_count = v_stripe_count,
        disperse_count = v_disperse_count,
        redundancy_count = v_redundancy_count,
        is_arbiter = v_is_arbiter,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolume(v_id uuid, v_cluster_id uuid, v_vol_name character varying, v_vol_type character varying, v_status character varying, v_replica_count integer, v_stripe_count integer, v_disperse_count integer, v_redundancy_count integer, v_is_arbiter boolean) OWNER TO engine;

--
-- Name: updateglustervolumeasynctask(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumeasynctask(v_volume_id uuid, v_task_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET task_id = v_task_id,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updateglustervolumeasynctask(v_volume_id uuid, v_task_id uuid) OWNER TO engine;

--
-- Name: updateglustervolumebrick(uuid, uuid, uuid, character varying, character varying, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrick(v_id uuid, v_new_id uuid, v_new_server_id uuid, v_new_brick_dir character varying, v_new_status character varying, v_new_network_id uuid, v_is_arbiter boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM gluster_volume_brick_details
    WHERE brick_id = v_id;
    UPDATE gluster_volume_bricks
    SET id = v_new_id,
        server_id = v_new_server_id,
        brick_dir = v_new_brick_dir,
        status = v_new_status,
        network_id = v_new_network_id,
        is_arbiter = v_is_arbiter,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrick(v_id uuid, v_new_id uuid, v_new_server_id uuid, v_new_brick_dir character varying, v_new_status character varying, v_new_network_id uuid, v_is_arbiter boolean) OWNER TO engine;

--
-- Name: updateglustervolumebrickasynctask(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrickasynctask(v_id uuid, v_task_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET task_id = v_task_id,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrickasynctask(v_id uuid, v_task_id uuid) OWNER TO engine;

--
-- Name: updateglustervolumebrickdetails(uuid, bigint, bigint, bigint, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrickdetails(v_brick_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_confirmed_total_space bigint, v_vdo_savings integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_brick_details
    SET total_space = v_total_space,
        used_space = v_used_space,
        free_space = v_free_space,
        confirmed_free_space = v_confirmed_free_space,
        confirmed_total_space = v_confirmed_total_space,
        vdo_savings = v_vdo_savings,
        _update_date = LOCALTIMESTAMP
    WHERE brick_id = v_brick_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrickdetails(v_brick_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_confirmed_total_space bigint, v_vdo_savings integer) OWNER TO engine;

--
-- Name: updateglustervolumebricknetworkid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebricknetworkid(v_id uuid, v_network_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET network_id = v_network_id,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebricknetworkid(v_id uuid, v_network_id uuid) OWNER TO engine;

--
-- Name: updateglustervolumebrickorder(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrickorder(v_id uuid, v_brick_order integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET brick_order = v_brick_order,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrickorder(v_id uuid, v_brick_order integer) OWNER TO engine;

--
-- Name: updateglustervolumebrickstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrickstatus(v_id uuid, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrickstatus(v_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: updateglustervolumebrickunsyncedentries(uuid, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumebrickunsyncedentries(v_id uuid, v_unsynced_entries integer, v_unsynced_entries_history text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_bricks
    SET unsynced_entries = v_unsynced_entries,
        unsynced_entries_history = v_unsynced_entries_history,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumebrickunsyncedentries(v_id uuid, v_unsynced_entries integer, v_unsynced_entries_history text) OWNER TO engine;

--
-- Name: updateglustervolumedetails(uuid, bigint, bigint, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumedetails(v_volume_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_vdo_savings integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_details
    SET total_space = v_total_space,
        used_space = v_used_space,
        free_space = v_free_space,
        confirmed_free_space = v_confirmed_free_space,
        vdo_savings = v_vdo_savings,
        _update_date = LOCALTIMESTAMP
    WHERE volume_id = v_volume_id;
END;$$;


ALTER FUNCTION public.updateglustervolumedetails(v_volume_id uuid, v_total_space bigint, v_used_space bigint, v_free_space bigint, v_confirmed_free_space bigint, v_vdo_savings integer) OWNER TO engine;

--
-- Name: updateglustervolumeoption(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumeoption(v_id uuid, v_option_val character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_options
    SET option_val = v_option_val
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateglustervolumeoption(v_id uuid, v_option_val character varying) OWNER TO engine;

--
-- Name: updateglustervolumesnapshotschedulebyvolumeid(uuid, character varying, character varying, character varying, character varying, character varying, integer, timestamp with time zone, time without time zone, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid, v_job_id character varying, v_snapshot_name_prefix character varying, v_snapshot_description character varying, v_recurrence character varying, v_time_zone character varying, v_interval integer, v_start_date timestamp with time zone, v_execution_time time without time zone, v_days character varying, v_end_by timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_snapshot_schedules
    SET job_id = v_job_id,
        snapshot_name_prefix = v_snapshot_name_prefix,
        snapshot_description = v_snapshot_description,
        recurrence = v_recurrence,
        time_zone = v_time_zone,
        interval = v_interval,
        start_date = v_start_date,
        execution_time = v_execution_time,
        days = v_days,
        end_by = v_end_by,
        _update_date = LOCALTIMESTAMP
    WHERE volume_id = v_volume_id;

    UPDATE gluster_volumes
    SET snapshot_scheduled = true
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updateglustervolumesnapshotschedulebyvolumeid(v_volume_id uuid, v_job_id character varying, v_snapshot_name_prefix character varying, v_snapshot_description character varying, v_recurrence character varying, v_time_zone character varying, v_interval integer, v_start_date timestamp with time zone, v_execution_time time without time zone, v_days character varying, v_end_by timestamp with time zone) OWNER TO engine;

--
-- Name: updateglustervolumesnapshotstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumesnapshotstatus(v_snapshot_id uuid, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_snapshots
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.updateglustervolumesnapshotstatus(v_snapshot_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: updateglustervolumesnapshotstatusbyname(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumesnapshotstatusbyname(v_volume_id uuid, v_snapshot_name character varying, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volume_snapshots
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE volume_id = v_volume_id
        AND snapshot_name = v_snapshot_name;
END;$$;


ALTER FUNCTION public.updateglustervolumesnapshotstatusbyname(v_volume_id uuid, v_snapshot_name character varying, v_status character varying) OWNER TO engine;

--
-- Name: updateglustervolumestatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumestatus(v_volume_id uuid, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updateglustervolumestatus(v_volume_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: updateglustervolumestatusbyname(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateglustervolumestatusbyname(v_cluster_id uuid, v_vol_name character varying, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE cluster_id = v_cluster_id
        AND vol_name = v_vol_name;
END;$$;


ALTER FUNCTION public.updateglustervolumestatusbyname(v_cluster_id uuid, v_vol_name character varying, v_status character varying) OWNER TO engine;

--
-- Name: updategroup(uuid, character varying, character varying, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updategroup(v_id uuid, v_name character varying, v_domain character varying, v_distinguishedname character varying, v_external_id text, v_namespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE ad_groups
    SET name = v_name,
        domain = v_domain,
        distinguishedname = v_distinguishedname,
        external_id = v_external_id,
        namespace = v_namespace
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updategroup(v_id uuid, v_name character varying, v_domain character varying, v_distinguishedname character varying, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: updatehostdevice(uuid, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying, boolean, character varying, text, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatehostdevice(v_host_id uuid, v_device_name character varying, v_parent_device_name character varying, v_capability character varying, v_iommu_group integer, v_product_name character varying, v_product_id character varying, v_vendor_name character varying, v_vendor_id character varying, v_physfn character varying, v_total_vfs integer, v_net_iface_name character varying, v_driver character varying, v_is_assignable boolean, v_address character varying, v_mdev_types text, v_block_path text, v_hostdev_spec_params text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    SET CONSTRAINTS ALL DEFERRED;

    UPDATE host_device
    SET host_id = v_host_id,
        device_name = v_device_name,
        parent_device_name = v_parent_device_name,
        capability = v_capability,
        iommu_group = v_iommu_group,
        product_name = v_product_name,
        product_id = v_product_id,
        vendor_name = v_vendor_name,
        vendor_id = v_vendor_id,
        physfn = v_physfn,
        total_vfs = v_total_vfs,
        net_iface_name = v_net_iface_name,
        driver = v_driver,
        is_assignable = v_is_assignable,
        address = v_address,
        mdev_types = v_mdev_types,
        block_path = v_block_path,
        hostdev_spec_params = v_hostdev_spec_params
    WHERE host_id = v_host_id
        AND device_name = v_device_name;
END;$$;


ALTER FUNCTION public.updatehostdevice(v_host_id uuid, v_device_name character varying, v_parent_device_name character varying, v_capability character varying, v_iommu_group integer, v_product_name character varying, v_product_id character varying, v_vendor_name character varying, v_vendor_id character varying, v_physfn character varying, v_total_vfs integer, v_net_iface_name character varying, v_driver character varying, v_is_assignable boolean, v_address character varying, v_mdev_types text, v_block_path text, v_hostdev_spec_params text) OWNER TO engine;

--
-- Name: updatehostexternalstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatehostexternalstatus(v_vds_guid uuid, v_external_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET external_status = v_external_status
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.updatehostexternalstatus(v_vds_guid uuid, v_external_status integer) OWNER TO engine;

--
-- Name: updatehostnetworkqos(uuid, smallint, character varying, text, uuid, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatehostnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_out_average_linkshare integer, v_out_average_upperlimit integer, v_out_average_realtime integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE qos
    SET qos_type = v_qos_type,
        name = v_name,
        description = v_description,
        storage_pool_id = v_storage_pool_id,
        out_average_linkshare = v_out_average_linkshare,
        out_average_upperlimit = v_out_average_upperlimit,
        out_average_realtime = v_out_average_realtime,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatehostnetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_out_average_linkshare integer, v_out_average_upperlimit integer, v_out_average_realtime integer) OWNER TO engine;

--
-- Name: updatehostnicvfsconfig(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatehostnicvfsconfig(v_id uuid, v_nic_id uuid, v_is_all_networks_allowed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE host_nic_vfs_config
    SET id = v_id,
        nic_id = v_nic_id,
        is_all_networks_allowed = v_is_all_networks_allowed,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatehostnicvfsconfig(v_id uuid, v_nic_id uuid, v_is_all_networks_allowed boolean) OWNER TO engine;

--
-- Name: updatehostproviderbinding(uuid, character varying[], character varying[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatehostproviderbinding(v_vds_id uuid, v_plugin_types character varying[], v_provider_binding_host_ids character varying[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1 FROM provider_binding_host_id WHERE vds_id = v_vds_id FOR UPDATE;
    DELETE FROM provider_binding_host_id WHERE vds_id = v_vds_id;
    INSERT INTO provider_binding_host_id (
        vds_id,
        plugin_type,
        binding_host_id
        )
    SELECT v_vds_id, unnest(v_plugin_types), unnest(v_provider_binding_host_ids);
END;$$;


ALTER FUNCTION public.updatehostproviderbinding(v_vds_id uuid, v_plugin_types character varying[], v_provider_binding_host_ids character varying[]) OWNER TO engine;

--
-- Name: updateimage(timestamp with time zone, uuid, uuid, bigint, uuid, integer, timestamp with time zone, uuid, integer, integer, uuid, boolean, smallint, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateimage(v_creation_date timestamp with time zone, v_image_guid uuid, v_it_guid uuid, v_size bigint, v_parentid uuid, v_imagestatus integer, v_lastmodified timestamp with time zone, v_vm_snapshot_id uuid, v_volume_type integer, v_volume_format integer, v_image_group_id uuid, v_active boolean, v_volume_classification smallint, v_qcow_compat integer, v_sequence_number integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE images
    SET creation_date = v_creation_date,
        it_guid = v_it_guid,
        size = v_size,
        ParentId = v_ParentId,
        imageStatus = v_imageStatus,
        lastModified = v_lastModified,
        vm_snapshot_id = v_vm_snapshot_id,
        volume_type = v_volume_type,
        image_group_id = v_image_group_id,
        volume_format = v_volume_format,
        active = v_active,
        volume_classification = v_volume_classification,
        qcow_compat = v_qcow_compat,
        _update_date = LOCALTIMESTAMP,
        sequence_number = v_sequence_number
    WHERE image_guid = v_image_guid;
END;$$;


ALTER FUNCTION public.updateimage(v_creation_date timestamp with time zone, v_image_guid uuid, v_it_guid uuid, v_size bigint, v_parentid uuid, v_imagestatus integer, v_lastmodified timestamp with time zone, v_vm_snapshot_id uuid, v_volume_type integer, v_volume_format integer, v_image_group_id uuid, v_active boolean, v_volume_classification smallint, v_qcow_compat integer, v_sequence_number integer) OWNER TO engine;

--
-- Name: updateimagesize(uuid, bigint, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateimagesize(v_image_id uuid, v_size bigint, v_lastmodified timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE images
    SET size = v_size,
        lastModified = v_lastModified
    WHERE image_guid = v_image_id;
END;$$;


ALTER FUNCTION public.updateimagesize(v_image_id uuid, v_size bigint, v_lastmodified timestamp with time zone) OWNER TO engine;

--
-- Name: updateimagestatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateimagestatus(v_image_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE images
    SET imageStatus = v_status
    WHERE image_guid = v_image_id;
END;$$;


ALTER FUNCTION public.updateimagestatus(v_image_id uuid, v_status integer) OWNER TO engine;

--
-- Name: updateimageuploads(uuid, integer, integer, integer, boolean, timestamp without time zone, character varying, uuid, uuid, uuid, character varying, character varying, bigint, bigint, integer, character varying, integer, integer, uuid, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateimageuploads(v_command_id uuid, v_command_type integer, v_phase integer, v_type integer, v_active boolean, v_last_updated timestamp without time zone, v_message character varying, v_vds_id uuid, v_disk_id uuid, v_imaged_ticket_id uuid, v_proxy_uri character varying, v_daemon_uri character varying, v_bytes_sent bigint, v_bytes_total bigint, v_client_inactivity_timeout integer, v_timeout_policy character varying, v_image_format integer, v_backend integer, v_backup_id uuid, v_client_type integer, v_shallow boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE image_transfers
    SET command_id = v_command_id,
        command_type = v_command_type,
        phase = v_phase,
        type = v_type,
        active = v_active,
        last_updated = v_last_updated,
        message = v_message,
        vds_id = v_vds_id,
        disk_id = v_disk_id,
        imaged_ticket_id = v_imaged_ticket_id,
        proxy_uri = v_proxy_uri,
        daemon_uri = v_daemon_uri,
        bytes_sent = v_bytes_sent,
        bytes_total = v_bytes_total,
        client_inactivity_timeout = v_client_inactivity_timeout,
        timeout_policy = v_timeout_policy,
        image_format = v_image_format,
        backend = v_backend,
        backup_id = v_backup_id,
        client_type = v_client_type,
        shallow = v_shallow
    WHERE command_id = v_command_id;
END;$$;


ALTER FUNCTION public.updateimageuploads(v_command_id uuid, v_command_type integer, v_phase integer, v_type integer, v_active boolean, v_last_updated timestamp without time zone, v_message character varying, v_vds_id uuid, v_disk_id uuid, v_imaged_ticket_id uuid, v_proxy_uri character varying, v_daemon_uri character varying, v_bytes_sent bigint, v_bytes_total bigint, v_client_inactivity_timeout integer, v_timeout_policy character varying, v_image_format integer, v_backend integer, v_backup_id uuid, v_client_type integer, v_shallow boolean) OWNER TO engine;

--
-- Name: updateimagevmsnapshotid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateimagevmsnapshotid(v_image_id uuid, v_vm_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE images
    SET vm_snapshot_id = v_vm_snapshot_id
    WHERE image_guid = v_image_id;
END;$$;


ALTER FUNCTION public.updateimagevmsnapshotid(v_image_id uuid, v_vm_snapshot_id uuid) OWNER TO engine;

--
-- Name: updateiscsibond(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateiscsibond(v_id uuid, v_name character varying, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE iscsi_bonds
    SET name = v_name,
        description = v_description
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateiscsibond(v_id uuid, v_name character varying, v_description character varying) OWNER TO engine;

--
-- Name: updateisfreeflagbyid(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateisfreeflagbyid(v_id uuid, v_is_free boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_device
    SET is_free = v_is_free,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateisfreeflagbyid(v_id uuid, v_is_free boolean) OWNER TO engine;

--
-- Name: updateisinitialized(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateisinitialized(v_vm_guid uuid, v_is_initialized boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET is_initialized = v_is_initialized
      WHERE vm_guid = v_vm_guid
          AND entity_type = 'VM';
END; $$;


ALTER FUNCTION public.updateisinitialized(v_vm_guid uuid, v_is_initialized boolean) OWNER TO engine;

--
-- Name: updatejob(uuid, character varying, text, character varying, uuid, bigint, boolean, timestamp with time zone, timestamp with time zone, timestamp with time zone, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatejob(v_job_id uuid, v_action_type character varying, v_description text, v_status character varying, v_owner_id uuid, v_engine_session_seq_id bigint, v_visible boolean, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_last_update_time timestamp with time zone, v_correlation_id character varying, v_is_external boolean, v_is_auto_cleared boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE job
    SET action_type = v_action_type,
        description = v_description,
        status = v_status,
        owner_id = v_owner_id,
        engine_session_seq_id = v_engine_session_seq_id,
        visible = v_visible,
        start_time = v_start_time,
        end_time = v_end_time,
        last_update_time = v_last_update_time,
        correlation_id = v_correlation_id,
        is_external = v_is_external,
        is_auto_cleared = v_is_auto_cleared
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.updatejob(v_job_id uuid, v_action_type character varying, v_description text, v_status character varying, v_owner_id uuid, v_engine_session_seq_id bigint, v_visible boolean, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_last_update_time timestamp with time zone, v_correlation_id character varying, v_is_external boolean, v_is_auto_cleared boolean) OWNER TO engine;

--
-- Name: updatejoblastupdatetime(uuid, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatejoblastupdatetime(v_job_id uuid, v_last_update_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE job
    SET last_update_time = v_last_update_time
    WHERE job_id = v_job_id;
END;$$;


ALTER FUNCTION public.updatejoblastupdatetime(v_job_id uuid, v_last_update_time timestamp with time zone) OWNER TO engine;

--
-- Name: updatejobstepscompleted(uuid, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatejobstepscompleted(v_job_id uuid, v_status character varying, v_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE step
    SET status = v_status,
        end_time = v_end_time
    WHERE job_id = v_job_id
        AND status = 'STARTED'
        AND status != v_status;
END;$$;


ALTER FUNCTION public.updatejobstepscompleted(v_job_id uuid, v_status character varying, v_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: updatelabel(uuid, character varying, boolean, boolean, uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelabel(v_label_id uuid, v_label_name character varying, v_readonly boolean, v_has_implicit_affinity_group boolean, v_vms uuid[], v_hosts uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
   o uuid;
BEGIN
    UPDATE labels
    SET label_name = v_label_name,
        read_only = v_readonly,
        has_implicit_affinity_group = v_has_implicit_affinity_group
    WHERE label_id = v_label_id;

    DELETE FROM labels_map
    WHERE label_id = v_label_id;

    -- Insert VM references
    FOREACH o IN ARRAY v_vms
    LOOP
        INSERT INTO labels_map (
            label_id,
            vm_id
            )
        VALUES (
            v_label_id,
            o
            );
    END LOOP;

    -- Insert host references
    FOREACH o IN ARRAY v_hosts
    LOOP
        INSERT INTO labels_map (
            label_id,
            vds_id
            )
        VALUES (
            v_label_id,
            o
            );
    END LOOP;
END;$$;


ALTER FUNCTION public.updatelabel(v_label_id uuid, v_label_name character varying, v_readonly boolean, v_has_implicit_affinity_group boolean, v_vms uuid[], v_hosts uuid[]) OWNER TO engine;

--
-- Name: updatelabelsforhost(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelabelsforhost(v_host_id uuid, v_labels uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Remove existing entries for the host
    DELETE FROM labels_map
    WHERE vds_id = v_host_id;

    -- Add the current entries for the host
    PERFORM
        AddHostToLabels(v_host_id, v_labels);
END;$$;


ALTER FUNCTION public.updatelabelsforhost(v_host_id uuid, v_labels uuid[]) OWNER TO engine;

--
-- Name: updatelabelsforvm(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelabelsforvm(v_vm_id uuid, v_labels uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Remove existing entries for the VM
    DELETE FROM labels_map
    WHERE vm_id = v_vm_id;

    -- Add the current entries for the VM
    PERFORM
        AddVmToLabels(v_vm_id, v_labels);
END;$$;


ALTER FUNCTION public.updatelabelsforvm(v_vm_id uuid, v_labels uuid[]) OWNER TO engine;

--
-- Name: updatelastadmincheckstatus(character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelastadmincheckstatus(v_userids character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

    DECLARE v_id UUID;

    v_tempId VARCHAR(4000);

    myCursor CURSOR
    FOR

    SELECT id
    FROM fnSplitter(v_userIds);

    v_result INT;

    BEGIN
        -- get users and its groups
        -- get their permission based on ad_element_id.
        -- if one permissions role's type is ADMIN(1) THEN set the user last_admin_check_status to 1
        OPEN myCursor;

        FETCH myCursor
        INTO v_tempId;

        WHILE FOUND LOOP v_id := CAST(v_tempId AS UUID);
            SELECT count(*)
            INTO v_result
            FROM users
            WHERE user_id IN (
                    SELECT ad_element_id AS user_id
                    FROM permissions,
                        roles
                    WHERE permissions.role_id = roles.id
                        AND ad_element_id IN (
                            (
                                SELECT ad_groups.id
                                FROM ad_groups,
                                    engine_sessions
                                WHERE engine_sessions.user_id = v_id
                                    AND ad_groups.id IN (
                                        SELECT *
                                        FROM fnsplitteruuid(engine_sessions.group_ids)
                                        )

                                UNION

                                SELECT v_id
                                )
                            )
                        AND (
                            roles.role_type = 1
                            OR permissions.role_id = '00000000-0000-0000-0000-000000000001'
                            )
                    );

        UPDATE users
        SET last_admin_check_status = CASE
                WHEN v_result = 0
                    THEN FALSE
                ELSE TRUE
                END
        WHERE user_id = v_id;

        FETCH myCursor
        INTO v_tempId;
    END LOOP;


    CLOSE myCursor;
END;$$;


ALTER FUNCTION public.updatelastadmincheckstatus(v_userids character varying) OWNER TO engine;

--
-- Name: updatelibvirtsecret(uuid, text, integer, text, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelibvirtsecret(v_secret_id uuid, v_secret_value text, v_secret_usage_type integer, v_secret_description text, v_provider_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE libvirt_secrets
    SET secret_id = v_secret_id,
        secret_value = v_secret_value,
        secret_usage_type = v_secret_usage_type,
        secret_description = v_secret_description,
        provider_id = v_provider_id,
        _update_date = LOCALTIMESTAMP
    WHERE secret_id = v_secret_id;
END;$$;


ALTER FUNCTION public.updatelibvirtsecret(v_secret_id uuid, v_secret_value text, v_secret_usage_type integer, v_secret_description text, v_provider_id uuid) OWNER TO engine;

--
-- Name: updatelun_storage_server_connection_map(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatelun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
END;$$;


ALTER FUNCTION public.updatelun_storage_server_connection_map(v_lun_id character varying, v_storage_server_connection character varying) OWNER TO engine;

--
-- Name: updateluns(character varying, character varying, character varying, character varying, integer, character varying, character varying, integer, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateluns(v_lun_id character varying, v_physical_volume_id character varying, v_volume_group_id character varying, v_serial character varying, v_lun_mapping integer, v_vendor_id character varying, v_product_id character varying, v_device_size integer, v_discard_max_size bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE LUNs
    SET LUN_id = v_LUN_id,
        physical_volume_id = v_physical_volume_id,
        volume_group_id = v_volume_group_id,
        serial = v_serial,
        lun_mapping = v_lun_mapping,
        vendor_id = v_vendor_id,
        product_id = v_product_id,
        device_size = v_device_size,
        discard_max_size = v_discard_max_size
    WHERE LUN_id = v_LUN_id;
END;$$;


ALTER FUNCTION public.updateluns(v_lun_id character varying, v_physical_volume_id character varying, v_volume_group_id character varying, v_serial character varying, v_lun_mapping integer, v_vendor_id character varying, v_product_id character varying, v_device_size integer, v_discard_max_size bigint) OWNER TO engine;

--
-- Name: updatemacpool(uuid, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatemacpool(v_id uuid, v_name character varying, v_allow_duplicate_mac_addresses boolean, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE mac_pools
    SET id = v_id,
        name = v_name,
        allow_duplicate_mac_addresses = v_allow_duplicate_mac_addresses,
        description = v_description
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatemacpool(v_id uuid, v_name character varying, v_allow_duplicate_mac_addresses boolean, v_description character varying) OWNER TO engine;

--
-- Name: updatememory(uuid, uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatememory(v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_vm_id uuid, v_snapshot_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET    memory_dump_disk_id = v_memory_dump_disk_id,
           memory_metadata_disk_id = v_memory_metadata_disk_id
    WHERE vm_id = v_vm_id
        AND snapshot_type = v_snapshot_type;
END;$$;


ALTER FUNCTION public.updatememory(v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_vm_id uuid, v_snapshot_type character varying) OWNER TO engine;

--
-- Name: updatenetwork(character varying, character varying, text, uuid, character varying, character varying, character varying, character varying, integer, integer, boolean, uuid, integer, boolean, uuid, text, uuid, uuid, text, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenetwork(v_addr character varying, v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_vdsm_name character varying, v_subnet character varying, v_gateway character varying, v_type integer, v_vlan_id integer, v_stp boolean, v_storage_pool_id uuid, v_mtu integer, v_vm_network boolean, v_provider_network_provider_id uuid, v_provider_network_external_id text, v_provider_physical_network_id uuid, v_qos_id uuid, v_label text, v_dns_resolver_configuration_id uuid, v_port_isolation boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network
    SET addr = v_addr,
        description = v_description,
        free_text_comment = v_free_text_comment,
        name = v_name,
        vdsm_name = v_vdsm_name,
        subnet = v_subnet,
        gateway = v_gateway,
        type = v_type,
        vlan_id = v_vlan_id,
        stp = v_stp,
        storage_pool_id = v_storage_pool_id,
        mtu = v_mtu,
        vm_network = v_vm_network,
        provider_network_provider_id = v_provider_network_provider_id,
        provider_network_external_id = v_provider_network_external_id,
        provider_physical_network_id = v_provider_physical_network_id,
        qos_id = v_qos_id,
        label = v_label,
        dns_resolver_configuration_id = v_dns_resolver_configuration_id,
        port_isolation = v_port_isolation
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatenetwork(v_addr character varying, v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_vdsm_name character varying, v_subnet character varying, v_gateway character varying, v_type integer, v_vlan_id integer, v_stp boolean, v_storage_pool_id uuid, v_mtu integer, v_vm_network boolean, v_provider_network_provider_id uuid, v_provider_network_external_id text, v_provider_physical_network_id uuid, v_qos_id uuid, v_label text, v_dns_resolver_configuration_id uuid, v_port_isolation boolean) OWNER TO engine;

--
-- Name: updatenetwork_cluster(uuid, uuid, integer, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenetwork_cluster(v_cluster_id uuid, v_network_id uuid, v_status integer, v_is_display boolean, v_required boolean, v_migration boolean, v_management boolean, v_is_gluster boolean, v_default_route boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET status = v_status,
        is_display = v_is_display,
        required = v_required,
        migration = v_migration,
        management = v_management,
        is_gluster = v_is_gluster,
        default_route = v_default_route
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.updatenetwork_cluster(v_cluster_id uuid, v_network_id uuid, v_status integer, v_is_display boolean, v_required boolean, v_migration boolean, v_management boolean, v_is_gluster boolean, v_default_route boolean) OWNER TO engine;

--
-- Name: updatenetwork_cluster_status(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenetwork_cluster_status(v_cluster_id uuid, v_network_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_cluster
    SET status = v_status
    WHERE cluster_id = v_cluster_id
        AND network_id = v_network_id;
END;$$;


ALTER FUNCTION public.updatenetwork_cluster_status(v_cluster_id uuid, v_network_id uuid, v_status integer) OWNER TO engine;

--
-- Name: updatenetworkattachment(uuid, uuid, uuid, character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying, text, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenetworkattachment(v_id uuid, v_network_id uuid, v_nic_id uuid, v_boot_protocol character varying, v_address character varying, v_netmask character varying, v_gateway character varying, v_ipv6_boot_protocol character varying, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_custom_properties text, v_dns_resolver_configuration_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE network_attachments
    SET network_id = v_network_id,
        nic_id = v_nic_id,
        boot_protocol = v_boot_protocol,
        address = v_address,
        netmask = v_netmask,
        gateway = v_gateway,
        custom_properties = v_custom_properties,
        ipv6_boot_protocol = v_ipv6_boot_protocol,
        ipv6_address = v_ipv6_address,
        ipv6_prefix = v_ipv6_prefix,
        ipv6_gateway = v_ipv6_gateway,
        _update_date = LOCALTIMESTAMP,
        dns_resolver_configuration_id = v_dns_resolver_configuration_id
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatenetworkattachment(v_id uuid, v_network_id uuid, v_nic_id uuid, v_boot_protocol character varying, v_address character varying, v_netmask character varying, v_gateway character varying, v_ipv6_boot_protocol character varying, v_ipv6_address character varying, v_ipv6_prefix integer, v_ipv6_gateway character varying, v_custom_properties text, v_dns_resolver_configuration_id uuid) OWNER TO engine;

--
-- Name: updatenetworkqos(uuid, smallint, character varying, text, uuid, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_inbound_average integer, v_inbound_peak integer, v_inbound_burst integer, v_outbound_average integer, v_outbound_peak integer, v_outbound_burst integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE qos
    SET qos_type = v_qos_type,
        name = v_name,
        description = v_description,
        storage_pool_id = v_storage_pool_id,
        inbound_average = v_inbound_average,
        inbound_peak = v_inbound_peak,
        inbound_burst = v_inbound_burst,
        outbound_average = v_outbound_average,
        outbound_peak = v_outbound_peak,
        outbound_burst = v_outbound_burst,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatenetworkqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_inbound_average integer, v_inbound_peak integer, v_inbound_burst integer, v_outbound_average integer, v_outbound_peak integer, v_outbound_burst integer) OWNER TO engine;

--
-- Name: updatenumanode(uuid, smallint, bigint, smallint, text, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenumanode(v_numa_node_id uuid, v_numa_node_index smallint, v_mem_total bigint, v_cpu_count smallint, v_distance text, v_hugepages text, v_numa_tune_mode character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE numa_node
        SET numa_node_index = v_numa_node_index,
            mem_total = v_mem_total,
            cpu_count = v_cpu_count,
            distance = v_distance,
            hugepages = v_hugepages,
            numa_tune_mode = v_numa_tune_mode
        WHERE numa_node_id = v_numa_node_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatenumanode(v_numa_node_id uuid, v_numa_node_index smallint, v_mem_total bigint, v_cpu_count smallint, v_distance text, v_hugepages text, v_numa_tune_mode character varying) OWNER TO engine;

--
-- Name: updatenumanodestatistics(uuid, bigint, integer, numeric, numeric, numeric, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenumanodestatistics(v_numa_node_id uuid, v_mem_free bigint, v_usage_mem_percent integer, v_cpu_sys numeric, v_cpu_user numeric, v_cpu_idle numeric, v_usage_cpu_percent integer, v_hugepages text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE numa_node
        SET mem_free = v_mem_free,
            usage_mem_percent = v_usage_mem_percent,
            cpu_sys = v_cpu_sys,
            cpu_user = v_cpu_user,
            cpu_idle = v_cpu_idle,
            usage_cpu_percent = v_usage_cpu_percent,
            hugepages = v_hugepages
        WHERE numa_node_id = v_numa_node_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatenumanodestatistics(v_numa_node_id uuid, v_mem_free bigint, v_usage_mem_percent integer, v_cpu_sys numeric, v_cpu_user numeric, v_cpu_idle numeric, v_usage_cpu_percent integer, v_hugepages text) OWNER TO engine;

--
-- Name: updatenvramdata(uuid, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatenvramdata(v_vm_id uuid, v_nvram_data text, v_nvram_hash text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_nvram_data (
        vm_id,
        nvram_data,
        nvram_hash
    )
    VALUES (
        v_vm_id,
        v_nvram_data,
        v_nvram_hash
    )
    ON CONFLICT (vm_id) DO
    UPDATE
    SET nvram_data = v_nvram_data,
        nvram_hash = v_nvram_hash;
END;$$;


ALTER FUNCTION public.updatenvramdata(v_vm_id uuid, v_nvram_data text, v_nvram_hash text) OWNER TO engine;

--
-- Name: updateoriginaltemplatename(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateoriginaltemplatename(v_original_template_id uuid, v_original_template_name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET original_template_name = v_original_template_name
      WHERE original_template_id = v_original_template_id;
END; $$;


ALTER FUNCTION public.updateoriginaltemplatename(v_original_template_id uuid, v_original_template_name character varying) OWNER TO engine;

--
-- Name: updateovfgenerations(character varying, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateovfgenerations(v_vms_ids character varying, v_vms_db_generations character varying, v_ovf_data text, v_ovf_data_seperator character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE curs_vmids CURSOR
FOR
SELECT *
FROM fnSplitterUuid(v_vms_ids);

curs_newovfgen CURSOR
FOR

SELECT *
FROM fnSplitter(v_vms_db_generations);

curs_newovfdata CURSOR
FOR

SELECT *
FROM fnSplitterWithSeperator(v_ovf_data, v_ovf_data_seperator);

id UUID;

new_ovf_gen BIGINT;

new_ovf_config TEXT;

BEGIN
    OPEN curs_vmids;

    OPEN curs_newovfgen;

    OPEN curs_newovfdata;

    LOOP

    FETCH curs_vmids
    INTO id;

    FETCH curs_newovfgen
    INTO new_ovf_gen;

    FETCH curs_newovfdata
    INTO new_ovf_config;

    IF NOT FOUND THEN EXIT;
    END IF;
    UPDATE vm_ovf_generations
    SET ovf_generation = new_ovf_gen,
        ovf_data = new_ovf_config
    WHERE vm_guid = id;
    END LOOP;

CLOSE curs_vmids;

CLOSE curs_newovfgen;

CLOSE curs_newovfdata;END;$$;


ALTER FUNCTION public.updateovfgenerations(v_vms_ids character varying, v_vms_db_generations character varying, v_ovf_data text, v_ovf_data_seperator character varying) OWNER TO engine;

--
-- Name: updateovfupdatedinfo(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateovfupdatedinfo(v_storage_domains_ids character varying, v_status integer, v_except_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE curs_storages_ids CURSOR
FOR
SELECT *
FROM fnSplitterUuid(v_storage_domains_ids);

id UUID;

BEGIN
    OPEN curs_storages_ids;

    LOOP

        FETCH curs_storages_ids
        INTO id;

        IF NOT FOUND THEN
            EXIT;
        END IF;
        UPDATE storage_domains_ovf_info
        SET status = v_status
        WHERE storage_domain_id = id
            AND status != v_except_status;
    END LOOP;

    CLOSE curs_storages_ids;
END;$$;


ALTER FUNCTION public.updateovfupdatedinfo(v_storage_domains_ids character varying, v_status integer, v_except_status integer) OWNER TO engine;

--
-- Name: updateovirtguestagentstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateovirtguestagentstatus(v_vm_guid uuid, v_ovirt_guest_agent_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_dynamic
      SET
      ovirt_guest_agent_status = v_ovirt_guest_agent_status
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.updateovirtguestagentstatus(v_vm_guid uuid, v_ovirt_guest_agent_status integer) OWNER TO engine;

--
-- Name: updatepolicyunit(uuid, boolean, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatepolicyunit(v_id uuid, v_enabled boolean, v_custom_properties_regex text, v_description text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE policy_units
    SET custom_properties_regex = v_custom_properties_regex,
        enabled = v_enabled,
        description = v_description
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatepolicyunit(v_id uuid, v_enabled boolean, v_custom_properties_regex text, v_description text) OWNER TO engine;

--
-- Name: updateprovider(uuid, character varying, character varying, character varying, character varying, boolean, character varying, text, text, character varying, character varying, text, text, boolean, boolean, boolean, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateprovider(v_id uuid, v_name character varying, v_description character varying, v_url character varying, v_provider_type character varying, v_auth_required boolean, v_auth_username character varying, v_auth_password text, v_custom_properties text, v_tenant_name character varying DEFAULT NULL::character varying, v_plugin_type character varying DEFAULT NULL::character varying, v_additional_properties text DEFAULT NULL::text, v_auth_url text DEFAULT NULL::text, v_read_only boolean DEFAULT false, v_is_unmanaged boolean DEFAULT false, v_auto_sync boolean DEFAULT false, v_user_domain_name character varying DEFAULT NULL::character varying, v_project_name character varying DEFAULT NULL::character varying, v_project_domain_name character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE providers
    SET name = v_name,
        description = v_description,
        url = v_url,
        provider_type = v_provider_type,
        auth_required = v_auth_required,
        auth_username = v_auth_username,
        auth_password = v_auth_password,
        custom_properties = v_custom_properties,
        tenant_name = v_tenant_name,
        plugin_type = v_plugin_type,
        _update_date = NOW(),
        additional_properties = v_additional_properties,
        auth_url = v_auth_url,
        read_only = v_read_only,
        is_unmanaged = v_is_unmanaged,
        auto_sync = v_auto_sync,
        user_domain_name = v_user_domain_name,
        project_name = v_project_name,
        project_domain_name = v_project_domain_name
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updateprovider(v_id uuid, v_name character varying, v_description character varying, v_url character varying, v_provider_type character varying, v_auth_required boolean, v_auth_username character varying, v_auth_password text, v_custom_properties text, v_tenant_name character varying, v_plugin_type character varying, v_additional_properties text, v_auth_url text, v_read_only boolean, v_is_unmanaged boolean, v_auto_sync boolean, v_user_domain_name character varying, v_project_name character varying, v_project_domain_name character varying) OWNER TO engine;

--
-- Name: updateqemuguestagentstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateqemuguestagentstatus(v_vm_guid uuid, v_qemu_guest_agent_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_dynamic
      SET
      qemu_guest_agent_status = v_qemu_guest_agent_status
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.updateqemuguestagentstatus(v_vm_guid uuid, v_qemu_guest_agent_status integer) OWNER TO engine;

--
-- Name: updatequotaforimageandsnapshots(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatequotaforimageandsnapshots(v_disk_id uuid, v_storage_domain_id uuid, v_quota_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE image_storage_domain_map AS isdm
    SET quota_id = v_quota_id
    FROM images AS i
    WHERE i.image_group_id = v_disk_id
        AND i.image_guid = isdm.image_id
        AND storage_domain_id = v_storage_domain_id;
END;$$;


ALTER FUNCTION public.updatequotaforimageandsnapshots(v_disk_id uuid, v_storage_domain_id uuid, v_quota_id uuid) OWNER TO engine;

--
-- Name: updatequotametadata(uuid, uuid, character varying, character varying, integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatequotametadata(v_id uuid, v_storage_pool_id uuid, v_quota_name character varying, v_description character varying, v_threshold_cluster_percentage integer, v_threshold_storage_percentage integer, v_grace_cluster_percentage integer, v_grace_storage_percentage integer, v_is_default boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE quota
    SET storage_pool_id = v_storage_pool_id,
        quota_name = v_quota_name,
        description = v_description,
        _update_date = LOCALTIMESTAMP,
        threshold_cluster_percentage = v_threshold_cluster_percentage,
        threshold_storage_percentage = v_threshold_storage_percentage,
        grace_cluster_percentage = v_grace_cluster_percentage,
        grace_storage_percentage = v_grace_storage_percentage,
        is_default = v_is_default
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatequotametadata(v_id uuid, v_storage_pool_id uuid, v_quota_name character varying, v_description character varying, v_threshold_cluster_percentage integer, v_threshold_storage_percentage integer, v_grace_cluster_percentage integer, v_grace_storage_percentage integer, v_is_default boolean) OWNER TO engine;

--
-- Name: updatereplicacount(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatereplicacount(v_volume_id uuid, v_replica_count integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET replica_count = v_replica_count,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updatereplicacount(v_volume_id uuid, v_replica_count integer) OWNER TO engine;

--
-- Name: updaterole(character varying, uuid, character varying, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updaterole(v_description character varying, v_id uuid, v_name character varying, v_is_readonly boolean, v_role_type integer, v_allows_viewing_children boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE roles
    SET description = v_description,
        name = v_name,
        is_readonly = v_is_readonly,
        role_type = v_role_type,
        allows_viewing_children = v_allows_viewing_children
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updaterole(v_description character varying, v_id uuid, v_name character varying, v_is_readonly boolean, v_role_type integer, v_allows_viewing_children boolean) OWNER TO engine;

--
-- Name: updatesnapshot(uuid, uuid, character varying, character varying, character varying, timestamp with time zone, text, text, uuid, uuid, boolean, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesnapshot(v_snapshot_id uuid, v_vm_id uuid, v_snapshot_type character varying, v_status character varying, v_description character varying, v_creation_date timestamp with time zone, v_app_list text, v_vm_configuration text, v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_vm_configuration_broken boolean, v_changed_fields text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET status = v_status,
        vm_id = v_vm_id,
        snapshot_type = v_snapshot_type,
        description = v_description,
        creation_date = v_creation_date,
        app_list = v_app_list,
        vm_configuration = v_vm_configuration,
        memory_dump_disk_id = v_memory_dump_disk_id,
        memory_metadata_disk_id = v_memory_metadata_disk_id,
        vm_configuration_broken = v_vm_configuration_broken,
        changed_fields = v_changed_fields,
        _update_date = NOW()
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.updatesnapshot(v_snapshot_id uuid, v_vm_id uuid, v_snapshot_type character varying, v_status character varying, v_description character varying, v_creation_date timestamp with time zone, v_app_list text, v_vm_configuration text, v_memory_dump_disk_id uuid, v_memory_metadata_disk_id uuid, v_vm_configuration_broken boolean, v_changed_fields text) OWNER TO engine;

--
-- Name: updatesnapshotcountdec(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesnapshotcountdec(v_volume_id uuid, v_num integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET snapshot_count = snapshot_count - v_num
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updatesnapshotcountdec(v_volume_id uuid, v_num integer) OWNER TO engine;

--
-- Name: updatesnapshotcountinc(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesnapshotcountinc(v_volume_id uuid, v_num integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE gluster_volumes
    SET snapshot_count = snapshot_count + v_num
    WHERE id = v_volume_id;
END;$$;


ALTER FUNCTION public.updatesnapshotcountinc(v_volume_id uuid, v_num integer) OWNER TO engine;

--
-- Name: updatesnapshotid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesnapshotid(v_snapshot_id uuid, v_new_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET snapshot_id = v_new_snapshot_id
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.updatesnapshotid(v_snapshot_id uuid, v_new_snapshot_id uuid) OWNER TO engine;

--
-- Name: updatesnapshotstatus(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesnapshotstatus(v_snapshot_id uuid, v_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE snapshots
    SET status = v_status
    WHERE snapshot_id = v_snapshot_id;
END;$$;


ALTER FUNCTION public.updatesnapshotstatus(v_snapshot_id uuid, v_status character varying) OWNER TO engine;

--
-- Name: updatestartedexecutionentitiestounknown(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestartedexecutionentitiestounknown(v_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE job
    SET status = 'UNKNOWN',
        end_time = v_end_time,
        last_update_time = v_end_time
    WHERE job.status = 'STARTED'
        AND job_id NOT IN (
            SELECT job_id
            FROM step
            WHERE external_id IS NOT NULL
            );

    UPDATE step
    SET status = 'UNKNOWN',
        end_time = v_end_time
    WHERE status = 'STARTED'
        AND job_id NOT IN (
            SELECT step.job_id
            FROM step step
            WHERE step.external_id IS NOT NULL
            );
END;$$;


ALTER FUNCTION public.updatestartedexecutionentitiestounknown(v_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: updatestatusofimagesbyimagegroupid(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestatusofimagesbyimagegroupid(v_image_group_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE images
    SET imageStatus = v_status
    WHERE image_group_id = v_image_group_id;
END;$$;


ALTER FUNCTION public.updatestatusofimagesbyimagegroupid(v_image_group_id uuid, v_status integer) OWNER TO engine;

--
-- Name: updatestep(uuid, uuid, uuid, character varying, text, integer, character varying, smallint, timestamp with time zone, timestamp with time zone, character varying, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestep(v_step_id uuid, v_parent_step_id uuid, v_job_id uuid, v_step_type character varying, v_description text, v_step_number integer, v_status character varying, v_progress smallint, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_correlation_id character varying, v_external_id uuid, v_external_system_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE step
    SET parent_step_id = v_parent_step_id,
        job_id = v_job_id,
        step_type = v_step_type,
        description = v_description,
        step_number = v_step_number,
        status = v_status,
        progress = v_progress,
        start_time = v_start_time,
        end_time = v_end_time,
        correlation_id = v_correlation_id,
        external_id = v_external_id,
        external_system_type = v_external_system_type
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.updatestep(v_step_id uuid, v_parent_step_id uuid, v_job_id uuid, v_step_type character varying, v_description text, v_step_number integer, v_status character varying, v_progress smallint, v_start_time timestamp with time zone, v_end_time timestamp with time zone, v_correlation_id character varying, v_external_id uuid, v_external_system_type character varying) OWNER TO engine;

--
-- Name: updatestepexternalidandtype(uuid, uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestepexternalidandtype(v_step_id uuid, v_external_id uuid, v_external_system_type character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE step
    SET external_id = v_external_id,
        external_system_type = v_external_system_type
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.updatestepexternalidandtype(v_step_id uuid, v_external_id uuid, v_external_system_type character varying) OWNER TO engine;

--
-- Name: updatestepprogress(uuid, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestepprogress(v_step_id uuid, v_progress smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE step
    SET progress = v_progress
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.updatestepprogress(v_step_id uuid, v_progress smallint) OWNER TO engine;

--
-- Name: updatestepstatusandendtime(uuid, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestepstatusandendtime(v_step_id uuid, v_status character varying, v_end_time timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE step
    SET status = v_status,
        end_time = v_end_time
    WHERE step_id = v_step_id;
END;$$;


ALTER FUNCTION public.updatestepstatusandendtime(v_step_id uuid, v_status character varying, v_end_time timestamp with time zone) OWNER TO engine;

--
-- Name: updatestorage_domain_dynamic(integer, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_domain_dynamic(v_available_disk_size integer, v_id uuid, v_used_disk_size integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domain_dynamic
    SET available_disk_size = v_available_disk_size,
        used_disk_size = v_used_disk_size,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_domain_dynamic(v_available_disk_size integer, v_id uuid, v_used_disk_size integer) OWNER TO engine;

--
-- Name: updatestorage_domain_static(uuid, character varying, character varying, character varying, text, integer, integer, integer, bigint, boolean, boolean, character varying, character varying, integer, integer, integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_domain_static(v_id uuid, v_storage character varying, v_storage_name character varying, v_storage_description character varying, v_storage_comment text, v_storage_type integer, v_storage_domain_type integer, v_storage_domain_format_type integer, v_last_time_used_as_master bigint, v_wipe_after_delete boolean, v_discard_after_delete boolean, v_first_metadata_device character varying, v_vg_metadata_device character varying, v_warning_low_space_indicator integer, v_critical_space_action_blocker integer, v_warning_low_confirmed_space_indicator integer, v_backup boolean, v_block_size integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domain_static
    SET storage = v_storage,
        storage_name = v_storage_name,
        storage_type = v_storage_type,
        storage_domain_type = v_storage_domain_type,
        _update_date = LOCALTIMESTAMP,
        storage_domain_format_type = v_storage_domain_format_type,
        last_time_used_as_master = v_last_time_used_as_master,
        wipe_after_delete = v_wipe_after_delete,
        discard_after_delete = v_discard_after_delete,
        first_metadata_device=v_first_metadata_device,
        vg_metadata_device=v_vg_metadata_device,
        storage_description = v_storage_description,
        storage_comment = v_storage_comment,
        warning_low_space_indicator = v_warning_low_space_indicator,
        critical_space_action_blocker = v_critical_space_action_blocker,
        warning_low_confirmed_space_indicator = v_warning_low_confirmed_space_indicator,
        backup = v_backup,
        block_size = v_block_size
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_domain_static(v_id uuid, v_storage character varying, v_storage_name character varying, v_storage_description character varying, v_storage_comment text, v_storage_type integer, v_storage_domain_type integer, v_storage_domain_format_type integer, v_last_time_used_as_master bigint, v_wipe_after_delete boolean, v_discard_after_delete boolean, v_first_metadata_device character varying, v_vg_metadata_device character varying, v_warning_low_space_indicator integer, v_critical_space_action_blocker integer, v_warning_low_confirmed_space_indicator integer, v_backup boolean, v_block_size integer) OWNER TO engine;

--
-- Name: updatestorage_pool(character varying, text, uuid, character varying, integer, boolean, character varying, integer, uuid, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_pool(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_status integer, v_is_local boolean, v_storage_pool_format_type character varying, v_master_domain_version integer, v_spm_vds_id uuid, v_compatibility_version character varying, v_quota_enforcement_type integer, v_managed boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_pool
    SET description = v_description,
        free_text_comment = v_free_text_comment,
        name = v_name,
        is_local = v_is_local,
        status = v_status,
        storage_pool_format_type = v_storage_pool_format_type,
        master_domain_version = v_master_domain_version,
        spm_vds_id = v_spm_vds_id,
        compatibility_version = v_compatibility_version,
        _update_date = LOCALTIMESTAMP,
        quota_enforcement_type = v_quota_enforcement_type,
        managed = v_managed
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_pool(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_status integer, v_is_local boolean, v_storage_pool_format_type character varying, v_master_domain_version integer, v_spm_vds_id uuid, v_compatibility_version character varying, v_quota_enforcement_type integer, v_managed boolean) OWNER TO engine;

--
-- Name: updatestorage_pool_iso_map_status(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_pool_iso_map_status(v_storage_id uuid, v_storage_pool_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_pool_iso_map
    SET status = v_status
    WHERE storage_pool_id = v_storage_pool_id
        AND storage_id = v_storage_id;
END;$$;


ALTER FUNCTION public.updatestorage_pool_iso_map_status(v_storage_id uuid, v_storage_pool_id uuid, v_status integer) OWNER TO engine;

--
-- Name: updatestorage_pool_partial(character varying, text, uuid, character varying, boolean, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_pool_partial(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_is_local boolean, v_storage_pool_format_type character varying, v_compatibility_version character varying, v_quota_enforcement_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_pool
    SET description = v_description,
        free_text_comment = v_free_text_comment,
        name = v_name,
        is_local = v_is_local,
        storage_pool_format_type = v_storage_pool_format_type,
        compatibility_version = v_compatibility_version,
        _update_date = LOCALTIMESTAMP,
        quota_enforcement_type = v_quota_enforcement_type
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_pool_partial(v_description character varying, v_free_text_comment text, v_id uuid, v_name character varying, v_is_local boolean, v_storage_pool_format_type character varying, v_compatibility_version character varying, v_quota_enforcement_type integer) OWNER TO engine;

--
-- Name: updatestorage_pool_status(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_pool_status(v_id uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_pool
    SET status = v_status,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_pool_status(v_id uuid, v_status integer) OWNER TO engine;

--
-- Name: updatestorage_server_connections(character varying, character varying, character varying, text, integer, character varying, character varying, text, character varying, character varying, character varying, smallint, smallint, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorage_server_connections(v_connection character varying, v_id character varying, v_iqn character varying, v_password text, v_storage_type integer, v_port character varying, v_portal character varying, v_user_name text, v_mount_options character varying, v_vfs_type character varying, v_nfs_version character varying, v_nfs_timeo smallint, v_nfs_retrans smallint, v_gluster_volume_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_server_connections
    SET connection = v_connection,
        iqn = v_iqn,
        password = v_password,
        port = v_port,
        portal = v_portal,
        storage_type = v_storage_type,
        user_name = v_user_name,
        mount_options = v_mount_options,
        vfs_type = v_vfs_type,
        nfs_version = v_nfs_version,
        nfs_timeo = v_nfs_timeo,
        nfs_retrans = v_nfs_retrans,
        gluster_volume_id = v_gluster_volume_id
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorage_server_connections(v_connection character varying, v_id character varying, v_iqn character varying, v_password text, v_storage_type integer, v_port character varying, v_portal character varying, v_user_name text, v_mount_options character varying, v_vfs_type character varying, v_nfs_version character varying, v_nfs_timeo smallint, v_nfs_retrans smallint, v_gluster_volume_id uuid) OWNER TO engine;

--
-- Name: updatestoragedevice(uuid, text, character varying, character varying, text, character varying, text, character varying, text, bigint, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestoragedevice(v_id uuid, v_name text, v_device_uuid character varying, v_filesystem_uuid character varying, v_description text, v_device_type character varying, v_device_path text, v_filesystem_type character varying, v_mount_point text, v_size bigint, v_is_free boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_device
    SET name = v_name,
        device_uuid = v_device_uuid,
        filesystem_uuid = v_filesystem_uuid,
        description = v_description,
        device_type = v_device_type,
        device_path = v_device_path,
        filesystem_type = v_filesystem_type,
        mount_point = v_mount_point,
        size = v_size,
        is_free = v_is_free,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestoragedevice(v_id uuid, v_name text, v_device_uuid character varying, v_filesystem_uuid character varying, v_description text, v_device_type character varying, v_device_path text, v_filesystem_type character varying, v_mount_point text, v_size bigint, v_is_free boolean) OWNER TO engine;

--
-- Name: updatestoragedomainconfirmedsize(integer, integer, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestoragedomainconfirmedsize(v_confirmed_available_disk_size integer, v_vdo_savings integer, v_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domain_dynamic
    SET confirmed_available_disk_size = v_confirmed_available_disk_size,
        vdo_savings = v_vdo_savings,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestoragedomainconfirmedsize(v_confirmed_available_disk_size integer, v_vdo_savings integer, v_id uuid) OWNER TO engine;

--
-- Name: updatestoragedomaindr(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid, v_sync_schedule character varying, v_gluster_scheduler_job_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domain_dr
    set sync_schedule = v_sync_schedule,
        gluster_scheduler_job_id = v_gluster_scheduler_job_id
    WHERE storage_domain_id = v_storage_domain_id
    AND georep_session_id = v_georep_session_id;
END;$$;


ALTER FUNCTION public.updatestoragedomaindr(v_storage_domain_id uuid, v_georep_session_id uuid, v_sync_schedule character varying, v_gluster_scheduler_job_id uuid) OWNER TO engine;

--
-- Name: updatestoragedomainexternalstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestoragedomainexternalstatus(v_storage_id uuid, v_external_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domain_dynamic
    SET external_status = v_external_status
    WHERE id = v_storage_id;
END;$$;


ALTER FUNCTION public.updatestoragedomainexternalstatus(v_storage_id uuid, v_external_status integer) OWNER TO engine;

--
-- Name: updatestoragedomainovfinfo(uuid, integer, uuid, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestoragedomainovfinfo(v_storage_domain_id uuid, v_status integer, v_ovf_disk_id uuid, v_stored_ovfs_ids text, v_last_updated timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_domains_ovf_info
    SET status = v_status,
        storage_domain_id = v_storage_domain_id,
        ovf_disk_id = v_ovf_disk_id,
        stored_ovfs_ids = v_stored_ovfs_ids,
        last_updated = v_last_updated
    WHERE ovf_disk_id = v_ovf_disk_id;
END;$$;


ALTER FUNCTION public.updatestoragedomainovfinfo(v_storage_domain_id uuid, v_status integer, v_ovf_disk_id uuid, v_stored_ovfs_ids text, v_last_updated timestamp with time zone) OWNER TO engine;

--
-- Name: updatestorageqos(uuid, smallint, character varying, text, uuid, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorageqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_max_throughput integer, v_max_read_throughput integer, v_max_write_throughput integer, v_max_iops integer, v_max_read_iops integer, v_max_write_iops integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE qos
    SET qos_type = v_qos_type,
        name = v_name,
        description = v_description,
        storage_pool_id = v_storage_pool_id,
        max_throughput = v_max_throughput,
        max_read_throughput = v_max_read_throughput,
        max_write_throughput = v_max_write_throughput,
        max_iops = v_max_iops,
        max_read_iops = v_max_read_iops,
        max_write_iops = v_max_write_iops,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorageqos(v_id uuid, v_qos_type smallint, v_name character varying, v_description text, v_storage_pool_id uuid, v_max_throughput integer, v_max_read_throughput integer, v_max_write_throughput integer, v_max_iops integer, v_max_read_iops integer, v_max_write_iops integer) OWNER TO engine;

--
-- Name: updatestorageserverconnectionextension(uuid, uuid, character varying, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatestorageserverconnectionextension(v_id uuid, v_vds_id uuid, v_iqn character varying, v_user_name text, v_password text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE storage_server_connection_extension
    SET vds_id = v_vds_id,
        iqn = v_iqn,
        user_name = v_user_name,
        password = v_password
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatestorageserverconnectionextension(v_id uuid, v_vds_id uuid, v_iqn character varying, v_user_name text, v_password text) OWNER TO engine;

--
-- Name: updatesupportedclusterfeature(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatesupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid, v_is_enabled boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE supported_cluster_features
    SET is_enabled = v_is_enabled
    WHERE cluster_id = v_cluster_id
        AND feature_id = v_feature_id;
END;$$;


ALTER FUNCTION public.updatesupportedclusterfeature(v_feature_id uuid, v_cluster_id uuid, v_is_enabled boolean) OWNER TO engine;

--
-- Name: updatetags(character varying, uuid, character varying, uuid, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatetags(v_description character varying, v_tag_id uuid, v_tag_name character varying, v_parent_id uuid, v_readonly boolean, v_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE tags
    SET description = v_description,
        tag_name = v_tag_name,
        parent_id = v_parent_id,
        readonly = v_readonly,
        type = v_type,
        _update_date = LOCALTIMESTAMP
    WHERE tag_id = v_tag_id;
END;$$;


ALTER FUNCTION public.updatetags(v_description character varying, v_tag_id uuid, v_tag_name character varying, v_parent_id uuid, v_readonly boolean, v_type integer) OWNER TO engine;

--
-- Name: updatetags_vm_pool_map(integer, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatetags_vm_pool_map(v_tag_id integer, v_vm_pool_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
END;$$;


ALTER FUNCTION public.updatetags_vm_pool_map(v_tag_id integer, v_vm_pool_id integer) OWNER TO engine;

--
-- Name: updatetpmdata(uuid, text, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatetpmdata(v_vm_id uuid, v_tpm_data text, v_tpm_hash text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO vm_external_data (
        device_id,
        vm_id,
        tpm_data,
        tpm_hash
    )
    SELECT device_id, v_vm_id, v_tpm_data, v_tpm_hash
    FROM vm_device
    WHERE v_tpm_data IS NOT NULL AND vm_id = v_vm_id AND type = 'tpm'
    ON CONFLICT (device_id, vm_id) DO
    UPDATE
    SET tpm_data = v_tpm_data,
        tpm_hash = v_tpm_hash;
END;$$;


ALTER FUNCTION public.updatetpmdata(v_vm_id uuid, v_tpm_data text, v_tpm_hash text) OWNER TO engine;

--
-- Name: updateuser(character varying, character varying, character varying, character varying, character varying, character varying, uuid, character varying, boolean, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_last_admin_check_status boolean, v_external_id text, v_namespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM UpdateUserImpl(
        v_department,
        v_domain,
        v_email,
        v_name,
        v_note,
        v_surname,
        v_user_id,
        v_username,
        v_external_id,
        v_namespace);

    UPDATE users
    SET last_admin_check_status = v_last_admin_check_status
    WHERE domain = v_domain
        AND external_id = v_external_id;
END;$$;


ALTER FUNCTION public.updateuser(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_last_admin_check_status boolean, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: updateuserimpl(character varying, character varying, character varying, character varying, character varying, character varying, uuid, character varying, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateuserimpl(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE updated_rows INT;

BEGIN
    UPDATE users
    SET department = v_department,
        domain = v_domain,
        email = v_email,
        name = v_name,
        note = v_note,
        surname = v_surname,
        username = v_username,
        external_id = v_external_id,
        namespace = v_namespace,
        _update_date = CURRENT_TIMESTAMP
    WHERE external_id = v_external_id
        AND domain = v_domain;

    GET DIAGNOSTICS updated_rows = ROW_COUNT;

    RETURN updated_rows;
END;$$;


ALTER FUNCTION public.updateuserimpl(v_department character varying, v_domain character varying, v_email character varying, v_name character varying, v_note character varying, v_surname character varying, v_user_id uuid, v_username character varying, v_external_id text, v_namespace character varying) OWNER TO engine;

--
-- Name: updateuserprofileproperty(uuid, uuid, text, text, text, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updateuserprofileproperty(v_user_id uuid, v_property_id uuid, v_property_name text, v_property_type text, v_property_content text, v_new_property_id uuid) RETURNS SETOF public.user_profiles
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY

    UPDATE user_profiles
    -- update is valid only if provided property_id matches the ID
    -- currently stored in DB (for the property with the same name)
    -- the property_id should change each time the content changes
    SET property_id = v_new_property_id,
        property_content = v_property_content::jsonb
    WHERE
        property_id = v_property_id AND
        user_id = v_user_id AND
        property_name = v_property_name AND
        property_type = v_property_type
    RETURNING *;
END;$$;


ALTER FUNCTION public.updateuserprofileproperty(v_user_id uuid, v_property_id uuid, v_property_name text, v_property_type text, v_property_content text, v_new_property_id uuid) OWNER TO engine;

--
-- Name: updatevdcoption(character varying, text, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdcoption(v_option_name character varying, v_option_value text, v_option_id integer, v_version character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vdc_options
    SET option_name = v_option_name,
        option_value = v_option_value,
        version = v_version
    WHERE option_id = v_option_id;
END;$$;


ALTER FUNCTION public.updatevdcoption(v_option_name character varying, v_option_value text, v_option_id integer, v_version character varying) OWNER TO engine;

--
-- Name: updatevds_interface(character varying, character varying, integer, character varying, boolean, uuid, boolean, character varying, character varying, character varying, character varying, character varying, integer, character varying, integer, integer, uuid, character varying, integer, integer, boolean, text, character varying, character varying, integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevds_interface(v_addr character varying, v_bond_name character varying, v_bond_type integer, v_gateway character varying, v_ipv4_default_route boolean, v_id uuid, v_is_bond boolean, v_reported_switch_type character varying, v_bond_opts character varying, v_mac_addr character varying, v_name character varying, v_network_name character varying, v_speed integer, v_subnet character varying, v_boot_protocol integer, v_type integer, v_vds_id uuid, v_base_interface character varying, v_vlan_id integer, v_mtu integer, v_bridged boolean, v_labels text, v_ipv6_address character varying, v_ipv6_gateway character varying, v_ipv6_prefix integer, v_ipv6_boot_protocol integer, v_ad_partner_mac character varying, v_ad_aggregator_id integer, v_bond_active_slave character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_interface
    SET addr = v_addr,
        bond_name = v_bond_name,
        bond_type = v_bond_type,
        gateway = v_gateway,
        ipv4_default_route = v_ipv4_default_route,
        is_bond = v_is_bond,
        reported_switch_type = v_reported_switch_type,
        bond_opts = v_bond_opts,
        mac_addr = v_mac_addr,
        name = v_name,
        network_name = v_network_name,
        speed = v_speed,
        subnet = v_subnet,
        boot_protocol = v_boot_protocol,
        type = v_type,
        VDS_ID = v_vds_id,
        base_interface = v_base_interface,
        vlan_id = v_vlan_id,
        _update_date = LOCALTIMESTAMP,
        mtu = v_mtu,
        bridged = v_bridged,
        labels = v_labels,
        ipv6_address = v_ipv6_address,
        ipv6_gateway = v_ipv6_gateway,
        ipv6_prefix = v_ipv6_prefix,
        ipv6_boot_protocol = v_ipv6_boot_protocol,
        ad_partner_mac = v_ad_partner_mac,
        ad_aggregator_id = v_ad_aggregator_id,
        bond_active_slave = v_bond_active_slave
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevds_interface(v_addr character varying, v_bond_name character varying, v_bond_type integer, v_gateway character varying, v_ipv4_default_route boolean, v_id uuid, v_is_bond boolean, v_reported_switch_type character varying, v_bond_opts character varying, v_mac_addr character varying, v_name character varying, v_network_name character varying, v_speed integer, v_subnet character varying, v_boot_protocol integer, v_type integer, v_vds_id uuid, v_base_interface character varying, v_vlan_id integer, v_mtu integer, v_bridged boolean, v_labels text, v_ipv6_address character varying, v_ipv6_gateway character varying, v_ipv6_prefix integer, v_ipv6_boot_protocol integer, v_ad_partner_mac character varying, v_ad_aggregator_id integer, v_bond_active_slave character varying) OWNER TO engine;

--
-- Name: updatevds_interface_statistics(uuid, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, integer, double precision, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevds_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vds_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_interface_statistics
    SET rx_drop = v_rx_drop,
        rx_rate = v_rx_rate,
        rx_total = v_rx_total,
        rx_offset = v_rx_offset,
        tx_drop = v_tx_drop,
        tx_rate = v_tx_rate,
        tx_total = v_tx_total,
        tx_offset = v_tx_offset,
        vds_id = v_vds_id,
        iface_status = v_iface_status,
        sample_time = v_sample_time,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevds_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vds_id uuid) OWNER TO engine;

--
-- Name: updatevdsdynamic(integer, integer, character varying, numeric, character varying, boolean, integer, integer, integer, uuid, integer, integer, integer, integer, integer, integer, integer, integer, character varying, character varying, character varying, character varying, integer, character varying, integer, integer, integer, boolean, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, text, integer, character varying, character varying, character varying, character varying, character varying, character varying, text, text, smallint, integer, smallint, boolean, character varying, text, text, boolean, boolean, text, character varying, boolean, boolean, jsonb, boolean, jsonb, boolean, boolean, boolean, character varying, jsonb, character varying, boolean, boolean, character varying, boolean, boolean, jsonb, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamic(v_cpu_cores integer, v_cpu_threads integer, v_cpu_model character varying, v_cpu_speed_mh numeric, v_if_total_speed character varying, v_kvm_enabled boolean, v_mem_commited integer, v_physical_mem_mb integer, v_status integer, v_vds_id uuid, v_vm_active integer, v_vm_count integer, v_vms_cores_count integer, v_vm_migrating integer, v_incoming_migrations integer, v_outgoing_migrations integer, v_reserved_mem integer, v_guest_overhead integer, v_rpm_version character varying, v_software_version character varying, v_version_name character varying, v_build_name character varying, v_previous_status integer, v_cpu_flags character varying, v_pending_vcpus_count integer, v_pending_vmem_size integer, v_cpu_sockets integer, v_net_config_dirty boolean, v_supported_cluster_levels character varying, v_supported_engines character varying, v_host_os character varying, v_kvm_version character varying, v_libvirt_version character varying, v_spice_version character varying, v_gluster_version character varying, v_librbd1_version character varying, v_glusterfs_cli_version character varying, v_openvswitch_version character varying, v_kernel_version character varying, v_nmstate_version character varying, v_iscsi_initiator_name character varying, v_transparent_hugepages_state integer, v_hooks text, v_non_operational_reason integer, v_hw_manufacturer character varying, v_hw_product_name character varying, v_hw_version character varying, v_hw_serial_number character varying, v_hw_uuid character varying, v_hw_family character varying, v_hbas text, v_supported_emulated_machines text, v_kdump_status smallint, v_selinux_enforce_mode integer, v_auto_numa_balancing smallint, v_is_numa_supported boolean, v_supported_rng_sources character varying, v_online_cpus text, v_maintenance_reason text, v_is_update_available boolean, v_is_hostdev_enabled boolean, v_kernel_args text, v_pretty_name character varying, v_hosted_engine_configured boolean, v_in_fence_flow boolean, v_kernel_features jsonb, v_vnc_encryption_enabled boolean, v_connector_info jsonb, v_backup_enabled boolean, v_cold_backup_enabled boolean, v_clear_bitmaps_enabled boolean, v_supported_domain_versions character varying, v_supported_block_size jsonb, v_tsc_frequency character varying, v_tsc_scaling boolean, v_fips_enabled boolean, v_boot_uuid character varying, v_cd_change_pdiv boolean, v_ovn_configured boolean, v_cpu_topology jsonb, v_vdsm_cpus_affinity character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_dynamic
        SET cpu_cores = v_cpu_cores,
            cpu_threads = v_cpu_threads,
            cpu_model = v_cpu_model,
            cpu_speed_mh = v_cpu_speed_mh,
            if_total_speed = v_if_total_speed,
            kvm_enabled = v_kvm_enabled,
            mem_commited = v_mem_commited,
            physical_mem_mb = v_physical_mem_mb,
            status = v_status,
            vm_active = v_vm_active,
            vm_count = v_vm_count,
            vm_migrating = v_vm_migrating,
            incoming_migrations = v_incoming_migrations,
            outgoing_migrations = v_outgoing_migrations,
            reserved_mem = v_reserved_mem,
            guest_overhead = v_guest_overhead,
            rpm_version = v_rpm_version,
            software_version = v_software_version,
            version_name = v_version_name,
            build_name = v_build_name,
            previous_status = v_previous_status,
            cpu_flags = v_cpu_flags,
            vms_cores_count = v_vms_cores_count,
            pending_vcpus_count = v_pending_vcpus_count,
            pending_vmem_size = v_pending_vmem_size,
            cpu_sockets = v_cpu_sockets,
            net_config_dirty = v_net_config_dirty,
            supported_cluster_levels = v_supported_cluster_levels,
            supported_engines = v_supported_engines,
            host_os = v_host_os,
            kvm_version = v_kvm_version,
            libvirt_version = v_libvirt_version,
            spice_version = v_spice_version,
            gluster_version = v_gluster_version,
            librbd1_version = v_librbd1_version,
            glusterfs_cli_version = v_glusterfs_cli_version,
            openvswitch_version = v_openvswitch_version,
            kernel_version = v_kernel_version,
            nmstate_version = v_nmstate_version,
            iscsi_initiator_name = v_iscsi_initiator_name,
            transparent_hugepages_state = v_transparent_hugepages_state,
            hooks = v_hooks,
            _update_date = LOCALTIMESTAMP,
            non_operational_reason = v_non_operational_reason,
            hw_manufacturer = v_hw_manufacturer,
            hw_product_name = v_hw_product_name,
            hw_version = v_hw_version,
            hw_serial_number = v_hw_serial_number,
            hw_uuid = v_hw_uuid,
            hw_family = v_hw_family,
            hbas = v_hbas,
            supported_emulated_machines = v_supported_emulated_machines,
            kdump_status = v_kdump_status,
            selinux_enforce_mode = v_selinux_enforce_mode,
            auto_numa_balancing = v_auto_numa_balancing,
            is_numa_supported = v_is_numa_supported,
            supported_rng_sources = v_supported_rng_sources,
            online_cpus = v_online_cpus,
            maintenance_reason = v_maintenance_reason,
            is_update_available = v_is_update_available,
            is_hostdev_enabled = v_is_hostdev_enabled,
            kernel_args = v_kernel_args,
            pretty_name = v_pretty_name,
            hosted_engine_configured = v_hosted_engine_configured,
            in_fence_flow = v_in_fence_flow,
            kernel_features = v_kernel_features,
            vnc_encryption_enabled = v_vnc_encryption_enabled,
            connector_info = v_connector_info,
            backup_enabled = v_backup_enabled,
            cold_backup_enabled = v_cold_backup_enabled,
            clear_bitmaps_enabled = v_clear_bitmaps_enabled,
            supported_domain_versions = v_supported_domain_versions,
            supported_block_size = v_supported_block_size,
            tsc_frequency = v_tsc_frequency,
            tsc_scaling = v_tsc_scaling,
            fips_enabled = v_fips_enabled,
            boot_uuid = v_boot_uuid,
            cd_change_pdiv = v_cd_change_pdiv,
            ovn_configured = v_ovn_configured,
            cpu_topology = v_cpu_topology,
            vdsm_cpus_affinity = v_vdsm_cpus_affinity
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsdynamic(v_cpu_cores integer, v_cpu_threads integer, v_cpu_model character varying, v_cpu_speed_mh numeric, v_if_total_speed character varying, v_kvm_enabled boolean, v_mem_commited integer, v_physical_mem_mb integer, v_status integer, v_vds_id uuid, v_vm_active integer, v_vm_count integer, v_vms_cores_count integer, v_vm_migrating integer, v_incoming_migrations integer, v_outgoing_migrations integer, v_reserved_mem integer, v_guest_overhead integer, v_rpm_version character varying, v_software_version character varying, v_version_name character varying, v_build_name character varying, v_previous_status integer, v_cpu_flags character varying, v_pending_vcpus_count integer, v_pending_vmem_size integer, v_cpu_sockets integer, v_net_config_dirty boolean, v_supported_cluster_levels character varying, v_supported_engines character varying, v_host_os character varying, v_kvm_version character varying, v_libvirt_version character varying, v_spice_version character varying, v_gluster_version character varying, v_librbd1_version character varying, v_glusterfs_cli_version character varying, v_openvswitch_version character varying, v_kernel_version character varying, v_nmstate_version character varying, v_iscsi_initiator_name character varying, v_transparent_hugepages_state integer, v_hooks text, v_non_operational_reason integer, v_hw_manufacturer character varying, v_hw_product_name character varying, v_hw_version character varying, v_hw_serial_number character varying, v_hw_uuid character varying, v_hw_family character varying, v_hbas text, v_supported_emulated_machines text, v_kdump_status smallint, v_selinux_enforce_mode integer, v_auto_numa_balancing smallint, v_is_numa_supported boolean, v_supported_rng_sources character varying, v_online_cpus text, v_maintenance_reason text, v_is_update_available boolean, v_is_hostdev_enabled boolean, v_kernel_args text, v_pretty_name character varying, v_hosted_engine_configured boolean, v_in_fence_flow boolean, v_kernel_features jsonb, v_vnc_encryption_enabled boolean, v_connector_info jsonb, v_backup_enabled boolean, v_cold_backup_enabled boolean, v_clear_bitmaps_enabled boolean, v_supported_domain_versions character varying, v_supported_block_size jsonb, v_tsc_frequency character varying, v_tsc_scaling boolean, v_fips_enabled boolean, v_boot_uuid character varying, v_cd_change_pdiv boolean, v_ovn_configured boolean, v_cpu_topology jsonb, v_vdsm_cpus_affinity character varying) OWNER TO engine;

--
-- Name: updatevdsdynamicisupdateavailable(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamicisupdateavailable(v_vds_guid uuid, v_is_update_available boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET is_update_available = v_is_update_available
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.updatevdsdynamicisupdateavailable(v_vds_guid uuid, v_is_update_available boolean) OWNER TO engine;

--
-- Name: updatevdsdynamicnetconfigdirty(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamicnetconfigdirty(v_vds_guid uuid, v_net_config_dirty boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET net_config_dirty = v_net_config_dirty
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.updatevdsdynamicnetconfigdirty(v_vds_guid uuid, v_net_config_dirty boolean) OWNER TO engine;

--
-- Name: updatevdsdynamicpowermanagementpolicyflag(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamicpowermanagementpolicyflag(v_vds_id uuid, v_controlled_by_pm_policy boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_dynamic
        SET controlled_by_pm_policy = v_controlled_by_pm_policy
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsdynamicpowermanagementpolicyflag(v_vds_id uuid, v_controlled_by_pm_policy boolean) OWNER TO engine;

--
-- Name: updatevdsdynamicstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamicstatus(v_vds_guid uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET status = v_status
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.updatevdsdynamicstatus(v_vds_guid uuid, v_status integer) OWNER TO engine;

--
-- Name: updatevdsdynamicstatusandreasons(uuid, integer, integer, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsdynamicstatusandreasons(v_vds_guid uuid, v_status integer, v_non_operational_reason integer, v_maintenance_reason text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_dynamic
    SET status = v_status,
        non_operational_reason = v_non_operational_reason,
        maintenance_reason = v_maintenance_reason
    WHERE vds_id = v_vds_guid;
END;$$;


ALTER FUNCTION public.updatevdsdynamicstatusandreasons(v_vds_guid uuid, v_status integer, v_non_operational_reason integer, v_maintenance_reason text) OWNER TO engine;

--
-- Name: updatevdsreinstallrequired(uuid, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsreinstallrequired(v_vds_id uuid, v_reinstall_required boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_static
        SET reinstall_required = v_reinstall_required
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsreinstallrequired(v_vds_id uuid, v_reinstall_required boolean) OWNER TO engine;

--
-- Name: updatevdsstatic(character varying, text, character varying, integer, uuid, uuid, character varying, boolean, integer, boolean, character varying, boolean, bigint, integer, character varying, character varying, character varying, integer, character varying, boolean, uuid, text, boolean, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsstatic(v_host_name character varying, v_free_text_comment text, v_vds_unique_id character varying, v_port integer, v_cluster_id uuid, v_vds_id uuid, v_vds_name character varying, v_server_ssl_enabled boolean, v_vds_type integer, v_pm_enabled boolean, v_pm_proxy_preferences character varying, v_pm_detect_kdump boolean, v_otp_validity bigint, v_vds_spm_priority integer, v_sshkeyfingerprint character varying, v_ssh_public_key character varying, v_console_address character varying, v_ssh_port integer, v_ssh_username character varying, v_disable_auto_pm boolean, v_host_provider_id uuid, v_kernel_cmdline text, v_reinstall_required boolean, v_vgpu_placement integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_static
        SET host_name = v_host_name,
            free_text_comment = v_free_text_comment,
            vds_unique_id = v_vds_unique_id,
            port = v_port,
            cluster_id = v_cluster_id,
            vds_name = v_vds_name,
            server_SSL_enabled = v_server_SSL_enabled,
            vds_type = v_vds_type,
            _update_date = LOCALTIMESTAMP,
            pm_enabled = v_pm_enabled,
            pm_proxy_preferences = v_pm_proxy_preferences,
            pm_detect_kdump = v_pm_detect_kdump,
            otp_validity = v_otp_validity,
            vds_spm_priority = v_vds_spm_priority,
            sshKeyFingerprint = v_sshKeyFingerprint,
            ssh_public_key = v_ssh_public_key,
            host_provider_id = v_host_provider_id,
            console_address = v_console_address,
            ssh_port = v_ssh_port,
            ssh_username = v_ssh_username,
            disable_auto_pm = v_disable_auto_pm,
            kernel_cmdline = v_kernel_cmdline,
            reinstall_required = v_reinstall_required,
            vgpu_placement = v_vgpu_placement
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsstatic(v_host_name character varying, v_free_text_comment text, v_vds_unique_id character varying, v_port integer, v_cluster_id uuid, v_vds_id uuid, v_vds_name character varying, v_server_ssl_enabled boolean, v_vds_type integer, v_pm_enabled boolean, v_pm_proxy_preferences character varying, v_pm_detect_kdump boolean, v_otp_validity bigint, v_vds_spm_priority integer, v_sshkeyfingerprint character varying, v_ssh_public_key character varying, v_console_address character varying, v_ssh_port integer, v_ssh_username character varying, v_disable_auto_pm boolean, v_host_provider_id uuid, v_kernel_cmdline text, v_reinstall_required boolean, v_vgpu_placement integer) OWNER TO engine;

--
-- Name: updatevdsstatickernelcmdlines(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsstatickernelcmdlines(v_vds_id uuid, v_kernel_cmdline text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_static
        SET kernel_cmdline = v_kernel_cmdline,
            last_stored_kernel_cmdline = v_kernel_cmdline
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsstatickernelcmdlines(v_vds_id uuid, v_kernel_cmdline text) OWNER TO engine;

--
-- Name: updatevdsstaticlaststoredkernelcmdline(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsstaticlaststoredkernelcmdline(v_vds_id uuid, v_last_stored_kernel_cmdline text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_static
        SET last_stored_kernel_cmdline = v_last_stored_kernel_cmdline
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsstaticlaststoredkernelcmdline(v_vds_id uuid, v_last_stored_kernel_cmdline text) OWNER TO engine;

--
-- Name: updatevdsstatistics(numeric, numeric, numeric, numeric, integer, integer, integer, uuid, bigint, bigint, bigint, bigint, integer, bigint, boolean, integer, bigint, integer, boolean, boolean, boolean, boolean, timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevdsstatistics(v_cpu_idle numeric, v_cpu_load numeric, v_cpu_sys numeric, v_cpu_user numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_vds_id uuid, v_mem_free bigint, v_mem_shared bigint, v_swap_free bigint, v_swap_total bigint, v_ksm_cpu_percent integer, v_ksm_pages bigint, v_ksm_state boolean, v_anonymous_hugepages integer, v_boot_time bigint, v_ha_score integer, v_ha_configured boolean, v_ha_active boolean, v_ha_global_maintenance boolean, v_ha_local_maintenance boolean, v_cpu_over_commit_time_stamp timestamp with time zone, v_hugepages text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    BEGIN
        UPDATE vds_statistics
        SET cpu_idle = v_cpu_idle,
            cpu_load = v_cpu_load,
            cpu_sys = v_cpu_sys,
            cpu_user = v_cpu_user,
            usage_cpu_percent = v_usage_cpu_percent,
            usage_mem_percent = v_usage_mem_percent,
            usage_network_percent = v_usage_network_percent,
            mem_free = v_mem_free,
            mem_shared = v_mem_shared,
            swap_free = v_swap_free,
            swap_total = v_swap_total,
            ksm_cpu_percent = v_ksm_cpu_percent,
            ksm_pages = v_ksm_pages,
            ksm_state = v_ksm_state,
            anonymous_hugepages = v_anonymous_hugepages,
            boot_time = v_boot_time,
            ha_score = v_ha_score,
            ha_configured = v_ha_configured,
            ha_active = v_ha_active,
            ha_global_maintenance = v_ha_global_maintenance,
            ha_local_maintenance = v_ha_local_maintenance,
            _update_date = LOCALTIMESTAMP,
            cpu_over_commit_time_stamp = v_cpu_over_commit_time_stamp,
            hugepages = v_hugepages
        WHERE vds_id = v_vds_id;
    END;

    RETURN;
END;$$;


ALTER FUNCTION public.updatevdsstatistics(v_cpu_idle numeric, v_cpu_load numeric, v_cpu_sys numeric, v_cpu_user numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_vds_id uuid, v_mem_free bigint, v_mem_shared bigint, v_swap_free bigint, v_swap_total bigint, v_ksm_cpu_percent integer, v_ksm_pages bigint, v_ksm_state boolean, v_anonymous_hugepages integer, v_boot_time bigint, v_ha_score integer, v_ha_configured boolean, v_ha_active boolean, v_ha_global_maintenance boolean, v_ha_local_maintenance boolean, v_cpu_over_commit_time_stamp timestamp with time zone, v_hugepages text) OWNER TO engine;

--
-- Name: updatevm_interface_statistics(uuid, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, integer, double precision, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevm_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vm_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_interface_statistics
    SET rx_drop = v_rx_drop,
        rx_rate = v_rx_rate,
        rx_total = v_rx_total,
        rx_offset = v_rx_offset,
        tx_drop = v_tx_drop,
        tx_rate = v_tx_rate,
        tx_total = v_tx_total,
        tx_offset = v_tx_offset,
        vm_id = v_vm_id,
        iface_status = v_iface_status,
        sample_time = v_sample_time,
        _update_date = LOCALTIMESTAMP
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevm_interface_statistics(v_id uuid, v_rx_drop numeric, v_rx_rate numeric, v_rx_total numeric, v_rx_offset numeric, v_tx_drop numeric, v_tx_rate numeric, v_tx_total numeric, v_tx_offset numeric, v_iface_status integer, v_sample_time double precision, v_vm_id uuid) OWNER TO engine;

--
-- Name: updatevm_pool_map(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevm_pool_map(v_vm_guid uuid, v_vm_pool_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_pool_map
    SET vm_pool_id = v_vm_pool_id
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.updatevm_pool_map(v_vm_guid uuid, v_vm_pool_id uuid) OWNER TO engine;

--
-- Name: updatevm_pools(character varying, text, uuid, character varying, integer, boolean, character varying, integer, uuid, smallint, character varying, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevm_pools(v_vm_pool_description character varying, v_vm_pool_comment text, v_vm_pool_id uuid, v_vm_pool_name character varying, v_vm_pool_type integer, v_stateful boolean, v_parameters character varying, v_prestarted_vms integer, v_cluster_id uuid, v_max_assigned_vms_per_user smallint, v_spice_proxy character varying, v_is_auto_storage_select boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_pools
    SET vm_pool_description = v_vm_pool_description,
        vm_pool_comment = v_vm_pool_comment,
        vm_pool_name = v_vm_pool_name,
        vm_pool_type = v_vm_pool_type,
        stateful = v_stateful,
        parameters = v_parameters,
        prestarted_vms = v_prestarted_vms,
        cluster_id = v_cluster_id,
        max_assigned_vms_per_user = v_max_assigned_vms_per_user,
        spice_proxy = v_spice_proxy,
        is_auto_storage_select = v_is_auto_storage_select
    WHERE vm_pool_id = v_vm_pool_id;
END;$$;


ALTER FUNCTION public.updatevm_pools(v_vm_pool_description character varying, v_vm_pool_comment text, v_vm_pool_id uuid, v_vm_pool_name character varying, v_vm_pool_type integer, v_stateful boolean, v_parameters character varying, v_prestarted_vms integer, v_cluster_id uuid, v_max_assigned_vms_per_user smallint, v_spice_proxy character varying, v_is_auto_storage_select boolean) OWNER TO engine;

--
-- Name: updatevmbackup(uuid, uuid, uuid, uuid, uuid, text, timestamp with time zone, character varying, character varying, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmbackup(v_backup_id uuid, v_from_checkpoint_id uuid, v_to_checkpoint_id uuid, v_vm_id uuid, v_host_id uuid, v_phase text, v__update_date timestamp with time zone, v_description character varying, v_backup_type character varying, v_snapshot_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_backups
    SET backup_id = v_backup_id,
        from_checkpoint_id = v_from_checkpoint_id,
        to_checkpoint_id = v_to_checkpoint_id,
        vm_id = v_vm_id,
        host_id = v_host_id,
        phase = v_phase,
        _update_date = v__update_date,
        description = v_description,
        backup_type = v_backup_type,
        snapshot_id = v_snapshot_id
    WHERE backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.updatevmbackup(v_backup_id uuid, v_from_checkpoint_id uuid, v_to_checkpoint_id uuid, v_vm_id uuid, v_host_id uuid, v_phase text, v__update_date timestamp with time zone, v_description character varying, v_backup_type character varying, v_snapshot_id uuid) OWNER TO engine;

--
-- Name: updatevmbackupdiskmap(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmbackupdiskmap(v_backup_id uuid, v_disk_id uuid, v_backup_url text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_backup_disk_map
    SET backup_id = v_backup_id,
        disk_id = v_disk_id,
        backup_url = v_backup_url
    WHERE backup_id = v_backup_id AND disk_id = v_disk_id;
END;$$;


ALTER FUNCTION public.updatevmbackupdiskmap(v_backup_id uuid, v_disk_id uuid, v_backup_url text) OWNER TO engine;

--
-- Name: updatevmbackupstopped(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmbackupstopped(v_backup_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_backups
    SET is_stopped = true
    WHERE backup_id = v_backup_id;
END;$$;


ALTER FUNCTION public.updatevmbackupstopped(v_backup_id uuid) OWNER TO engine;

--
-- Name: updatevmcheckpoint(uuid, uuid, uuid, text, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmcheckpoint(v_checkpoint_id uuid, v_vm_id uuid, v_parent_id uuid, v_state text, v_description character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_checkpoints
    SET checkpoint_id = v_checkpoint_id,
        vm_id = v_vm_id,
        parent_id = v_parent_id,
        state = v_state,
        description = v_description
    WHERE checkpoint_id = v_checkpoint_id;
END;$$;


ALTER FUNCTION public.updatevmcheckpoint(v_checkpoint_id uuid, v_vm_id uuid, v_parent_id uuid, v_state text, v_description character varying) OWNER TO engine;

--
-- Name: updatevmcpuprofileidforclusterid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmcpuprofileidforclusterid(v_cluster_id uuid, v_cpu_profile_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_static
    SET cpu_profile_id = v_cpu_profile_id
    WHERE cluster_id = v_cluster_id;
END;$$;


ALTER FUNCTION public.updatevmcpuprofileidforclusterid(v_cluster_id uuid, v_cpu_profile_id uuid) OWNER TO engine;

--
-- Name: updatevmdevice(uuid, uuid, character varying, character varying, character varying, text, boolean, boolean, boolean, character varying, text, uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmdevice(v_device_id uuid, v_vm_id uuid, v_device character varying, v_type character varying, v_address character varying, v_spec_params text, v_is_managed boolean, v_is_plugged boolean, v_is_readonly boolean, v_alias character varying, v_custom_properties text, v_snapshot_id uuid, v_logical_name character varying, v_host_device character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_device
    SET device = v_device,
        type = v_type,
        address = v_address,
        spec_params = v_spec_params,
        is_managed = v_is_managed,
        is_plugged = v_is_plugged,
        is_readonly = v_is_readonly,
        alias = v_alias,
        custom_properties = v_custom_properties,
        snapshot_id = v_snapshot_id,
        logical_name = v_logical_name,
        host_device = v_host_device,
        _update_date = current_timestamp
    WHERE device_id = v_device_id
        AND vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.updatevmdevice(v_device_id uuid, v_vm_id uuid, v_device character varying, v_type character varying, v_address character varying, v_spec_params text, v_is_managed boolean, v_is_plugged boolean, v_is_readonly boolean, v_alias character varying, v_custom_properties text, v_snapshot_id uuid, v_logical_name character varying, v_host_device character varying) OWNER TO engine;

--
-- Name: updatevmdynamic(text, text, character varying, character varying, uuid, character varying, uuid, uuid, integer, uuid, character varying, character varying, character varying, timestamp with time zone, timestamp with time zone, bigint, timestamp with time zone, boolean, integer, integer, integer, character varying, integer, integer, integer, character varying, integer, numeric, character varying, boolean, boolean, character varying, character varying, character varying, character varying, integer, integer, integer, integer, character varying, integer, character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, text, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmdynamic(v_app_list text, v_guest_cur_user_name text, v_console_cur_user_name character varying, v_runtime_name character varying, v_console_user_id uuid, v_guest_os character varying, v_migrating_to_vds uuid, v_run_on_vds uuid, v_status integer, v_vm_guid uuid, v_vm_host character varying, v_vm_ip character varying, v_vm_fqdn character varying, v_last_start_time timestamp with time zone, v_boot_time timestamp with time zone, v_downtime bigint, v_last_stop_time timestamp with time zone, v_acpi_enable boolean, v_session integer, v_boot_sequence integer, v_utc_diff integer, v_client_ip character varying, v_guest_requested_memory integer, v_exit_status integer, v_pause_status integer, v_exit_message character varying, v_guest_agent_nics_hash integer, v_last_watchdog_event numeric, v_last_watchdog_action character varying, v_is_run_once boolean, v_volatile_run boolean, v_cpu_name character varying, v_emulated_machine character varying, v_current_cd character varying, v_reason character varying, v_exit_reason integer, v_guest_cpu_count integer, v_spice_port integer, v_spice_tls_port integer, v_spice_ip character varying, v_vnc_port integer, v_vnc_ip character varying, v_ovirt_guest_agent_status integer, v_qemu_guest_agent_status integer, v_guest_timezone_offset integer, v_guest_timezone_name character varying, v_guestos_arch integer, v_guestos_codename character varying, v_guestos_distribution character varying, v_guestos_kernel_version character varying, v_guestos_type character varying, v_guestos_version character varying, v_guest_containers text, v_current_cpu_pinning character varying, v_current_sockets integer, v_current_cores integer, v_current_threads integer, v_current_numa_pinning character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET app_list = v_app_list,
        guest_cur_user_name = v_guest_cur_user_name,
        console_cur_user_name = v_console_cur_user_name,
        runtime_name = v_runtime_name,
        console_user_id = v_console_user_id,
        guest_os = v_guest_os,
        migrating_to_vds = v_migrating_to_vds,
        run_on_vds = v_run_on_vds,
        status = v_status,
        vm_host = v_vm_host,
        vm_ip = v_vm_ip,
        vm_fqdn = v_vm_fqdn,
        last_start_time = v_last_start_time,
        boot_time = v_boot_time,
        downtime = v_downtime,
        last_stop_time = v_last_stop_time,
        acpi_enable = v_acpi_enable,
        session = v_session,
        boot_sequence = v_boot_sequence,
        utc_diff = v_utc_diff,
        client_ip = v_client_ip,
        guest_requested_memory = v_guest_requested_memory,
        exit_status = v_exit_status,
        pause_status = v_pause_status,
        exit_message = v_exit_message,
        guest_agent_nics_hash = v_guest_agent_nics_hash,
        last_watchdog_event = v_last_watchdog_event,
        last_watchdog_action = v_last_watchdog_action,
        is_run_once = v_is_run_once,
        volatile_run = v_volatile_run,
        cpu_name = v_cpu_name,
        emulated_machine = v_emulated_machine,
        current_cd = v_current_cd,
        reason = v_reason,
        exit_reason = v_exit_reason,
        guest_cpu_count = v_guest_cpu_count,
        spice_port = v_spice_port,
        spice_tls_port = v_spice_tls_port,
        spice_ip = v_spice_ip,
        vnc_port = v_vnc_port,
        vnc_ip = v_vnc_ip,
        ovirt_guest_agent_status = v_ovirt_guest_agent_status,
        qemu_guest_agent_status = v_qemu_guest_agent_status,
        guest_timezone_offset = v_guest_timezone_offset,
        guest_timezone_name = v_guest_timezone_name,
        guestos_arch = v_guestos_arch,
        guestos_codename = v_guestos_codename,
        guestos_distribution = v_guestos_distribution,
        guestos_kernel_version = v_guestos_kernel_version,
        guestos_type = v_guestos_type,
        guestos_version = v_guestos_version,
        guest_containers = v_guest_containers,
        current_cpu_pinning = v_current_cpu_pinning,
        current_sockets = v_current_sockets,
        current_cores = v_current_cores,
        current_threads = v_current_threads,
        current_numa_pinning = v_current_numa_pinning
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.updatevmdynamic(v_app_list text, v_guest_cur_user_name text, v_console_cur_user_name character varying, v_runtime_name character varying, v_console_user_id uuid, v_guest_os character varying, v_migrating_to_vds uuid, v_run_on_vds uuid, v_status integer, v_vm_guid uuid, v_vm_host character varying, v_vm_ip character varying, v_vm_fqdn character varying, v_last_start_time timestamp with time zone, v_boot_time timestamp with time zone, v_downtime bigint, v_last_stop_time timestamp with time zone, v_acpi_enable boolean, v_session integer, v_boot_sequence integer, v_utc_diff integer, v_client_ip character varying, v_guest_requested_memory integer, v_exit_status integer, v_pause_status integer, v_exit_message character varying, v_guest_agent_nics_hash integer, v_last_watchdog_event numeric, v_last_watchdog_action character varying, v_is_run_once boolean, v_volatile_run boolean, v_cpu_name character varying, v_emulated_machine character varying, v_current_cd character varying, v_reason character varying, v_exit_reason integer, v_guest_cpu_count integer, v_spice_port integer, v_spice_tls_port integer, v_spice_ip character varying, v_vnc_port integer, v_vnc_ip character varying, v_ovirt_guest_agent_status integer, v_qemu_guest_agent_status integer, v_guest_timezone_offset integer, v_guest_timezone_name character varying, v_guestos_arch integer, v_guestos_codename character varying, v_guestos_distribution character varying, v_guestos_kernel_version character varying, v_guestos_type character varying, v_guestos_version character varying, v_guest_containers text, v_current_cpu_pinning character varying, v_current_sockets integer, v_current_cores integer, v_current_threads integer, v_current_numa_pinning character varying) OWNER TO engine;

--
-- Name: updatevmdynamicstatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmdynamicstatus(v_vm_guid uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_dynamic
    SET status = v_status
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.updatevmdynamicstatus(v_vm_guid uuid, v_status integer) OWNER TO engine;

--
-- Name: updatevmicon(uuid, text); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmicon(v_id uuid, v_data_url text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_icons
    SET id = v_id,
        data_url = v_data_url
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevmicon(v_id uuid, v_data_url text) OWNER TO engine;

--
-- Name: updatevmicondefault(uuid, integer, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmicondefault(v_id uuid, v_os_id integer, v_small_icon_id uuid, v_large_icon_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_icon_defaults
    SET id = v_id,
        os_id = v_os_id,
        small_icon_id = v_small_icon_id,
        large_icon_id = v_large_icon_id
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevmicondefault(v_id uuid, v_os_id integer, v_small_icon_id uuid, v_large_icon_id uuid) OWNER TO engine;

--
-- Name: updatevminit(uuid, text, text, text, boolean, character varying, text, text, text, text, character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevminit(v_vm_id uuid, v_host_name text, v_domain text, v_authorized_keys text, v_regenerate_keys boolean, v_time_zone character varying, v_dns_servers text, v_dns_search_domains text, v_networks text, v_password text, v_winkey character varying, v_custom_script text, v_input_locale character varying, v_ui_language character varying, v_system_locale character varying, v_user_locale character varying, v_user_name character varying, v_active_directory_ou character varying, v_org_name character varying, v_cloud_init_network_protocol character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_init
    SET host_name = v_host_name,
        domain = v_domain,
        authorized_keys = v_authorized_keys,
        regenerate_keys = v_regenerate_keys,
        time_zone = v_time_zone,
        dns_servers = v_dns_servers,
        dns_search_domains = v_dns_search_domains,
        networks = v_networks,
        password = v_password,
        winkey = v_winkey,
        custom_script = v_custom_script,
        input_locale = v_input_locale,
        ui_language = v_ui_language,
        system_locale = v_system_locale,
        user_locale = v_user_locale,
        user_name = v_user_name,
        active_directory_ou = v_active_directory_ou,
        org_name = v_org_name,
        cloud_init_network_protocol = v_cloud_init_network_protocol
    WHERE vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.updatevminit(v_vm_id uuid, v_host_name text, v_domain text, v_authorized_keys text, v_regenerate_keys boolean, v_time_zone character varying, v_dns_servers text, v_dns_search_domains text, v_networks text, v_password text, v_winkey character varying, v_custom_script text, v_input_locale character varying, v_ui_language character varying, v_system_locale character varying, v_user_locale character varying, v_user_name character varying, v_active_directory_ou character varying, v_org_name character varying, v_cloud_init_network_protocol character varying) OWNER TO engine;

--
-- Name: updatevminterface(uuid, character varying, character varying, integer, uuid, uuid, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevminterface(v_id uuid, v_mac_addr character varying, v_name character varying, v_speed integer, v_vnic_profile_id uuid, v_vm_guid uuid, v_type integer, v_linked boolean, v_synced boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_interface
    SET mac_addr = v_mac_addr,
        name = v_name,
        speed = v_speed,
        vnic_profile_id = v_vnic_profile_id,
        vm_guid = v_vm_guid,
        type = v_type,
        _update_date = LOCALTIMESTAMP,
        linked = v_linked,
        synced = v_synced
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevminterface(v_id uuid, v_mac_addr character varying, v_name character varying, v_speed integer, v_vnic_profile_id uuid, v_vm_guid uuid, v_type integer, v_linked boolean, v_synced boolean) OWNER TO engine;

--
-- Name: updatevminterfacefilterparameter(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevminterfacefilterparameter(v_id uuid, v_name character varying, v_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_interface_filter_parameters
    SET name = v_name,
        value = v_value
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevminterfacefilterparameter(v_id uuid, v_name character varying, v_value character varying) OWNER TO engine;

--
-- Name: updatevmjobs(uuid, uuid, integer, integer, integer, integer, bigint, bigint, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmjobs(v_vm_job_id uuid, v_vm_id uuid, v_job_state integer, v_job_type integer, v_block_job_type integer, v_bandwidth integer, v_cursor_cur bigint, v_cursor_end bigint, v_image_group_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_jobs
    SET vm_job_id = v_vm_job_id,
        vm_id = v_vm_id,
        job_state = v_job_state,
        job_type = v_job_type,
        block_job_type = v_block_job_type,
        bandwidth = v_bandwidth,
        cursor_cur = v_cursor_cur,
        cursor_end = v_cursor_end,
        image_group_id = v_image_group_id
    WHERE vm_job_id = v_vm_job_id;
END;$$;


ALTER FUNCTION public.updatevmjobs(v_vm_job_id uuid, v_vm_id uuid, v_job_state integer, v_job_type integer, v_block_job_type integer, v_bandwidth integer, v_cursor_cur bigint, v_cursor_end bigint, v_image_group_id uuid) OWNER TO engine;

--
-- Name: updatevmleaseinfo(uuid, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmleaseinfo(v_vm_guid uuid, v_lease_info character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_dynamic
      SET lease_info = v_lease_info
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.updatevmleaseinfo(v_vm_guid uuid, v_lease_info character varying) OWNER TO engine;

--
-- Name: updatevmleasestoragedomainid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmleasestoragedomainid(v_vm_guid uuid, v_sd_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET lease_sd_id = v_sd_id
      WHERE vm_guid = v_vm_guid;
END; $$;


ALTER FUNCTION public.updatevmleasestoragedomainid(v_vm_guid uuid, v_sd_id uuid) OWNER TO engine;

--
-- Name: updatevmstatic(character varying, text, integer, integer, integer, integer, uuid, uuid, character varying, uuid, timestamp with time zone, integer, boolean, boolean, integer, integer, integer, integer, character varying, boolean, boolean, boolean, boolean, character varying, text, integer, integer, integer, integer, integer, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, integer, uuid, character varying, boolean, boolean, character varying, boolean, uuid, uuid, uuid, uuid, character varying, integer, integer, smallint, character varying, boolean, boolean, boolean, uuid, boolean, boolean, boolean, character varying, integer, character varying, uuid, uuid, uuid, character varying, character varying, character varying, uuid, uuid, boolean, integer, boolean, character varying, boolean, integer, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmstatic(v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_os integer, v_cluster_id uuid, v_vm_guid uuid, v_vm_name character varying, v_vmt_guid uuid, v_creation_date timestamp with time zone, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_is_initialized boolean, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_usb_policy integer, v_time_zone character varying, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_dedicated_vm_for_vds text, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_migration_support integer, v_predefined_properties character varying, v_userdefined_properties character varying, v_min_allocated_mem integer, v_quota_id uuid, v_cpu_pinning character varying, v_host_cpu_flags boolean, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_instance_type_id uuid, v_image_type_id uuid, v_original_template_id uuid, v_original_template_name character varying, v_migration_downtime integer, v_template_version_number integer, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_provider_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_namespace character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
     UPDATE vm_static
     SET
     description = v_description,
     free_text_comment = v_free_text_comment ,
     mem_size_mb = v_mem_size_mb,
     max_memory_size_mb = v_max_memory_size_mb,
     num_of_io_threads = v_num_of_io_threads,
     os = v_os,
     cluster_id = v_cluster_id,
     vm_name = v_vm_name,
     vmt_guid = v_vmt_guid,
     creation_date = v_creation_date,
     num_of_monitors = v_num_of_monitors,
     allow_console_reconnect = v_allow_console_reconnect,
     is_initialized = v_is_initialized,
     num_of_sockets = v_num_of_sockets,
     cpu_per_socket = v_cpu_per_socket,
     threads_per_cpu = v_threads_per_cpu,
     usb_policy = v_usb_policy,
     time_zone = v_time_zone,
     auto_startup = v_auto_startup,
     is_stateless = v_is_stateless,
     vm_type = v_vm_type,
     nice_level = v_nice_level,
     cpu_shares = v_cpu_shares,
     _update_date = LOCALTIMESTAMP,
     default_boot_sequence = v_default_boot_sequence,
     default_display_type = v_default_display_type,
     priority = v_priority,
     iso_path = v_iso_path,origin = v_origin,
     initrd_url = v_initrd_url,
     kernel_url = v_kernel_url,
     kernel_params = v_kernel_params,
     migration_support = v_migration_support,
     predefined_properties = v_predefined_properties,
     userdefined_properties = v_userdefined_properties,
     min_allocated_mem = v_min_allocated_mem,
     quota_id = v_quota_id,
     cpu_pinning = v_cpu_pinning,
     is_smartcard_enabled = v_is_smartcard_enabled,
     is_delete_protected = v_is_delete_protected,
     sso_method = v_sso_method,
     host_cpu_flags = v_host_cpu_flags,
     tunnel_migration = v_tunnel_migration,
     vnc_keyboard_layout = v_vnc_keyboard_layout,
     is_run_and_pause = v_is_run_and_pause,
     created_by_user_id = v_created_by_user_id,
     instance_type_id = v_instance_type_id,
     image_type_id = v_image_type_id,
     original_template_id = v_original_template_id,
     original_template_name = v_original_template_name,
     migration_downtime = v_migration_downtime,
     template_version_number = v_template_version_number,
     serial_number_policy = v_serial_number_policy,
     custom_serial_number = v_custom_serial_number,
     is_boot_menu_enabled = v_is_boot_menu_enabled,
     is_spice_file_transfer_enabled = v_is_spice_file_transfer_enabled,
     is_spice_copy_paste_enabled = v_is_spice_copy_paste_enabled,
     cpu_profile_id = v_cpu_profile_id,
     is_auto_converge = v_is_auto_converge,
     is_migrate_compressed = v_is_migrate_compressed,
     is_migrate_encrypted = v_is_migrate_encrypted,
     custom_emulated_machine = v_custom_emulated_machine,
     bios_type = v_bios_type,
     custom_cpu_name = v_custom_cpu_name,
     small_icon_id = v_small_icon_id,
     large_icon_id = v_large_icon_id,
     provider_id = v_provider_id,
     console_disconnect_action = v_console_disconnect_action,
     resume_behavior = v_resume_behavior,
     custom_compatibility_version=v_custom_compatibility_version,
     migration_policy_id = v_migration_policy_id,
     lease_sd_id = v_lease_sd_id,
     multi_queues_enabled = v_multi_queues_enabled,
     virtio_scsi_multi_queues = v_virtio_scsi_multi_queues,
     use_tsc_frequency = v_use_tsc_frequency,
     namespace = v_namespace,
     balloon_enabled = v_balloon_enabled,
     console_disconnect_action_delay = v_console_disconnect_action_delay,
     cpu_pinning_policy = v_cpu_pinning_policy,
     parallel_migrations = v_parallel_migrations
     WHERE vm_guid = v_vm_guid
         AND entity_type = 'VM';

      -- Update connections to dedicated hosts
      PERFORM UpdateDedicatedHostsToVm(
          v_vm_guid,
          v_dedicated_vm_for_vds);

END; $$;


ALTER FUNCTION public.updatevmstatic(v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_os integer, v_cluster_id uuid, v_vm_guid uuid, v_vm_name character varying, v_vmt_guid uuid, v_creation_date timestamp with time zone, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_is_initialized boolean, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_usb_policy integer, v_time_zone character varying, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_dedicated_vm_for_vds text, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_migration_support integer, v_predefined_properties character varying, v_userdefined_properties character varying, v_min_allocated_mem integer, v_quota_id uuid, v_cpu_pinning character varying, v_host_cpu_flags boolean, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_instance_type_id uuid, v_image_type_id uuid, v_original_template_id uuid, v_original_template_name character varying, v_migration_downtime integer, v_template_version_number integer, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_provider_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_namespace character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: updatevmstatistics(numeric, numeric, numeric, integer, integer, integer, text, uuid, bigint, bigint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmstatistics(v_cpu_sys numeric, v_cpu_user numeric, v_elapsed_time numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_disks_usage text, v_vm_guid uuid, v_guest_mem_buffered bigint, v_guest_mem_cached bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_statistics
    SET cpu_sys = v_cpu_sys,
        cpu_user = v_cpu_user,
        elapsed_time = v_elapsed_time,
        usage_cpu_percent = v_usage_cpu_percent,
        usage_mem_percent = v_usage_mem_percent,
        usage_network_percent = v_usage_network_percent,
        disks_usage = v_disks_usage,
        guest_mem_buffered = v_guest_mem_buffered,
        guest_mem_cached = v_guest_mem_cached,
        _update_date = LOCALTIMESTAMP
    WHERE vm_guid = v_vm_guid;
END;$$;


ALTER FUNCTION public.updatevmstatistics(v_cpu_sys numeric, v_cpu_user numeric, v_elapsed_time numeric, v_usage_cpu_percent integer, v_usage_mem_percent integer, v_usage_network_percent integer, v_disks_usage text, v_vm_guid uuid, v_guest_mem_buffered bigint, v_guest_mem_cached bigint) OWNER TO engine;

--
-- Name: updatevmtagsdefaultdisplaytype(uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmtagsdefaultdisplaytype(v_tag_id uuid, v_vm_id uuid, v_defaultdisplaytype integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE tags_vm_map
    SET DefaultDisplayType = v_DefaultDisplayType
    WHERE tags_vm_map.tag_id = v_tag_id
        AND tags_vm_map.vm_id = v_vm_id;
END;$$;


ALTER FUNCTION public.updatevmtagsdefaultdisplaytype(v_tag_id uuid, v_vm_id uuid, v_defaultdisplaytype integer) OWNER TO engine;

--
-- Name: updatevmtemplate(integer, timestamp with time zone, character varying, text, integer, integer, integer, character varying, integer, integer, integer, integer, uuid, uuid, integer, boolean, integer, integer, character varying, integer, integer, integer, integer, integer, integer, boolean, boolean, boolean, boolean, character varying, boolean, character varying, integer, character varying, character varying, character varying, uuid, integer, text, boolean, character varying, integer, boolean, uuid, character varying, integer, character varying, smallint, character varying, boolean, boolean, boolean, uuid, boolean, boolean, boolean, boolean, character varying, character varying, character varying, integer, character varying, uuid, uuid, character varying, character varying, character varying, uuid, uuid, boolean, integer, boolean, boolean, character varying, boolean, integer, smallint, smallint); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmtemplate(v_child_count integer, v_creation_date timestamp with time zone, v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_name character varying, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_os integer, v_vmt_guid uuid, v_cluster_id uuid, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_status integer, v_usb_policy integer, v_time_zone character varying, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_is_disabled boolean, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_quota_id uuid, v_migration_support integer, v_dedicated_vm_for_vds text, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_min_allocated_mem integer, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_template_type character varying, v_migration_downtime integer, v_template_version_name character varying, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_host_cpu_flags boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_predefined_properties character varying, v_userdefined_properties character varying, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_is_template_sealed boolean, v_cpu_pinning character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET child_count = v_child_count,
      creation_date = v_creation_date,
      description = v_description,
      free_text_comment = v_free_text_comment,
      mem_size_mb = v_mem_size_mb,
      max_memory_size_mb = v_max_memory_size_mb,
      num_of_io_threads = v_num_of_io_threads,
      vm_name = v_name,
      num_of_sockets = v_num_of_sockets,
      cpu_per_socket = v_cpu_per_socket,
      threads_per_cpu = v_threads_per_cpu,
      os = v_os,
      cluster_id = v_cluster_id,
      num_of_monitors = v_num_of_monitors,
      allow_console_reconnect = v_allow_console_reconnect,
      template_status = v_status,
      usb_policy = v_usb_policy,
      time_zone = v_time_zone,
      vm_type = v_vm_type,
      nice_level = v_nice_level,
      cpu_shares = v_cpu_shares,
      default_boot_sequence = v_default_boot_sequence,
      default_display_type = v_default_display_type,
      priority = v_priority,
      auto_startup = v_auto_startup,
      is_stateless = v_is_stateless,
      iso_path = v_iso_path,
      origin = v_origin,
      initrd_url = v_initrd_url,
      kernel_url = v_kernel_url,
      kernel_params = v_kernel_params,
      _update_date = CURRENT_TIMESTAMP,
      quota_id = v_quota_id,
      migration_support = v_migration_support,
      is_smartcard_enabled = v_is_smartcard_enabled,
      is_delete_protected = v_is_delete_protected,
      sso_method = v_sso_method,
      is_disabled = v_is_disabled,
      tunnel_migration = v_tunnel_migration,
      vnc_keyboard_layout = v_vnc_keyboard_layout,
      min_allocated_mem = v_min_allocated_mem,
      is_run_and_pause = v_is_run_and_pause,
      created_by_user_id = v_created_by_user_id,
      migration_downtime = v_migration_downtime,
      template_version_name = v_template_version_name,
      serial_number_policy = v_serial_number_policy,
      custom_serial_number = v_custom_serial_number,
      is_boot_menu_enabled = v_is_boot_menu_enabled,
      is_spice_file_transfer_enabled = v_is_spice_file_transfer_enabled,
      is_spice_copy_paste_enabled = v_is_spice_copy_paste_enabled,
      cpu_profile_id = v_cpu_profile_id,
      host_cpu_flags = v_host_cpu_flags,
      is_auto_converge = v_is_auto_converge,
      is_migrate_compressed = v_is_migrate_compressed,
      is_migrate_encrypted = v_is_migrate_encrypted,
      predefined_properties = v_predefined_properties,
      userdefined_properties = v_userdefined_properties,
      custom_emulated_machine = v_custom_emulated_machine,
      bios_type = v_bios_type,
      custom_cpu_name = v_custom_cpu_name,
      small_icon_id = v_small_icon_id,
      large_icon_id = v_large_icon_id,
      console_disconnect_action = v_console_disconnect_action,
      resume_behavior = v_resume_behavior,
      custom_compatibility_version = v_custom_compatibility_version,
      migration_policy_id = v_migration_policy_id,
      lease_sd_id = v_lease_sd_id,
      multi_queues_enabled = v_multi_queues_enabled,
      virtio_scsi_multi_queues = v_virtio_scsi_multi_queues,
      use_tsc_frequency = v_use_tsc_frequency,
      is_template_sealed = v_is_template_sealed,
      cpu_pinning = v_cpu_pinning,
      balloon_enabled = v_balloon_enabled,
      console_disconnect_action_delay = v_console_disconnect_action_delay,
      cpu_pinning_policy = v_cpu_pinning_policy,
      parallel_migrations = v_parallel_migrations
      WHERE vm_guid = v_vmt_guid
          AND entity_type = v_template_type;

      -- update template versions to new name
      UPDATE vm_static
        SET vm_name = v_name
      WHERE vm_guid <> v_vmt_guid
          AND vmt_guid = v_vmt_guid
          AND entity_type = v_template_type;

      -- Update connections to dedicated hosts
      PERFORM UpdateDedicatedHostsToVm(v_vmt_guid, v_dedicated_vm_for_vds);
END; $$;


ALTER FUNCTION public.updatevmtemplate(v_child_count integer, v_creation_date timestamp with time zone, v_description character varying, v_free_text_comment text, v_mem_size_mb integer, v_max_memory_size_mb integer, v_num_of_io_threads integer, v_name character varying, v_num_of_sockets integer, v_cpu_per_socket integer, v_threads_per_cpu integer, v_os integer, v_vmt_guid uuid, v_cluster_id uuid, v_num_of_monitors integer, v_allow_console_reconnect boolean, v_status integer, v_usb_policy integer, v_time_zone character varying, v_vm_type integer, v_nice_level integer, v_cpu_shares integer, v_default_boot_sequence integer, v_default_display_type integer, v_priority integer, v_auto_startup boolean, v_is_stateless boolean, v_is_smartcard_enabled boolean, v_is_delete_protected boolean, v_sso_method character varying, v_is_disabled boolean, v_iso_path character varying, v_origin integer, v_initrd_url character varying, v_kernel_url character varying, v_kernel_params character varying, v_quota_id uuid, v_migration_support integer, v_dedicated_vm_for_vds text, v_tunnel_migration boolean, v_vnc_keyboard_layout character varying, v_min_allocated_mem integer, v_is_run_and_pause boolean, v_created_by_user_id uuid, v_template_type character varying, v_migration_downtime integer, v_template_version_name character varying, v_serial_number_policy smallint, v_custom_serial_number character varying, v_is_boot_menu_enabled boolean, v_is_spice_file_transfer_enabled boolean, v_is_spice_copy_paste_enabled boolean, v_cpu_profile_id uuid, v_host_cpu_flags boolean, v_is_auto_converge boolean, v_is_migrate_compressed boolean, v_is_migrate_encrypted boolean, v_predefined_properties character varying, v_userdefined_properties character varying, v_custom_emulated_machine character varying, v_bios_type integer, v_custom_cpu_name character varying, v_small_icon_id uuid, v_large_icon_id uuid, v_console_disconnect_action character varying, v_resume_behavior character varying, v_custom_compatibility_version character varying, v_migration_policy_id uuid, v_lease_sd_id uuid, v_multi_queues_enabled boolean, v_virtio_scsi_multi_queues integer, v_use_tsc_frequency boolean, v_is_template_sealed boolean, v_cpu_pinning character varying, v_balloon_enabled boolean, v_console_disconnect_action_delay integer, v_cpu_pinning_policy smallint, v_parallel_migrations smallint) OWNER TO engine;

--
-- Name: updatevmtemplateshiftbasetemplate(uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmtemplateshiftbasetemplate(v_base_template_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vm_static
    SET vmt_guid = (SELECT vm_guid
        FROM vm_static
        WHERE entity_type = 'TEMPLATE'
            AND vmt_guid = v_base_template_id
        ORDER BY template_version_number
        OFFSET 1
        LIMIT 1
    )
    WHERE entity_type = 'TEMPLATE'
        AND vmt_guid = v_base_template_id
        AND vm_guid != vmt_guid;
END; $$;


ALTER FUNCTION public.updatevmtemplateshiftbasetemplate(v_base_template_id uuid) OWNER TO engine;

--
-- Name: updatevmtemplatestatus(uuid, integer); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevmtemplatestatus(v_vmt_guid uuid, v_status integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
      UPDATE vm_static
      SET    template_status = v_status
      WHERE  vm_guid = v_vmt_guid;
END; $$;


ALTER FUNCTION public.updatevmtemplatestatus(v_vmt_guid uuid, v_status integer) OWNER TO engine;

--
-- Name: updatevnicprofile(uuid, character varying, uuid, uuid, boolean, boolean, boolean, text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.updatevnicprofile(v_id uuid, v_name character varying, v_network_id uuid, v_network_qos_id uuid, v_port_mirroring boolean, v_passthrough boolean, v_migratable boolean, v_custom_properties text, v_description text, v_network_filter_id uuid, v_failover_vnic_profile_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vnic_profiles
    SET id = v_id,
        name = v_name,
        network_id = v_network_id,
        network_qos_id = v_network_qos_id,
        port_mirroring = v_port_mirroring,
        passthrough = v_passthrough,
        migratable = v_migratable,
        custom_properties = v_custom_properties,
        description = v_description,
        _update_date = LOCALTIMESTAMP,
        network_filter_id = v_network_filter_id,
        failover_vnic_profile_id = v_failover_vnic_profile_id
    WHERE id = v_id;
END;$$;


ALTER FUNCTION public.updatevnicprofile(v_id uuid, v_name character varying, v_network_id uuid, v_network_qos_id uuid, v_port_mirroring boolean, v_passthrough boolean, v_migratable boolean, v_custom_properties text, v_description text, v_network_filter_id uuid, v_failover_vnic_profile_id uuid) OWNER TO engine;

--
-- Name: upsertexternalvariable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.upsertexternalvariable(v_var_name character varying, v_var_value character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE record_found BOOLEAN;

BEGIN
    SELECT UpdateExternalVariable(v_var_name, v_var_value)
    INTO record_found;

    IF NOT record_found THEN
        PERFORM InsertExternalVariable(v_var_name, v_var_value);
    END IF;
END;$$;


ALTER FUNCTION public.upsertexternalvariable(v_var_name character varying, v_var_value character varying) OWNER TO engine;

--
-- Name: upsertkdumpstatus(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.upsertkdumpstatus(v_vds_id uuid, v_status character varying, v_address character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE vds_kdump_status
    SET status = v_status,
        address = v_address
    WHERE vds_id = v_vds_id;

    IF NOT found THEN
        INSERT INTO vds_kdump_status (
            vds_id,
            status,
            address
            )
        VALUES (
            v_vds_id,
            v_status,
            v_address
            );
    END IF;

    RETURN 1;
END;$$;


ALTER FUNCTION public.upsertkdumpstatus(v_vds_id uuid, v_status character varying, v_address character varying) OWNER TO engine;

--
-- Name: upsertkdumpstatusforip(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: engine
--

CREATE FUNCTION public.upsertkdumpstatusforip(v_ip character varying, v_status character varying, v_address character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE v_vds_id UUID;

updated_rows INT;

BEGIN
    updated_rows := 0;

    SELECT vds_id
    INTO v_vds_id
    FROM vds_interface
    WHERE addr = v_ip;

    IF v_vds_id IS NOT NULL THEN
        SELECT UpsertKdumpStatus(v_vds_id, v_status, v_address)
        INTO updated_rows;
    END IF;

    RETURN updated_rows;
END;$$;


ALTER FUNCTION public.upsertkdumpstatusforip(v_ip character varying, v_status character varying, v_address character varying) OWNER TO engine;

--
-- Name: failed_logins; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.failed_logins (
    id integer NOT NULL,
    user_id integer NOT NULL,
    minute_start timestamp with time zone NOT NULL,
    count integer NOT NULL
);


ALTER TABLE aaa_jdbc.failed_logins OWNER TO engine;

--
-- Name: failed_logins_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.failed_logins_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.failed_logins_id_seq OWNER TO engine;

--
-- Name: failed_logins_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.failed_logins_id_seq OWNED BY aaa_jdbc.failed_logins.id;


--
-- Name: group_attributes; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.group_attributes (
    id integer NOT NULL,
    group_id integer NOT NULL,
    name character varying(512) NOT NULL,
    value character varying(1024) NOT NULL
);


ALTER TABLE aaa_jdbc.group_attributes OWNER TO engine;

--
-- Name: group_attributes_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.group_attributes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.group_attributes_id_seq OWNER TO engine;

--
-- Name: group_attributes_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.group_attributes_id_seq OWNED BY aaa_jdbc.group_attributes.id;


--
-- Name: group_groups; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.group_groups (
    id integer NOT NULL,
    group_id integer NOT NULL,
    in_group_id integer NOT NULL
);


ALTER TABLE aaa_jdbc.group_groups OWNER TO engine;

--
-- Name: group_groups_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.group_groups_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.group_groups_id_seq OWNER TO engine;

--
-- Name: group_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.group_groups_id_seq OWNED BY aaa_jdbc.group_groups.id;


--
-- Name: groups; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.groups (
    id integer NOT NULL,
    name character varying(512) NOT NULL,
    uuid character varying(512) NOT NULL
);


ALTER TABLE aaa_jdbc.groups OWNER TO engine;

--
-- Name: groups_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.groups_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.groups_id_seq OWNER TO engine;

--
-- Name: groups_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.groups_id_seq OWNED BY aaa_jdbc.groups.id;


--
-- Name: schema_version_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.schema_version_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.schema_version_seq OWNER TO engine;

--
-- Name: schema_version; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.schema_version (
    id integer DEFAULT nextval('aaa_jdbc.schema_version_seq'::regclass) NOT NULL,
    version character varying(10) NOT NULL,
    script character varying(255) NOT NULL,
    checksum character varying(128),
    installed_by character varying(63),
    started_at timestamp without time zone DEFAULT now(),
    ended_at timestamp without time zone,
    state character varying(15) NOT NULL,
    current boolean NOT NULL,
    comment text DEFAULT ''::text
);


ALTER TABLE aaa_jdbc.schema_version OWNER TO engine;

--
-- Name: settings; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.settings (
    id integer NOT NULL,
    uuid character varying(512) NOT NULL,
    name character varying(512) NOT NULL,
    description text NOT NULL,
    value character varying(1024) NOT NULL
);


ALTER TABLE aaa_jdbc.settings OWNER TO engine;

--
-- Name: settings_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.settings_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.settings_id_seq OWNER TO engine;

--
-- Name: settings_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.settings_id_seq OWNED BY aaa_jdbc.settings.id;


--
-- Name: user_attributes; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.user_attributes (
    id integer NOT NULL,
    user_id integer NOT NULL,
    name character varying(512) NOT NULL,
    value character varying(1024) NOT NULL
);


ALTER TABLE aaa_jdbc.user_attributes OWNER TO engine;

--
-- Name: user_attributes_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.user_attributes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.user_attributes_id_seq OWNER TO engine;

--
-- Name: user_attributes_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.user_attributes_id_seq OWNED BY aaa_jdbc.user_attributes.id;


--
-- Name: user_groups; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.user_groups (
    id integer NOT NULL,
    user_id integer NOT NULL,
    in_group_id integer NOT NULL
);


ALTER TABLE aaa_jdbc.user_groups OWNER TO engine;

--
-- Name: user_groups_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.user_groups_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.user_groups_id_seq OWNER TO engine;

--
-- Name: user_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.user_groups_id_seq OWNED BY aaa_jdbc.user_groups.id;


--
-- Name: user_password_history; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.user_password_history (
    id integer NOT NULL,
    user_id integer NOT NULL,
    password character varying(1024) NOT NULL,
    changed timestamp with time zone NOT NULL
);


ALTER TABLE aaa_jdbc.user_password_history OWNER TO engine;

--
-- Name: user_password_history_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.user_password_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.user_password_history_id_seq OWNER TO engine;

--
-- Name: user_password_history_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.user_password_history_id_seq OWNED BY aaa_jdbc.user_password_history.id;


--
-- Name: users; Type: TABLE; Schema: aaa_jdbc; Owner: engine
--

CREATE TABLE aaa_jdbc.users (
    id integer NOT NULL,
    uuid character varying(512) NOT NULL,
    name character varying(512) NOT NULL,
    password character varying(1024) NOT NULL,
    password_valid_to timestamp with time zone NOT NULL,
    login_allowed character varying(1024) NOT NULL,
    nopasswd integer NOT NULL,
    disabled integer NOT NULL,
    unlock_time timestamp with time zone NOT NULL,
    last_successful_login timestamp with time zone NOT NULL,
    last_unsuccessful_login timestamp with time zone NOT NULL,
    consecutive_failures integer NOT NULL,
    valid_from timestamp with time zone NOT NULL,
    valid_to timestamp with time zone NOT NULL
);


ALTER TABLE aaa_jdbc.users OWNER TO engine;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: aaa_jdbc; Owner: engine
--

CREATE SEQUENCE aaa_jdbc.users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE aaa_jdbc.users_id_seq OWNER TO engine;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: aaa_jdbc; Owner: engine
--

ALTER SEQUENCE aaa_jdbc.users_id_seq OWNED BY aaa_jdbc.users.id;


--
-- Name: labels_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.labels_map (
    label_id uuid NOT NULL,
    vm_id uuid,
    vds_id uuid
);


ALTER TABLE public.labels_map OWNER TO engine;

--
-- Name: affinity_groups_members_flat_labels_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.affinity_groups_members_flat_labels_view AS
 SELECT affinity_group_members.affinity_group_id,
    affinity_group_members.vm_id,
    affinity_group_members.vds_id
   FROM public.affinity_group_members
  WHERE ((affinity_group_members.vm_id IS NOT NULL) OR (affinity_group_members.vds_id IS NOT NULL))
UNION
 SELECT affinity_group_members.affinity_group_id,
    labels_map.vm_id,
    NULL::uuid AS vds_id
   FROM (public.affinity_group_members
     JOIN public.labels_map ON ((affinity_group_members.vm_label_id = labels_map.label_id)))
  WHERE (labels_map.vm_id IS NOT NULL)
UNION
 SELECT affinity_group_members.affinity_group_id,
    NULL::uuid AS vm_id,
    labels_map.vds_id
   FROM (public.affinity_group_members
     JOIN public.labels_map ON ((affinity_group_members.host_label_id = labels_map.label_id)))
  WHERE (labels_map.vds_id IS NOT NULL);


ALTER TABLE public.affinity_groups_members_flat_labels_view OWNER TO engine;

--
-- Name: cluster_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.cluster_storage_domain AS
 SELECT cluster.cluster_id,
    cluster.name,
    cluster.description,
    cluster.free_text_comment,
    cluster.cpu_name,
    cluster.cpu_flags,
    cluster.cpu_verb,
    cluster._create_date,
    cluster._update_date,
    cluster.storage_pool_id,
    cluster.max_vds_memory_over_commit,
    cluster.count_threads_as_cores,
    cluster.compatibility_version,
    cluster.transparent_hugepages,
    cluster.migrate_on_error,
    cluster.architecture,
    storage_pool_iso_map.storage_id,
    storage_pool.name AS storage_pool_name
   FROM ((public.cluster
     LEFT JOIN public.storage_pool_iso_map ON ((cluster.storage_pool_id = storage_pool_iso_map.storage_pool_id)))
     LEFT JOIN public.storage_pool ON ((cluster.storage_pool_id = storage_pool.id)));


ALTER TABLE public.cluster_storage_domain OWNER TO engine;

--
-- Name: desktop_vms; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.desktop_vms AS
 SELECT vms.vm_name,
    vms.mem_size_mb,
    vms.max_memory_size_mb,
    vms.num_of_io_threads,
    vms.nice_level,
    vms.cpu_shares,
    vms.vmt_guid,
    vms.os,
    vms.description,
    vms.free_text_comment,
    vms.cluster_id,
    vms.creation_date,
    vms.auto_startup,
    vms.lease_sd_id,
    vms.lease_info,
    vms.is_stateless,
    vms.is_smartcard_enabled,
    vms.is_delete_protected,
    vms.sso_method,
    vms.dedicated_vm_for_vds,
    vms.default_boot_sequence,
    vms.vm_type,
    vms.vm_pool_spice_proxy,
    vms.cluster_name,
    vms.transparent_hugepages,
    vms.trusted_service,
    vms.storage_pool_id,
    vms.storage_pool_name,
    vms.cluster_spice_proxy,
    vms.vmt_name,
    vms.status,
    vms.vm_ip,
    vms.vm_ip_inet_array,
    vms.vm_host,
    vms.last_start_time,
    vms.boot_time,
    vms.downtime,
    vms.guest_cur_user_name,
    vms.console_cur_user_name,
    vms.runtime_name,
    vms.guest_os,
    vms.console_user_id,
    vms.guest_agent_nics_hash,
    vms.run_on_vds,
    vms.migrating_to_vds,
    vms.app_list,
    vms.vm_pool_name,
    vms.vm_pool_id,
    vms.vm_guid,
    vms.num_of_monitors,
    vms.allow_console_reconnect,
    vms.is_initialized,
    vms.num_of_sockets,
    vms.cpu_per_socket,
    vms.threads_per_cpu,
    vms.usb_policy,
    vms.acpi_enable,
    vms.session,
    vms.num_of_cpus,
    vms.quota_id,
    vms.quota_name,
    vms.quota_enforcement_type,
    vms.boot_sequence,
    vms.utc_diff,
    vms.client_ip,
    vms.guest_requested_memory,
    vms.time_zone,
    vms.cpu_user,
    vms.cpu_sys,
    vms.elapsed_time,
    vms.usage_network_percent,
    vms.disks_usage,
    vms.usage_mem_percent,
    vms.usage_cpu_percent,
    vms.run_on_vds_name,
    vms.cluster_cpu_name,
    vms.cluster_cpu_flags,
    vms.cluster_cpu_verb,
    vms.default_display_type,
    vms.priority,
    vms.iso_path,
    vms.origin,
    vms.cluster_compatibility_version,
    vms.initrd_url,
    vms.kernel_url,
    vms.kernel_params,
    vms.pause_status,
    vms.exit_message,
    vms.exit_status,
    vms.migration_support,
    vms.predefined_properties,
    vms.userdefined_properties,
    vms.min_allocated_mem,
    vms.hash,
    vms.cpu_pinning,
    vms.db_generation,
    vms.host_cpu_flags,
    vms.tunnel_migration,
    vms.vnc_keyboard_layout,
    vms.is_run_and_pause,
    vms.created_by_user_id,
    vms.last_watchdog_event,
    vms.last_watchdog_action,
    vms.is_run_once,
    vms.volatile_run,
    vms.vm_fqdn,
    vms.cpu_name,
    vms.emulated_machine,
    vms.current_cd,
    vms.reason,
    vms.exit_reason,
    vms.instance_type_id,
    vms.image_type_id,
    vms.architecture,
    vms.original_template_id,
    vms.original_template_name,
    vms.last_stop_time,
    vms.migration_downtime,
    vms.template_version_number,
    vms.serial_number_policy,
    vms.custom_serial_number,
    vms.is_boot_menu_enabled,
    vms.guest_cpu_count,
    vms.next_run_config_exists,
    vms.is_previewing_snapshot,
    vms.changed_fields,
    vms.is_spice_file_transfer_enabled,
    vms.is_spice_copy_paste_enabled,
    vms.cpu_profile_id,
    vms.is_auto_converge,
    vms.is_migrate_compressed,
    vms.is_migrate_encrypted,
    vms.custom_emulated_machine,
    vms.bios_type,
    vms.cluster_bios_type,
    vms.custom_cpu_name,
    vms.spice_port,
    vms.spice_tls_port,
    vms.spice_ip,
    vms.vnc_port,
    vms.vnc_ip,
    vms.ovirt_guest_agent_status,
    vms.qemu_guest_agent_status,
    vms.guest_mem_buffered,
    vms.guest_mem_cached,
    vms.small_icon_id,
    vms.large_icon_id,
    vms.migration_policy_id,
    vms.provider_id,
    vms.console_disconnect_action,
    vms.resume_behavior,
    vms.guest_timezone_offset,
    vms.guest_timezone_name,
    vms.guestos_arch,
    vms.guestos_codename,
    vms.guestos_distribution,
    vms.guestos_kernel_version,
    vms.guestos_type,
    vms.guestos_version,
    vms.custom_compatibility_version,
    vms.guest_containers,
    vms.has_illegal_images,
    vms.multi_queues_enabled,
    vms.virtio_scsi_multi_queues,
    vms.use_tsc_frequency,
    vms.namespace,
    vms.balloon_enabled,
    vms.console_disconnect_action_delay,
    vms.cpu_pinning_policy,
    vms.current_cpu_pinning,
    vms.current_sockets,
    vms.current_cores,
    vms.current_threads,
    vms.current_numa_pinning,
    vms.parallel_migrations
   FROM public.vms
  WHERE (vms.vm_type = 0);


ALTER TABLE public.desktop_vms OWNER TO engine;

--
-- Name: dwh_add_tags_relations_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_add_tags_relations_history_view AS
 SELECT tags.tag_id AS entity_id,
    tags.parent_id,
    (18)::smallint AS entity_type,
    tags._create_date AS attach_date,
    tags._update_date AS move_date
   FROM public.tags
  WHERE ((tags._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (tags._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))))
UNION ALL
 SELECT tags_vds_map.vds_id AS entity_id,
    tags_vds_map.tag_id AS parent_id,
    (3)::smallint AS entity_type,
    tags_vds_map._create_date AS attach_date,
    NULL::timestamp with time zone AS move_date
   FROM public.tags_vds_map
  WHERE (tags_vds_map._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)))
UNION ALL
 SELECT tags_vm_pool_map.vm_pool_id AS entity_id,
    tags_vm_pool_map.tag_id AS parent_id,
    (5)::smallint AS entity_type,
    tags_vm_pool_map._create_date AS attach_date,
    NULL::timestamp with time zone AS move_date
   FROM public.tags_vm_pool_map
  WHERE (tags_vm_pool_map._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)))
UNION ALL
 SELECT tags_vm_map.vm_id AS entity_id,
    tags_vm_map.tag_id AS parent_id,
    (2)::smallint AS entity_type,
    tags_vm_map._create_date AS attach_date,
    NULL::timestamp with time zone AS move_date
   FROM public.tags_vm_map
  WHERE (tags_vm_map._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)))
UNION ALL
 SELECT tags_user_map.user_id AS entity_id,
    tags_user_map.tag_id AS parent_id,
    (15)::smallint AS entity_type,
    tags_user_map._create_date AS attach_date,
    NULL::timestamp with time zone AS move_date
   FROM public.tags_user_map
  WHERE (tags_user_map._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)))
UNION ALL
 SELECT tags_user_group_map.group_id AS entity_id,
    tags_user_group_map.tag_id AS parent_id,
    (17)::smallint AS entity_type,
    tags_user_group_map._create_date AS attach_date,
    NULL::timestamp with time zone AS move_date
   FROM public.tags_user_group_map
  WHERE (tags_user_group_map._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)));


ALTER TABLE public.dwh_add_tags_relations_history_view OWNER TO engine;

--
-- Name: dwh_cluster_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_cluster_configuration_history_view AS
 SELECT cluster.cluster_id,
    cluster.name AS cluster_name,
    cluster.description AS cluster_description,
    cluster.storage_pool_id AS datacenter_id,
    cluster.cpu_name,
    cluster.count_threads_as_cores,
    cluster.compatibility_version,
    cluster._create_date AS create_date,
    cluster._update_date AS update_date
   FROM public.cluster
  WHERE ((cluster._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (cluster._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_cluster_configuration_history_view OWNER TO engine;

--
-- Name: dwh_datacenter_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_datacenter_configuration_history_view AS
 SELECT storage_pool.id AS datacenter_id,
    storage_pool.name AS datacenter_name,
    storage_pool.description AS datacenter_description,
    storage_pool.is_local AS is_local_storage,
    storage_pool._create_date AS create_date,
    storage_pool._update_date AS update_date
   FROM public.storage_pool
  WHERE ((storage_pool._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (storage_pool._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_datacenter_configuration_history_view OWNER TO engine;

--
-- Name: dwh_datacenter_storage_map_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_datacenter_storage_map_history_view AS
 SELECT DISTINCT storage_pool_iso_map.storage_pool_id AS datacenter_id,
    storage_pool_iso_map.storage_id AS storage_domain_id
   FROM public.storage_pool_iso_map;


ALTER TABLE public.dwh_datacenter_storage_map_history_view OWNER TO engine;

--
-- Name: dwh_host_configuration_full_check_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_host_configuration_full_check_view AS
 SELECT a.vds_id AS host_id,
    a.vds_unique_id AS host_unique_id,
    a.vds_name AS host_name,
    a.cluster_id,
    (a.vds_type)::smallint AS host_type,
    a.host_name AS fqdn_or_ip,
    b.physical_mem_mb AS memory_size_mb,
    (c.swap_total)::integer AS swap_size_mb,
    b.cpu_model,
    (b.cpu_cores)::smallint AS number_of_cores,
    (b.cpu_sockets)::smallint AS number_of_sockets,
    b.cpu_speed_mh,
    b.host_os,
    b.kernel_version,
    b.kvm_version,
    b.libvirt_version,
        CASE substr((b.software_version)::text, 1, 3)
            WHEN '4.4'::text THEN (('2.1'::text || substr((b.software_version)::text, 4, length((b.software_version)::text))))::character varying
            WHEN '4.5'::text THEN (('2.2'::text || substr((b.software_version)::text, 4, length((b.software_version)::text))))::character varying
            WHEN '4.9'::text THEN (('2.3'::text || substr((b.software_version)::text, 4, length((b.software_version)::text))))::character varying
            ELSE b.software_version
        END AS vdsm_version,
    a.port AS vdsm_port,
    (b.cpu_threads)::smallint AS number_of_threads,
    b.hw_manufacturer AS hardware_manufacturer,
    b.hw_product_name AS hardware_product_name,
    b.hw_version AS hardware_version,
    b.hw_serial_number AS hardware_serial_number,
    a._create_date AS create_date,
    a._update_date AS update_date
   FROM ((public.vds_static a
     JOIN public.vds_dynamic b ON ((a.vds_id = b.vds_id)))
     JOIN public.vds_statistics c ON ((c.vds_id = a.vds_id)));


ALTER TABLE public.dwh_host_configuration_full_check_view OWNER TO engine;

--
-- Name: dwh_host_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_host_configuration_history_view AS
 SELECT a.vds_id AS host_id,
    a.vds_unique_id AS host_unique_id,
    a.vds_name AS host_name,
    a.cluster_id,
    (a.vds_type)::smallint AS host_type,
    a.host_name AS fqdn_or_ip,
    b.physical_mem_mb AS memory_size_mb,
    (c.swap_total)::integer AS swap_size_mb,
    b.cpu_model,
    (b.cpu_cores)::smallint AS number_of_cores,
    (b.cpu_sockets)::smallint AS number_of_sockets,
    b.cpu_speed_mh,
    b.host_os,
    b.kernel_version,
    b.kvm_version,
    b.libvirt_version,
    b.software_version AS vdsm_version,
    a.port AS vdsm_port,
    (b.cpu_threads)::smallint AS number_of_threads,
    b.hw_manufacturer AS hardware_manufacturer,
    b.hw_product_name AS hardware_product_name,
    b.hw_version AS hardware_version,
    b.hw_serial_number AS hardware_serial_number,
    a._create_date AS create_date,
    a._update_date AS update_date
   FROM ((public.vds_static a
     JOIN public.vds_dynamic b ON ((a.vds_id = b.vds_id)))
     JOIN public.vds_statistics c ON ((c.vds_id = a.vds_id)))
  WHERE ((a._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (a._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_host_configuration_history_view OWNER TO engine;

--
-- Name: dwh_host_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_host_history_view AS
 SELECT b.vds_id AS host_id,
    (b.status)::smallint AS host_status,
    (c.usage_mem_percent)::smallint AS memory_usage_percent,
    (c.usage_cpu_percent)::smallint AS cpu_usage_percent,
    (c.ksm_cpu_percent)::smallint AS ksm_cpu_percent,
    (c.cpu_load)::integer AS cpu_load,
    (c.cpu_sys)::smallint AS system_cpu_usage_percent,
    (c.cpu_user)::smallint AS user_cpu_usage_percent,
    ((c.swap_total - c.swap_free))::integer AS swap_used_mb,
    (b.vm_active)::smallint AS vm_active,
    (b.vm_count)::smallint AS total_vms,
    b.vms_cores_count AS total_vms_vcpus,
    c.mem_shared AS ksm_shared_memory_mb
   FROM public.vds_dynamic b,
    public.vds_statistics c
  WHERE (b.vds_id = c.vds_id);


ALTER TABLE public.dwh_host_history_view OWNER TO engine;

--
-- Name: dwh_host_interface_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_host_interface_configuration_history_view AS
 SELECT a.id AS host_interface_id,
    a.name AS host_interface_name,
    a.vds_id AS host_id,
    (a.type)::smallint AS host_interface_type,
    a.speed AS host_interface_speed_bps,
    a.mac_addr AS mac_address,
    a.network_name AS logical_network_name,
    a.addr AS ip_address,
    a.gateway,
    a.is_bond AS bond,
    a.bond_name,
    a.vlan_id,
    a._create_date AS create_date,
    a._update_date AS update_date
   FROM public.vds_interface a
  WHERE (((a._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (a._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text)))) AND ((a.is_bond IS NULL) OR (a.is_bond = false) OR ((a.is_bond = true) AND ((a.name)::text IN ( SELECT b.bond_name
           FROM public.vds_interface b
          WHERE ((b.is_bond IS NULL) AND (b.vds_id = a.vds_id)))))));


ALTER TABLE public.dwh_host_interface_configuration_history_view OWNER TO engine;

--
-- Name: dwh_host_interface_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_host_interface_history_view AS
 SELECT vds_interface_statistics.id AS host_interface_id,
    vds_interface_statistics.rx_rate AS receive_rate_percent,
    vds_interface_statistics.tx_rate AS transmit_rate_percent,
    vds_interface_statistics.rx_total AS received_total_byte,
    vds_interface_statistics.tx_total AS transmitted_total_byte,
    vds_interface_statistics.rx_drop AS received_dropped_total_packets,
    vds_interface_statistics.tx_drop AS transmitted_dropped_total_packets
   FROM public.vds_interface_statistics;


ALTER TABLE public.dwh_host_interface_history_view OWNER TO engine;

--
-- Name: dwh_osinfo; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.dwh_osinfo (
    os_id integer NOT NULL,
    os_name character varying(255)
);


ALTER TABLE public.dwh_osinfo OWNER TO engine;

--
-- Name: dwh_remove_tags_relations_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_remove_tags_relations_history_view AS
 SELECT tags.tag_id AS entity_id,
    tags.parent_id
   FROM public.tags
UNION ALL
 SELECT tags_vds_map.vds_id AS entity_id,
    tags_vds_map.tag_id AS parent_id
   FROM public.tags_vds_map
UNION ALL
 SELECT tags_vm_pool_map.vm_pool_id AS entity_id,
    tags_vm_pool_map.tag_id AS parent_id
   FROM public.tags_vm_pool_map
UNION ALL
 SELECT tags_vm_map.vm_id AS entity_id,
    tags_vm_map.tag_id AS parent_id
   FROM public.tags_vm_map
UNION ALL
 SELECT tags_user_map.user_id AS entity_id,
    tags_user_map.tag_id AS parent_id
   FROM public.tags_user_map
UNION ALL
 SELECT tags_user_group_map.group_id AS entity_id,
    tags_user_group_map.tag_id AS parent_id
   FROM public.tags_user_group_map;


ALTER TABLE public.dwh_remove_tags_relations_history_view OWNER TO engine;

--
-- Name: dwh_storage_domain_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_storage_domain_configuration_history_view AS
 SELECT storage_domain_static.id AS storage_domain_id,
    storage_domain_static.storage_name AS storage_domain_name,
    (storage_domain_static.storage_domain_type)::smallint AS storage_domain_type,
    (storage_domain_static.storage_type)::smallint AS storage_type,
    storage_domain_static._create_date AS create_date,
    storage_domain_static._update_date AS update_date
   FROM public.storage_domain_static
  WHERE ((storage_domain_static._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (storage_domain_static._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_storage_domain_configuration_history_view OWNER TO engine;

--
-- Name: dwh_storage_domain_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_storage_domain_history_view AS
 SELECT storage_domain_dynamic.id AS storage_domain_id,
    COALESCE(storage_domain_shared_status.status, 0) AS storage_domain_status,
    storage_domain_dynamic.available_disk_size AS available_disk_size_gb,
    storage_domain_dynamic.used_disk_size AS used_disk_size_gb,
    storage_domain_dynamic.confirmed_available_disk_size AS confirmed_available_disk_size_gb,
    storage_domain_dynamic.vdo_savings
   FROM ((public.storage_domain_dynamic
     JOIN public.storage_domain_static ON ((storage_domain_dynamic.id = storage_domain_static.id)))
     LEFT JOIN public.storage_domain_shared_status ON ((storage_domain_shared_status.storage_id = storage_domain_static.id)));


ALTER TABLE public.dwh_storage_domain_history_view OWNER TO engine;

--
-- Name: dwh_tags_details_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_tags_details_history_view AS
 SELECT tags.tag_id,
    tags.tag_name,
    tags.description AS tag_description,
    tags._create_date AS create_date,
    tags._update_date AS update_date
   FROM public.tags
  WHERE ((tags._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (tags._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_tags_details_history_view OWNER TO engine;

--
-- Name: dwh_users_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_users_history_view AS
 SELECT users.user_id,
    users.name AS first_name,
    users.surname AS last_name,
    users.domain,
    users.username,
    users.department,
    ''::text AS user_role_title,
    users.email,
    users.external_id,
    true AS active,
    users._create_date AS create_date,
    users._update_date AS update_date
   FROM public.users
  WHERE ((users._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (users._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text))));


ALTER TABLE public.dwh_users_history_view OWNER TO engine;

--
-- Name: dwh_vm_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_configuration_history_view AS
 SELECT a.vm_guid AS vm_id,
    a.vm_name,
    a.description AS vm_description,
    (a.vm_type)::smallint AS vm_type,
    a.cluster_id,
    a.vmt_guid AS template_id,
    b.vm_name AS template_name,
    (a.cpu_per_socket)::smallint AS cpu_per_socket,
    (a.num_of_sockets)::smallint AS number_of_sockets,
    a.mem_size_mb AS memory_size_mb,
    (a.os)::smallint AS operating_system,
    f.vds_id AS default_host,
    a.auto_startup AS high_availability,
    a.is_initialized AS initialized,
    a.is_stateless AS stateless,
    false AS fail_back,
    (a.usb_policy)::smallint AS usb_policy,
    a.time_zone,
    c.vm_pool_id,
    d.vm_pool_name,
    e.user_id AS created_by_user_id,
    a._create_date AS create_date,
    a._update_date AS update_date
   FROM (((((public.vm_static a
     JOIN public.vm_static b ON ((a.vmt_guid = b.vm_guid)))
     LEFT JOIN public.vm_pool_map c ON ((a.vm_guid = c.vm_guid)))
     LEFT JOIN public.vm_pools d ON ((c.vm_pool_id = d.vm_pool_id)))
     LEFT JOIN public.users e ON ((a.created_by_user_id = e.user_id)))
     LEFT JOIN ( SELECT DISTINCT ON (vm_host_pinning_map.vm_id) vm_host_pinning_map.vm_id,
            vm_host_pinning_map.vds_id
           FROM public.vm_host_pinning_map
          ORDER BY vm_host_pinning_map.vm_id) f ON ((f.vm_id = a.vm_guid))),
    ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text)) lastsync
  WHERE (((a.entity_type)::text = 'VM'::text) AND ((b.entity_type)::text = 'TEMPLATE'::text) AND (GREATEST(a._create_date, a._update_date, b._update_date) > lastsync.var_datetime));


ALTER TABLE public.dwh_vm_configuration_history_view OWNER TO engine;

--
-- Name: dwh_vm_device_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_device_history_view AS
 SELECT vm_device.device_id,
    vm_device.vm_id,
    vm_device.type,
    vm_device.address,
    vm_device.is_managed,
    vm_device.is_plugged,
    vm_device.is_readonly,
    vm_device._create_date AS create_date,
    vm_device._update_date AS update_date
   FROM public.vm_device
  WHERE (((((vm_device.type)::text = 'disk'::text) AND ((vm_device.device)::text = 'disk'::text)) OR ((vm_device.type)::text = 'interface'::text)) AND ((vm_device._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (vm_device._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text)))));


ALTER TABLE public.dwh_vm_device_history_view OWNER TO engine;

--
-- Name: dwh_vm_disk_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_disk_configuration_history_view AS
SELECT
    NULL::uuid AS vm_disk_id,
    NULL::character varying(255) AS vm_disk_name,
    NULL::character varying(500) AS vm_disk_description,
    NULL::uuid AS storage_domain_id,
    NULL::integer AS vm_disk_size_mb,
    NULL::smallint AS vm_disk_type,
    NULL::smallint AS vm_disk_format,
    NULL::boolean AS is_shared,
    NULL::timestamp with time zone AS create_date,
    NULL::timestamp with time zone AS update_date;


ALTER TABLE public.dwh_vm_disk_configuration_history_view OWNER TO engine;

--
-- Name: dwh_vm_disks_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_disks_history_view AS
 SELECT d.disk_id AS vm_disk_id,
    images.image_guid AS image_id,
    (images.imagestatus)::smallint AS vm_disk_status,
    vm_disk_actual_size.vm_disk_actual_size_mb,
    disk_image_dynamic.read_rate AS read_rate_bytes_per_second,
    disk_image_dynamic.read_ops AS read_ops_total_count,
    disk_image_dynamic.read_latency_seconds,
    disk_image_dynamic.write_rate AS write_rate_bytes_per_second,
    disk_image_dynamic.write_ops AS write_ops_total_count,
    disk_image_dynamic.write_latency_seconds,
    disk_image_dynamic.flush_latency_seconds
   FROM (((((public.images
     JOIN public.disk_image_dynamic ON ((images.image_guid = disk_image_dynamic.image_id)))
     JOIN public.base_disks d ON ((images.image_group_id = d.disk_id)))
     LEFT JOIN public.vm_device ON ((vm_device.device_id = images.image_group_id)))
     LEFT JOIN public.vm_static ON ((vm_static.vm_guid = vm_device.vm_id)))
     LEFT JOIN ( SELECT e.disk_id AS vm_disk_id,
            (sum((disk_image_dynamic_1.actual_size / 1048576)))::integer AS vm_disk_actual_size_mb
           FROM ((((public.images images_b
             JOIN public.disk_image_dynamic disk_image_dynamic_1 ON ((images_b.image_guid = disk_image_dynamic_1.image_id)))
             JOIN public.base_disks e ON ((images_b.image_group_id = e.disk_id)))
             LEFT JOIN public.vm_device vm_device_1 ON ((vm_device_1.device_id = images_b.image_group_id)))
             LEFT JOIN public.vm_static vm_static_1 ON ((vm_static_1.vm_guid = vm_device_1.vm_id)))
          WHERE (((vm_static_1.entity_type)::text = 'VM'::text) OR (vm_static_1.entity_type IS NULL))
          GROUP BY e.disk_id) vm_disk_actual_size ON ((d.disk_id = vm_disk_actual_size.vm_disk_id)))
  WHERE ((images.active = true) AND (((vm_static.entity_type)::text = 'VM'::text) OR (vm_static.entity_type IS NULL)));


ALTER TABLE public.dwh_vm_disks_history_view OWNER TO engine;

--
-- Name: dwh_vm_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_history_view AS
 SELECT c.vm_guid AS vm_id,
    (b.status)::smallint AS vm_status,
    (c.usage_cpu_percent)::smallint AS cpu_usage_percent,
    (c.usage_mem_percent)::smallint AS memory_usage_percent,
    ((c.cpu_sys / ((vm_static.cpu_per_socket * vm_static.num_of_sockets))::numeric))::smallint AS system_cpu_usage_percent,
    ((c.cpu_user / ((vm_static.cpu_per_socket * vm_static.num_of_sockets))::numeric))::smallint AS user_cpu_usage_percent,
    c.disks_usage,
    b.vm_ip,
    b.vm_fqdn,
    b.client_ip AS vm_client_ip,
    b.console_user_id AS current_user_id,
        CASE
            WHEN (b.guest_cur_user_name IS NULL) THEN false
            ELSE true
        END AS user_logged_in_to_guest,
    b.run_on_vds AS currently_running_on_host,
    c.guest_mem_buffered AS memory_buffered_kb,
    c.guest_mem_cached AS memory_cached_kb
   FROM ((public.vm_dynamic b
     LEFT JOIN public.vm_statistics c ON ((c.vm_guid = b.vm_guid)))
     JOIN public.vm_static ON ((c.vm_guid = vm_static.vm_guid)));


ALTER TABLE public.dwh_vm_history_view OWNER TO engine;

--
-- Name: dwh_vm_interface_configuration_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_interface_configuration_history_view AS
 SELECT vm_interface.id AS vm_interface_id,
    vm_interface.name AS vm_interface_name,
    vm_interface.vm_guid AS vm_id,
    (vm_interface.type)::smallint AS vm_interface_type,
    vm_interface.speed AS vm_interface_speed_bps,
    vm_interface.mac_addr AS mac_address,
    network.name AS logical_network_name,
    vm_interface._create_date AS create_date,
    vm_interface._update_date AS update_date
   FROM ((public.vm_interface
     LEFT JOIN (public.vnic_profiles
     JOIN public.network ON ((network.id = vnic_profiles.network_id))) ON ((vnic_profiles.id = vm_interface.vnic_profile_id)))
     JOIN public.vm_static ON ((vm_interface.vm_guid = vm_static.vm_guid)))
  WHERE (((vm_static.entity_type)::text = 'VM'::text) AND ((vm_interface._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (vm_interface._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text)))));


ALTER TABLE public.dwh_vm_interface_configuration_history_view OWNER TO engine;

--
-- Name: dwh_vm_interface_history_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.dwh_vm_interface_history_view AS
 SELECT vm_interface_statistics.id AS vm_interface_id,
    vm_interface_statistics.rx_rate AS receive_rate_percent,
    vm_interface_statistics.tx_rate AS transmit_rate_percent,
    vm_interface_statistics.rx_total AS received_total_byte,
    vm_interface_statistics.tx_total AS transmitted_total_byte,
    vm_interface_statistics.rx_drop AS received_dropped_total_packets,
    vm_interface_statistics.tx_drop AS transmitted_dropped_total_packets
   FROM public.vm_interface_statistics;


ALTER TABLE public.dwh_vm_interface_history_view OWNER TO engine;

--
-- Name: engine_session_user_flat_groups; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.engine_session_user_flat_groups AS
 SELECT engine_sessions.id AS engine_session_seq_id,
    engine_sessions.user_id,
    public.fnsplitteruuid(engine_sessions.group_ids) AS granted_id
   FROM public.engine_sessions
UNION ALL
 SELECT engine_sessions.id AS engine_session_seq_id,
    engine_sessions.user_id,
    engine_sessions.user_id AS granted_id
   FROM public.engine_sessions
UNION ALL
 SELECT engine_sessions.id AS engine_session_seq_id,
    engine_sessions.user_id,
    'eee00000-0000-0000-0000-123456789eee'::uuid AS granted_id
   FROM public.engine_sessions;


ALTER TABLE public.engine_session_user_flat_groups OWNER TO engine;

--
-- Name: event_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.event_map (
    event_up_name character varying(100) NOT NULL,
    event_down_name character varying(100) NOT NULL
);


ALTER TABLE public.event_map OWNER TO engine;

--
-- Name: event_notification_hist; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.event_notification_hist (
    event_name character varying(100) NOT NULL,
    audit_log_id bigint NOT NULL,
    method_type character(10) NOT NULL,
    sent_at timestamp with time zone NOT NULL,
    status boolean NOT NULL,
    reason character(255)
);


ALTER TABLE public.event_notification_hist OWNER TO engine;

--
-- Name: vm_templates_based_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_templates_based_storage_domain AS
 SELECT vm_templates.vm_guid AS vmt_guid,
    vm_templates.vm_name AS name,
    vm_templates.mem_size_mb,
    vm_templates.max_memory_size_mb,
    vm_templates.num_of_io_threads,
    vm_templates.os,
    vm_templates.creation_date,
    vm_templates.child_count,
    vm_templates.num_of_sockets,
    vm_templates.cpu_per_socket,
    vm_templates.threads_per_cpu,
    public.fn_get_num_of_vcpus(vm_templates.*) AS num_of_cpus,
    vm_templates.description,
    vm_templates.free_text_comment,
    vm_templates.cluster_id,
    vm_templates.num_of_monitors,
    vm_templates.allow_console_reconnect,
    vm_templates.template_status AS status,
    vm_templates.usb_policy,
    vm_templates.time_zone,
    cluster.name AS cluster_name,
    vm_templates.vm_type,
    vm_templates.nice_level,
    vm_templates.cpu_shares,
    storage_pool.id AS storage_pool_id,
    storage_pool.name AS storage_pool_name,
    vm_templates.default_boot_sequence,
    vm_templates.default_display_type,
    vm_templates.priority,
    vm_templates.auto_startup,
    vm_templates.lease_sd_id,
    vm_templates.is_stateless,
    vm_templates.iso_path,
    vm_templates.origin,
    vm_templates.initrd_url,
    vm_templates.kernel_url,
    vm_templates.kernel_params,
    image_storage_domain_map.storage_domain_id AS storage_id,
    quota.quota_name,
    vm_templates.is_disabled,
    vm_templates.min_allocated_mem,
    vm_templates.is_run_and_pause,
    vm_templates.created_by_user_id,
    vm_templates.migration_downtime,
    vm_templates.entity_type,
    cluster.architecture,
    vm_templates.template_version_number,
    vm_templates.vmt_guid AS base_template_id,
    vm_templates.template_version_name,
    vm_templates.serial_number_policy,
    vm_templates.custom_serial_number,
    vm_templates.is_boot_menu_enabled,
    vm_templates.is_spice_file_transfer_enabled,
    vm_templates.is_spice_copy_paste_enabled,
    vm_templates.cpu_profile_id,
    vm_templates.host_cpu_flags,
    vm_templates.is_auto_converge,
    vm_templates.is_migrate_compressed,
    vm_templates.is_migrate_encrypted,
    vm_templates.predefined_properties,
    vm_templates.userdefined_properties,
    vm_templates.is_template_sealed,
    vm_templates.console_disconnect_action_delay,
    vm_templates.parallel_migrations
   FROM ((((((public.vm_static vm_templates
     LEFT JOIN public.cluster ON ((vm_templates.cluster_id = cluster.cluster_id)))
     LEFT JOIN public.storage_pool ON ((storage_pool.id = cluster.storage_pool_id)))
     JOIN public.vm_device ON ((vm_device.vm_id = vm_templates.vm_guid)))
     LEFT JOIN public.images ON ((images.image_group_id = vm_device.device_id)))
     LEFT JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images.image_guid)))
     LEFT JOIN public.quota quota ON ((quota.id = vm_templates.quota_id)))
  WHERE (((vm_templates.entity_type)::text = 'TEMPLATE'::text) OR ((vm_templates.entity_type)::text = 'INSTANCE_TYPE'::text) OR ((vm_templates.entity_type)::text = 'IMAGE_TYPE'::text))
UNION
 SELECT vm_templates_1.vm_guid AS vmt_guid,
    vm_templates_1.vm_name AS name,
    vm_templates_1.mem_size_mb,
    vm_templates_1.max_memory_size_mb,
    vm_templates_1.num_of_io_threads,
    vm_templates_1.os,
    vm_templates_1.creation_date,
    vm_templates_1.child_count,
    vm_templates_1.num_of_sockets,
    vm_templates_1.cpu_per_socket,
    vm_templates_1.threads_per_cpu,
    public.fn_get_num_of_vcpus(vm_templates_1.*) AS num_of_cpus,
    vm_templates_1.description,
    vm_templates_1.free_text_comment,
    vm_templates_1.cluster_id,
    vm_templates_1.num_of_monitors,
    vm_templates_1.allow_console_reconnect,
    vm_templates_1.template_status AS status,
    vm_templates_1.usb_policy,
    vm_templates_1.time_zone,
    cluster_1.name AS cluster_name,
    vm_templates_1.vm_type,
    vm_templates_1.nice_level,
    vm_templates_1.cpu_shares,
    storage_pool_1.id AS storage_pool_id,
    storage_pool_1.name AS storage_pool_name,
    vm_templates_1.default_boot_sequence,
    vm_templates_1.default_display_type,
    vm_templates_1.priority,
    vm_templates_1.auto_startup,
    vm_templates_1.lease_sd_id,
    vm_templates_1.is_stateless,
    vm_templates_1.iso_path,
    vm_templates_1.origin,
    vm_templates_1.initrd_url,
    vm_templates_1.kernel_url,
    vm_templates_1.kernel_params,
    image_storage_domain_map.storage_domain_id AS storage_id,
    quota.quota_name,
    vm_templates_1.is_disabled,
    vm_templates_1.min_allocated_mem,
    vm_templates_1.is_run_and_pause,
    vm_templates_1.created_by_user_id,
    vm_templates_1.migration_downtime,
    vm_templates_1.entity_type,
    cluster_1.architecture,
    vm_templates_1.template_version_number,
    vm_templates_1.vmt_guid AS base_template_id,
    vm_templates_1.template_version_name,
    vm_templates_1.serial_number_policy,
    vm_templates_1.custom_serial_number,
    vm_templates_1.is_boot_menu_enabled,
    vm_templates_1.is_spice_file_transfer_enabled,
    vm_templates_1.is_spice_copy_paste_enabled,
    vm_templates_1.cpu_profile_id,
    vm_templates_1.host_cpu_flags,
    vm_templates_1.is_auto_converge,
    vm_templates_1.is_migrate_compressed,
    vm_templates_1.is_migrate_encrypted,
    vm_templates_1.predefined_properties,
    vm_templates_1.userdefined_properties,
    vm_templates_1.is_template_sealed,
    vm_templates_1.console_disconnect_action_delay,
    vm_templates_1.parallel_migrations
   FROM ((((((public.vm_static vm_templates_1
     LEFT JOIN public.cluster cluster_1 ON ((vm_templates_1.cluster_id = cluster_1.cluster_id)))
     LEFT JOIN public.storage_pool storage_pool_1 ON ((storage_pool_1.id = cluster_1.storage_pool_id)))
     JOIN public.vm_device vm_device_1 ON ((vm_device_1.vm_id = vm_templates_1.vm_guid)))
     JOIN public.images images_1 ON ((images_1.image_group_id = vm_device_1.device_id)))
     JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images_1.image_guid)))
     LEFT JOIN public.quota quota ON ((quota.id = vm_templates_1.quota_id)))
  WHERE (((vm_templates_1.entity_type)::text = 'TEMPLATE'::text) OR ((vm_templates_1.entity_type)::text = 'INSTANCE_TYPE'::text) OR ((vm_templates_1.entity_type)::text = 'IMAGE_TYPE'::text));


ALTER TABLE public.vm_templates_based_storage_domain OWNER TO engine;

--
-- Name: image_types_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.image_types_storage_domain AS
 SELECT vm_templates_based_storage_domain.vmt_guid,
    vm_templates_based_storage_domain.name,
    vm_templates_based_storage_domain.mem_size_mb,
    vm_templates_based_storage_domain.max_memory_size_mb,
    vm_templates_based_storage_domain.num_of_io_threads,
    vm_templates_based_storage_domain.os,
    vm_templates_based_storage_domain.creation_date,
    vm_templates_based_storage_domain.child_count,
    vm_templates_based_storage_domain.num_of_sockets,
    vm_templates_based_storage_domain.cpu_per_socket,
    vm_templates_based_storage_domain.threads_per_cpu,
    vm_templates_based_storage_domain.num_of_cpus,
    vm_templates_based_storage_domain.description,
    vm_templates_based_storage_domain.free_text_comment,
    vm_templates_based_storage_domain.cluster_id,
    vm_templates_based_storage_domain.num_of_monitors,
    vm_templates_based_storage_domain.allow_console_reconnect,
    vm_templates_based_storage_domain.status,
    vm_templates_based_storage_domain.usb_policy,
    vm_templates_based_storage_domain.time_zone,
    vm_templates_based_storage_domain.cluster_name,
    vm_templates_based_storage_domain.vm_type,
    vm_templates_based_storage_domain.nice_level,
    vm_templates_based_storage_domain.cpu_shares,
    vm_templates_based_storage_domain.storage_pool_id,
    vm_templates_based_storage_domain.storage_pool_name,
    vm_templates_based_storage_domain.default_boot_sequence,
    vm_templates_based_storage_domain.default_display_type,
    vm_templates_based_storage_domain.priority,
    vm_templates_based_storage_domain.auto_startup,
    vm_templates_based_storage_domain.lease_sd_id,
    vm_templates_based_storage_domain.is_stateless,
    vm_templates_based_storage_domain.iso_path,
    vm_templates_based_storage_domain.origin,
    vm_templates_based_storage_domain.initrd_url,
    vm_templates_based_storage_domain.kernel_url,
    vm_templates_based_storage_domain.kernel_params,
    vm_templates_based_storage_domain.storage_id,
    vm_templates_based_storage_domain.quota_name,
    vm_templates_based_storage_domain.is_disabled,
    vm_templates_based_storage_domain.min_allocated_mem,
    vm_templates_based_storage_domain.is_run_and_pause,
    vm_templates_based_storage_domain.created_by_user_id,
    vm_templates_based_storage_domain.migration_downtime,
    vm_templates_based_storage_domain.entity_type,
    vm_templates_based_storage_domain.architecture,
    vm_templates_based_storage_domain.template_version_number,
    vm_templates_based_storage_domain.base_template_id,
    vm_templates_based_storage_domain.template_version_name,
    vm_templates_based_storage_domain.serial_number_policy,
    vm_templates_based_storage_domain.custom_serial_number,
    vm_templates_based_storage_domain.is_boot_menu_enabled,
    vm_templates_based_storage_domain.is_spice_file_transfer_enabled,
    vm_templates_based_storage_domain.is_spice_copy_paste_enabled,
    vm_templates_based_storage_domain.cpu_profile_id,
    vm_templates_based_storage_domain.host_cpu_flags,
    vm_templates_based_storage_domain.is_auto_converge,
    vm_templates_based_storage_domain.is_migrate_compressed,
    vm_templates_based_storage_domain.is_migrate_encrypted,
    vm_templates_based_storage_domain.predefined_properties,
    vm_templates_based_storage_domain.userdefined_properties,
    vm_templates_based_storage_domain.is_template_sealed,
    vm_templates_based_storage_domain.console_disconnect_action_delay,
    vm_templates_based_storage_domain.parallel_migrations
   FROM public.vm_templates_based_storage_domain
  WHERE ((vm_templates_based_storage_domain.entity_type)::text = 'IMAGE_TYPE'::text);


ALTER TABLE public.image_types_storage_domain OWNER TO engine;

--
-- Name: image_types_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.image_types_view AS
 SELECT vm_templates_based_view.vmt_guid,
    vm_templates_based_view.name,
    vm_templates_based_view.mem_size_mb,
    vm_templates_based_view.max_memory_size_mb,
    vm_templates_based_view.num_of_io_threads,
    vm_templates_based_view.os,
    vm_templates_based_view.creation_date,
    vm_templates_based_view.child_count,
    vm_templates_based_view.num_of_sockets,
    vm_templates_based_view.cpu_per_socket,
    vm_templates_based_view.threads_per_cpu,
    vm_templates_based_view.num_of_cpus,
    vm_templates_based_view.description,
    vm_templates_based_view.free_text_comment,
    vm_templates_based_view.cluster_id,
    vm_templates_based_view.num_of_monitors,
    vm_templates_based_view.allow_console_reconnect,
    vm_templates_based_view.status,
    vm_templates_based_view.usb_policy,
    vm_templates_based_view.time_zone,
    vm_templates_based_view.cluster_name,
    vm_templates_based_view.cluster_compatibility_version,
    vm_templates_based_view.trusted_service,
    vm_templates_based_view.cluster_bios_type,
    vm_templates_based_view.vm_type,
    vm_templates_based_view.nice_level,
    vm_templates_based_view.cpu_shares,
    vm_templates_based_view.storage_pool_id,
    vm_templates_based_view.storage_pool_name,
    vm_templates_based_view.quota_enforcement_type,
    vm_templates_based_view.default_boot_sequence,
    vm_templates_based_view.default_display_type,
    vm_templates_based_view.priority,
    vm_templates_based_view.auto_startup,
    vm_templates_based_view.lease_sd_id,
    vm_templates_based_view.is_stateless,
    vm_templates_based_view.is_smartcard_enabled,
    vm_templates_based_view.is_delete_protected,
    vm_templates_based_view.sso_method,
    vm_templates_based_view.iso_path,
    vm_templates_based_view.origin,
    vm_templates_based_view.initrd_url,
    vm_templates_based_view.kernel_url,
    vm_templates_based_view.kernel_params,
    vm_templates_based_view.quota_id,
    vm_templates_based_view.quota_name,
    vm_templates_based_view.db_generation,
    vm_templates_based_view.host_cpu_flags,
    vm_templates_based_view.migration_support,
    vm_templates_based_view.dedicated_vm_for_vds,
    vm_templates_based_view.is_disabled,
    vm_templates_based_view.tunnel_migration,
    vm_templates_based_view.vnc_keyboard_layout,
    vm_templates_based_view.min_allocated_mem,
    vm_templates_based_view.is_run_and_pause,
    vm_templates_based_view.created_by_user_id,
    vm_templates_based_view.entity_type,
    vm_templates_based_view.migration_downtime,
    vm_templates_based_view.architecture,
    vm_templates_based_view.template_version_number,
    vm_templates_based_view.base_template_id,
    vm_templates_based_view.template_version_name,
    vm_templates_based_view.serial_number_policy,
    vm_templates_based_view.custom_serial_number,
    vm_templates_based_view.is_boot_menu_enabled,
    vm_templates_based_view.is_spice_file_transfer_enabled,
    vm_templates_based_view.is_spice_copy_paste_enabled,
    vm_templates_based_view.cpu_profile_id,
    vm_templates_based_view.is_auto_converge,
    vm_templates_based_view.is_migrate_compressed,
    vm_templates_based_view.is_migrate_encrypted,
    vm_templates_based_view.predefined_properties,
    vm_templates_based_view.userdefined_properties,
    vm_templates_based_view.custom_emulated_machine,
    vm_templates_based_view.bios_type,
    vm_templates_based_view.custom_cpu_name,
    vm_templates_based_view.small_icon_id,
    vm_templates_based_view.large_icon_id,
    vm_templates_based_view.migration_policy_id,
    vm_templates_based_view.console_disconnect_action,
    vm_templates_based_view.resume_behavior,
    vm_templates_based_view.custom_compatibility_version,
    vm_templates_based_view.multi_queues_enabled,
    vm_templates_based_view.virtio_scsi_multi_queues,
    vm_templates_based_view.use_tsc_frequency,
    vm_templates_based_view.is_template_sealed,
    vm_templates_based_view.cpu_pinning,
    vm_templates_based_view.balloon_enabled,
    vm_templates_based_view.console_disconnect_action_delay,
    vm_templates_based_view.cpu_pinning_policy,
    vm_templates_based_view.parallel_migrations
   FROM public.vm_templates_based_view
  WHERE ((vm_templates_based_view.entity_type)::text = 'IMAGE_TYPE'::text);


ALTER TABLE public.image_types_view OWNER TO engine;

--
-- Name: instance_types_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.instance_types_storage_domain AS
 SELECT vm_templates_based_storage_domain.vmt_guid,
    vm_templates_based_storage_domain.name,
    vm_templates_based_storage_domain.mem_size_mb,
    vm_templates_based_storage_domain.max_memory_size_mb,
    vm_templates_based_storage_domain.num_of_io_threads,
    vm_templates_based_storage_domain.os,
    vm_templates_based_storage_domain.creation_date,
    vm_templates_based_storage_domain.child_count,
    vm_templates_based_storage_domain.num_of_sockets,
    vm_templates_based_storage_domain.cpu_per_socket,
    vm_templates_based_storage_domain.threads_per_cpu,
    vm_templates_based_storage_domain.num_of_cpus,
    vm_templates_based_storage_domain.description,
    vm_templates_based_storage_domain.free_text_comment,
    vm_templates_based_storage_domain.cluster_id,
    vm_templates_based_storage_domain.num_of_monitors,
    vm_templates_based_storage_domain.allow_console_reconnect,
    vm_templates_based_storage_domain.status,
    vm_templates_based_storage_domain.usb_policy,
    vm_templates_based_storage_domain.time_zone,
    vm_templates_based_storage_domain.cluster_name,
    vm_templates_based_storage_domain.vm_type,
    vm_templates_based_storage_domain.nice_level,
    vm_templates_based_storage_domain.cpu_shares,
    vm_templates_based_storage_domain.storage_pool_id,
    vm_templates_based_storage_domain.storage_pool_name,
    vm_templates_based_storage_domain.default_boot_sequence,
    vm_templates_based_storage_domain.default_display_type,
    vm_templates_based_storage_domain.priority,
    vm_templates_based_storage_domain.auto_startup,
    vm_templates_based_storage_domain.lease_sd_id,
    vm_templates_based_storage_domain.is_stateless,
    vm_templates_based_storage_domain.iso_path,
    vm_templates_based_storage_domain.origin,
    vm_templates_based_storage_domain.initrd_url,
    vm_templates_based_storage_domain.kernel_url,
    vm_templates_based_storage_domain.kernel_params,
    vm_templates_based_storage_domain.storage_id,
    vm_templates_based_storage_domain.quota_name,
    vm_templates_based_storage_domain.is_disabled,
    vm_templates_based_storage_domain.min_allocated_mem,
    vm_templates_based_storage_domain.is_run_and_pause,
    vm_templates_based_storage_domain.created_by_user_id,
    vm_templates_based_storage_domain.migration_downtime,
    vm_templates_based_storage_domain.entity_type,
    vm_templates_based_storage_domain.architecture,
    vm_templates_based_storage_domain.template_version_number,
    vm_templates_based_storage_domain.base_template_id,
    vm_templates_based_storage_domain.template_version_name,
    vm_templates_based_storage_domain.serial_number_policy,
    vm_templates_based_storage_domain.custom_serial_number,
    vm_templates_based_storage_domain.is_boot_menu_enabled,
    vm_templates_based_storage_domain.is_spice_file_transfer_enabled,
    vm_templates_based_storage_domain.is_spice_copy_paste_enabled,
    vm_templates_based_storage_domain.cpu_profile_id,
    vm_templates_based_storage_domain.host_cpu_flags,
    vm_templates_based_storage_domain.is_auto_converge,
    vm_templates_based_storage_domain.is_migrate_compressed,
    vm_templates_based_storage_domain.is_migrate_encrypted,
    vm_templates_based_storage_domain.predefined_properties,
    vm_templates_based_storage_domain.userdefined_properties,
    vm_templates_based_storage_domain.is_template_sealed,
    vm_templates_based_storage_domain.console_disconnect_action_delay,
    vm_templates_based_storage_domain.parallel_migrations
   FROM public.vm_templates_based_storage_domain
  WHERE ((vm_templates_based_storage_domain.entity_type)::text = 'INSTANCE_TYPE'::text);


ALTER TABLE public.instance_types_storage_domain OWNER TO engine;

--
-- Name: instance_types_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.instance_types_view AS
 SELECT vm_templates_based_view.vmt_guid,
    vm_templates_based_view.name,
    vm_templates_based_view.mem_size_mb,
    vm_templates_based_view.max_memory_size_mb,
    vm_templates_based_view.num_of_io_threads,
    vm_templates_based_view.os,
    vm_templates_based_view.creation_date,
    vm_templates_based_view.child_count,
    vm_templates_based_view.num_of_sockets,
    vm_templates_based_view.cpu_per_socket,
    vm_templates_based_view.threads_per_cpu,
    vm_templates_based_view.num_of_cpus,
    vm_templates_based_view.description,
    vm_templates_based_view.free_text_comment,
    vm_templates_based_view.cluster_id,
    vm_templates_based_view.num_of_monitors,
    vm_templates_based_view.allow_console_reconnect,
    vm_templates_based_view.status,
    vm_templates_based_view.usb_policy,
    vm_templates_based_view.time_zone,
    vm_templates_based_view.cluster_name,
    vm_templates_based_view.cluster_compatibility_version,
    vm_templates_based_view.trusted_service,
    vm_templates_based_view.cluster_bios_type,
    vm_templates_based_view.vm_type,
    vm_templates_based_view.nice_level,
    vm_templates_based_view.cpu_shares,
    vm_templates_based_view.storage_pool_id,
    vm_templates_based_view.storage_pool_name,
    vm_templates_based_view.quota_enforcement_type,
    vm_templates_based_view.default_boot_sequence,
    vm_templates_based_view.default_display_type,
    vm_templates_based_view.priority,
    vm_templates_based_view.auto_startup,
    vm_templates_based_view.lease_sd_id,
    vm_templates_based_view.is_stateless,
    vm_templates_based_view.is_smartcard_enabled,
    vm_templates_based_view.is_delete_protected,
    vm_templates_based_view.sso_method,
    vm_templates_based_view.iso_path,
    vm_templates_based_view.origin,
    vm_templates_based_view.initrd_url,
    vm_templates_based_view.kernel_url,
    vm_templates_based_view.kernel_params,
    vm_templates_based_view.quota_id,
    vm_templates_based_view.quota_name,
    vm_templates_based_view.db_generation,
    vm_templates_based_view.host_cpu_flags,
    vm_templates_based_view.migration_support,
    vm_templates_based_view.dedicated_vm_for_vds,
    vm_templates_based_view.is_disabled,
    vm_templates_based_view.tunnel_migration,
    vm_templates_based_view.vnc_keyboard_layout,
    vm_templates_based_view.min_allocated_mem,
    vm_templates_based_view.is_run_and_pause,
    vm_templates_based_view.created_by_user_id,
    vm_templates_based_view.entity_type,
    vm_templates_based_view.migration_downtime,
    vm_templates_based_view.architecture,
    vm_templates_based_view.template_version_number,
    vm_templates_based_view.base_template_id,
    vm_templates_based_view.template_version_name,
    vm_templates_based_view.serial_number_policy,
    vm_templates_based_view.custom_serial_number,
    vm_templates_based_view.is_boot_menu_enabled,
    vm_templates_based_view.is_spice_file_transfer_enabled,
    vm_templates_based_view.is_spice_copy_paste_enabled,
    vm_templates_based_view.cpu_profile_id,
    vm_templates_based_view.is_auto_converge,
    vm_templates_based_view.is_migrate_compressed,
    vm_templates_based_view.is_migrate_encrypted,
    vm_templates_based_view.predefined_properties,
    vm_templates_based_view.userdefined_properties,
    vm_templates_based_view.custom_emulated_machine,
    vm_templates_based_view.bios_type,
    vm_templates_based_view.custom_cpu_name,
    vm_templates_based_view.small_icon_id,
    vm_templates_based_view.large_icon_id,
    vm_templates_based_view.migration_policy_id,
    vm_templates_based_view.console_disconnect_action,
    vm_templates_based_view.resume_behavior,
    vm_templates_based_view.custom_compatibility_version,
    vm_templates_based_view.multi_queues_enabled,
    vm_templates_based_view.virtio_scsi_multi_queues,
    vm_templates_based_view.use_tsc_frequency,
    vm_templates_based_view.is_template_sealed,
    vm_templates_based_view.cpu_pinning,
    vm_templates_based_view.balloon_enabled,
    vm_templates_based_view.console_disconnect_action_delay,
    vm_templates_based_view.cpu_pinning_policy,
    vm_templates_based_view.parallel_migrations
   FROM public.vm_templates_based_view
  WHERE ((vm_templates_based_view.entity_type)::text = 'INSTANCE_TYPE'::text);


ALTER TABLE public.instance_types_view OWNER TO engine;

--
-- Name: internal_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.internal_permissions_view AS
 SELECT permissions.id,
    permissions.role_id,
    permissions.ad_element_id,
    permissions.object_id,
    permissions.object_type_id,
    roles.name AS role_name,
    roles.role_type,
    roles.allows_viewing_children
   FROM (public.permissions
     JOIN public.roles ON ((permissions.role_id = roles.id)));


ALTER TABLE public.internal_permissions_view OWNER TO engine;

--
-- Name: iscsi_bonds_networks_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.iscsi_bonds_networks_map (
    iscsi_bond_id uuid NOT NULL,
    network_id uuid NOT NULL
);


ALTER TABLE public.iscsi_bonds_networks_map OWNER TO engine;

--
-- Name: iscsi_bonds_storage_connections_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.iscsi_bonds_storage_connections_map (
    iscsi_bond_id uuid NOT NULL,
    connection_id character varying(50) NOT NULL
);


ALTER TABLE public.iscsi_bonds_storage_connections_map OWNER TO engine;

--
-- Name: iso_disks_as_repo_images; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.iso_disks_as_repo_images AS
 SELECT sds.id AS repo_domain_id,
    (bd.disk_id)::character varying(256) AS repo_image_id,
    img.size,
    img.creation_date AS date_created,
    ((date_part('epoch'::text, CURRENT_TIMESTAMP) * (1000)::double precision))::bigint AS last_refreshed,
    1 AS file_type,
    (bd.disk_alias)::character varying(256) AS repo_image_name,
    spim.storage_pool_id,
    spim.status
   FROM ((((public.base_disks bd
     JOIN public.images img ON ((bd.disk_id = img.image_group_id)))
     JOIN public.image_storage_domain_map isdm ON ((isdm.image_id = img.image_guid)))
     JOIN public.storage_domain_static sds ON ((sds.id = isdm.storage_domain_id)))
     JOIN public.storage_pool_iso_map spim ON ((spim.storage_id = sds.id)))
  WHERE (bd.disk_content_type = 4);


ALTER TABLE public.iso_disks_as_repo_images OWNER TO engine;

--
-- Name: network_cluster_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.network_cluster_view AS
 SELECT network_cluster.cluster_id,
    network_cluster.network_id,
    network.name AS network_name,
    network_cluster.status,
    network_cluster.required,
    network_cluster.is_display,
    network_cluster.migration,
    cluster.name AS cluster_name
   FROM ((public.network_cluster
     JOIN public.network ON ((network_cluster.network_id = network.id)))
     JOIN public.cluster ON ((network_cluster.cluster_id = cluster.cluster_id)));


ALTER TABLE public.network_cluster_view OWNER TO engine;

--
-- Name: network_vds_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.network_vds_view AS
 SELECT network.id AS network_id,
    network.name AS network_name,
    vds_static.vds_name
   FROM (((public.vds_interface
     JOIN public.vds_static ON ((vds_interface.vds_id = vds_static.vds_id)))
     JOIN public.network ON (((vds_interface.network_name)::text = (network.name)::text)))
     JOIN public.network_cluster ON ((network_cluster.network_id = network.id)))
  WHERE (network_cluster.cluster_id = vds_static.cluster_id);


ALTER TABLE public.network_vds_view OWNER TO engine;

--
-- Name: object_column_white_list; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.object_column_white_list (
    object_name character varying(128) NOT NULL,
    column_name character varying(128) NOT NULL
);


ALTER TABLE public.object_column_white_list OWNER TO engine;

--
-- Name: object_column_white_list_sql; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.object_column_white_list_sql (
    object_name character varying(128) NOT NULL,
    sql text NOT NULL
);


ALTER TABLE public.object_column_white_list_sql OWNER TO engine;

--
-- Name: provider_binding_host_id; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.provider_binding_host_id (
    vds_id uuid NOT NULL,
    plugin_type character varying(64) NOT NULL,
    binding_host_id character varying(64)
);


ALTER TABLE public.provider_binding_host_id OWNER TO engine;

--
-- Name: quota_limitations_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.quota_limitations_view AS
 SELECT q_limit.quota_id,
    q.storage_pool_id,
    storage_pool.name AS storage_pool_name,
    q.quota_name,
    q.description,
    q.threshold_cluster_percentage,
    q.threshold_storage_percentage,
    q.grace_cluster_percentage,
    q.grace_storage_percentage,
    q_limit.virtual_cpu,
    q_limit.mem_size_mb,
    q_limit.storage_size_gb,
    storage_pool.quota_enforcement_type,
    q.is_default,
    q_limit.cluster_id,
    q_limit.storage_id,
    (COALESCE(q_limit.cluster_id, q_limit.storage_id) IS NULL) AS is_global,
    (COALESCE((q_limit.virtual_cpu)::bigint, q_limit.mem_size_mb, q_limit.storage_size_gb) IS NULL) AS is_empty
   FROM ((public.quota q
     JOIN public.storage_pool ON ((storage_pool.id = q.storage_pool_id)))
     LEFT JOIN public.quota_limitation q_limit ON ((q_limit.quota_id = q.id)));


ALTER TABLE public.quota_limitations_view OWNER TO engine;

--
-- Name: schema_version_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.schema_version_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.schema_version_seq OWNER TO engine;

--
-- Name: schema_version; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.schema_version (
    id integer DEFAULT nextval('public.schema_version_seq'::regclass) NOT NULL,
    version character varying(10) NOT NULL,
    script character varying(255) NOT NULL,
    checksum character varying(128),
    installed_by character varying(63) NOT NULL,
    started_at timestamp without time zone DEFAULT now(),
    ended_at timestamp without time zone,
    state character varying(15) NOT NULL,
    current boolean NOT NULL,
    comment text DEFAULT ''::text
);


ALTER TABLE public.schema_version OWNER TO engine;

--
-- Name: server_vms; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.server_vms AS
 SELECT vms.vm_name,
    vms.mem_size_mb,
    vms.max_memory_size_mb,
    vms.num_of_io_threads,
    vms.nice_level,
    vms.cpu_shares,
    vms.vmt_guid,
    vms.os,
    vms.description,
    vms.free_text_comment,
    vms.cluster_id,
    vms.creation_date,
    vms.auto_startup,
    vms.lease_sd_id,
    vms.lease_info,
    vms.is_stateless,
    vms.is_smartcard_enabled,
    vms.is_delete_protected,
    vms.sso_method,
    vms.dedicated_vm_for_vds,
    vms.default_boot_sequence,
    vms.vm_type,
    vms.vm_pool_spice_proxy,
    vms.cluster_name,
    vms.transparent_hugepages,
    vms.trusted_service,
    vms.storage_pool_id,
    vms.storage_pool_name,
    vms.cluster_spice_proxy,
    vms.vmt_name,
    vms.status,
    vms.vm_ip,
    vms.vm_ip_inet_array,
    vms.vm_host,
    vms.last_start_time,
    vms.boot_time,
    vms.downtime,
    vms.guest_cur_user_name,
    vms.console_cur_user_name,
    vms.runtime_name,
    vms.guest_os,
    vms.console_user_id,
    vms.guest_agent_nics_hash,
    vms.run_on_vds,
    vms.migrating_to_vds,
    vms.app_list,
    vms.vm_pool_name,
    vms.vm_pool_id,
    vms.vm_guid,
    vms.num_of_monitors,
    vms.allow_console_reconnect,
    vms.is_initialized,
    vms.num_of_sockets,
    vms.cpu_per_socket,
    vms.threads_per_cpu,
    vms.usb_policy,
    vms.acpi_enable,
    vms.session,
    vms.num_of_cpus,
    vms.quota_id,
    vms.quota_name,
    vms.quota_enforcement_type,
    vms.boot_sequence,
    vms.utc_diff,
    vms.client_ip,
    vms.guest_requested_memory,
    vms.time_zone,
    vms.cpu_user,
    vms.cpu_sys,
    vms.elapsed_time,
    vms.usage_network_percent,
    vms.disks_usage,
    vms.usage_mem_percent,
    vms.usage_cpu_percent,
    vms.run_on_vds_name,
    vms.cluster_cpu_name,
    vms.cluster_cpu_flags,
    vms.cluster_cpu_verb,
    vms.default_display_type,
    vms.priority,
    vms.iso_path,
    vms.origin,
    vms.cluster_compatibility_version,
    vms.initrd_url,
    vms.kernel_url,
    vms.kernel_params,
    vms.pause_status,
    vms.exit_message,
    vms.exit_status,
    vms.migration_support,
    vms.predefined_properties,
    vms.userdefined_properties,
    vms.min_allocated_mem,
    vms.hash,
    vms.cpu_pinning,
    vms.db_generation,
    vms.host_cpu_flags,
    vms.tunnel_migration,
    vms.vnc_keyboard_layout,
    vms.is_run_and_pause,
    vms.created_by_user_id,
    vms.last_watchdog_event,
    vms.last_watchdog_action,
    vms.is_run_once,
    vms.volatile_run,
    vms.vm_fqdn,
    vms.cpu_name,
    vms.emulated_machine,
    vms.current_cd,
    vms.reason,
    vms.exit_reason,
    vms.instance_type_id,
    vms.image_type_id,
    vms.architecture,
    vms.original_template_id,
    vms.original_template_name,
    vms.last_stop_time,
    vms.migration_downtime,
    vms.template_version_number,
    vms.serial_number_policy,
    vms.custom_serial_number,
    vms.is_boot_menu_enabled,
    vms.guest_cpu_count,
    vms.next_run_config_exists,
    vms.is_previewing_snapshot,
    vms.changed_fields,
    vms.is_spice_file_transfer_enabled,
    vms.is_spice_copy_paste_enabled,
    vms.cpu_profile_id,
    vms.is_auto_converge,
    vms.is_migrate_compressed,
    vms.is_migrate_encrypted,
    vms.custom_emulated_machine,
    vms.bios_type,
    vms.cluster_bios_type,
    vms.custom_cpu_name,
    vms.spice_port,
    vms.spice_tls_port,
    vms.spice_ip,
    vms.vnc_port,
    vms.vnc_ip,
    vms.ovirt_guest_agent_status,
    vms.qemu_guest_agent_status,
    vms.guest_mem_buffered,
    vms.guest_mem_cached,
    vms.small_icon_id,
    vms.large_icon_id,
    vms.migration_policy_id,
    vms.provider_id,
    vms.console_disconnect_action,
    vms.resume_behavior,
    vms.guest_timezone_offset,
    vms.guest_timezone_name,
    vms.guestos_arch,
    vms.guestos_codename,
    vms.guestos_distribution,
    vms.guestos_kernel_version,
    vms.guestos_type,
    vms.guestos_version,
    vms.custom_compatibility_version,
    vms.guest_containers,
    vms.has_illegal_images,
    vms.multi_queues_enabled,
    vms.virtio_scsi_multi_queues,
    vms.use_tsc_frequency,
    vms.namespace,
    vms.balloon_enabled,
    vms.console_disconnect_action_delay,
    vms.cpu_pinning_policy,
    vms.current_cpu_pinning,
    vms.current_sockets,
    vms.current_cores,
    vms.current_threads,
    vms.current_numa_pinning,
    vms.parallel_migrations
   FROM public.vms
  WHERE (vms.vm_type = 1);


ALTER TABLE public.server_vms OWNER TO engine;

--
-- Name: sso_scope_dependency_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.sso_scope_dependency_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sso_scope_dependency_seq OWNER TO engine;

--
-- Name: sso_scope_dependency; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.sso_scope_dependency (
    id bigint DEFAULT nextval('public.sso_scope_dependency_seq'::regclass) NOT NULL,
    scope character varying(128) NOT NULL,
    dependencies text
);


ALTER TABLE public.sso_scope_dependency OWNER TO engine;

--
-- Name: storage_domain_file_repos; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domain_file_repos AS
 SELECT storage_domain_static.id AS storage_domain_id,
    storage_domain_static.storage_domain_type,
    storage_pool_iso_map.storage_pool_id,
    storage_pool_iso_map.status AS storage_domain_status,
    repo_file_meta_data.repo_image_id,
    repo_file_meta_data.size,
    repo_file_meta_data.date_created,
    repo_file_meta_data.last_refreshed,
    repo_file_meta_data.file_type,
    vds_dynamic.status AS vds_status,
    storage_pool.status AS storage_pool_status
   FROM ((((public.storage_domain_static
     JOIN public.storage_pool_iso_map ON ((storage_domain_static.id = storage_pool_iso_map.storage_id)))
     JOIN public.storage_pool ON ((storage_pool.id = storage_pool_iso_map.storage_pool_id)))
     JOIN public.vds_dynamic ON ((vds_dynamic.vds_id = storage_pool.spm_vds_id)))
     LEFT JOIN public.repo_file_meta_data ON ((storage_pool_iso_map.storage_id = repo_file_meta_data.repo_domain_id)));


ALTER TABLE public.storage_domain_file_repos OWNER TO engine;

--
-- Name: storage_domains_for_search; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domains_for_search AS
 SELECT storage_domain_static.id,
    storage_domain_static.storage,
    storage_domain_static.storage_name,
    storage_domain_static.storage_description,
    storage_domain_static.storage_comment,
    storage_domain_static.storage_type,
    storage_domain_static.storage_domain_type,
    storage_domain_static.storage_domain_format_type,
    storage_domain_static.last_time_used_as_master,
    storage_domain_static.wipe_after_delete,
    storage_domain_static.discard_after_delete,
    storage_domain_static.first_metadata_device,
    storage_domain_static.vg_metadata_device,
    storage_domain_static.backup,
        CASE
            WHEN status_table.is_multi_domain THEN NULL::integer
            WHEN (status_table.status IS NULL) THEN 2
            ELSE status_table.status
        END AS status,
    storage_domain_static.block_size,
    status_table.storage_pool_ids[1] AS storage_pool_id,
    status_table.pool_names AS storage_pool_name,
    storage_domain_dynamic.available_disk_size,
    storage_domain_dynamic.confirmed_available_disk_size,
    storage_domain_dynamic.vdo_savings,
    storage_domain_dynamic.used_disk_size,
    (storage_domain_dynamic.available_disk_size + storage_domain_dynamic.used_disk_size) AS total_disk_size,
    storage_domains_image_sizes.commited_disk_size,
    storage_domains_image_sizes.actual_images_size,
    COALESCE(storage_domain_shared_status.status, 0) AS storage_domain_shared_status,
    storage_domain_static.recoverable,
    (domains_with_unregistered_entities_view.storage_domain_id IS NOT NULL) AS contains_unregistered_entities,
    storage_domain_static.warning_low_space_indicator,
    storage_domain_static.critical_space_action_blocker,
    storage_domain_static.warning_low_confirmed_space_indicator,
    storage_domain_dynamic.external_status,
    vg_discard_support_view.supports_discard,
    (EXISTS ( SELECT 1
           FROM public.hosted_engine_storage_domains_ids_view
          WHERE (hosted_engine_storage_domains_ids_view.id = storage_domain_static.id))) AS is_hosted_engine_storage
   FROM ((((((public.storage_domain_static
     JOIN public.storage_domain_dynamic ON ((storage_domain_static.id = storage_domain_dynamic.id)))
     LEFT JOIN ( SELECT storage_pool_iso_map.storage_id,
            (count(storage_pool_iso_map.storage_id) > 1) AS is_multi_domain,
            max(storage_pool_iso_map.status) AS status,
            array_to_string(array_agg(storage_pool.name), ','::text) AS pool_names,
                CASE
                    WHEN (count(DISTINCT storage_pool.id) = 1) THEN array_agg(storage_pool.id)
                    ELSE NULL::uuid[]
                END AS storage_pool_ids
           FROM (public.storage_pool_iso_map
             JOIN public.storage_pool ON ((storage_pool_iso_map.storage_pool_id = storage_pool.id)))
          GROUP BY storage_pool_iso_map.storage_id) status_table ON ((storage_domain_static.id = status_table.storage_id)))
     LEFT JOIN public.storage_domain_shared_status ON ((storage_domain_shared_status.storage_id = storage_domain_static.id)))
     LEFT JOIN public.domains_with_unregistered_entities_view ON ((domains_with_unregistered_entities_view.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.storage_domains_image_sizes ON ((storage_domains_image_sizes.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.vg_discard_support_view ON (((storage_domain_static.storage)::text = (vg_discard_support_view.volume_group_id)::text)));


ALTER TABLE public.storage_domains_for_search OWNER TO engine;

--
-- Name: storage_domains_with_hosts_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_domains_with_hosts_view AS
 SELECT storage_domain_static.id,
    storage_domain_static.storage,
    storage_domain_static.storage_name,
    storage_domain_static.storage_description,
    storage_domain_static.storage_comment,
    storage_domain_dynamic.available_disk_size,
    storage_domain_dynamic.confirmed_available_disk_size,
    storage_domain_dynamic.vdo_savings,
    storage_domain_dynamic.used_disk_size,
    storage_domains_image_sizes.commited_disk_size,
    storage_domains_image_sizes.actual_images_size,
    storage_pool.name AS storage_pool_name,
    storage_domain_static.storage_type,
    storage_domain_static.storage_domain_type,
    storage_domain_static.storage_domain_format_type,
    storage_domain_static.last_time_used_as_master,
    storage_domain_static.wipe_after_delete,
    storage_domain_static.discard_after_delete,
    storage_domain_static.first_metadata_device,
    storage_domain_static.vg_metadata_device,
    storage_domain_static.backup,
    storage_domain_static.block_size,
    COALESCE(storage_domain_shared_status.status, 0) AS storage_domain_shared_status,
    cluster.cluster_id,
    vds_static.vds_id,
    storage_pool_iso_map.storage_pool_id,
    vds_static.recoverable
   FROM (((((((public.storage_domain_static
     JOIN public.storage_domain_dynamic ON ((storage_domain_static.id = storage_domain_dynamic.id)))
     LEFT JOIN public.storage_pool_iso_map ON ((storage_domain_static.id = storage_pool_iso_map.storage_id)))
     LEFT JOIN public.storage_domain_shared_status ON ((storage_domain_shared_status.storage_id = storage_domain_static.id)))
     LEFT JOIN public.storage_domains_image_sizes ON ((storage_domains_image_sizes.storage_domain_id = storage_domain_static.id)))
     LEFT JOIN public.storage_pool ON ((storage_pool_iso_map.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.cluster ON ((storage_pool_iso_map.storage_pool_id = cluster.storage_pool_id)))
     LEFT JOIN public.vds_static ON ((cluster.cluster_id = vds_static.cluster_id)));


ALTER TABLE public.storage_domains_with_hosts_view OWNER TO engine;

--
-- Name: storage_pool_with_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.storage_pool_with_storage_domain AS
 SELECT storage_pool.id,
    storage_pool.name,
    storage_pool.description,
    storage_pool.free_text_comment,
    storage_pool.status,
    storage_pool.is_local,
    storage_pool.master_domain_version,
    storage_pool.spm_vds_id,
    storage_pool.compatibility_version,
    storage_pool._create_date,
    storage_pool._update_date,
    storage_pool_iso_map.storage_id,
    storage_pool_iso_map.storage_pool_id,
    storage_domain_static.storage_type,
    storage_domain_static.storage_domain_type,
    storage_domain_static.storage_domain_format_type,
    storage_domain_static.storage_name,
    storage_domain_static.storage,
    storage_domain_static.last_time_used_as_master
   FROM ((public.storage_pool
     LEFT JOIN public.storage_pool_iso_map ON ((storage_pool.id = storage_pool_iso_map.storage_pool_id)))
     LEFT JOIN public.storage_domain_static ON ((storage_pool_iso_map.storage_id = storage_domain_static.id)));


ALTER TABLE public.storage_pool_with_storage_domain OWNER TO engine;

--
-- Name: user_cluster_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_cluster_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 9) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT DISTINCT vm_static.cluster_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vm_static
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_static.vm_guid) AND ((internal_permissions_view.object_type_id = 2) OR (internal_permissions_view.object_type_id = 4)) AND (internal_permissions_view.role_type = 2) AND (vm_static.cluster_id IS NOT NULL))))
UNION ALL
 SELECT cluster.cluster_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.cluster
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = cluster.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT cluster.cluster_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.cluster)
  WHERE ((internal_permissions_view.object_type_id = 1) AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_cluster_permissions_view_base OWNER TO engine;

--
-- Name: user_cluster_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_cluster_permissions_view AS
 SELECT DISTINCT user_cluster_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_cluster_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_cluster_permissions_view OWNER TO engine;

--
-- Name: user_db_users_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_db_users_permissions_view AS
 SELECT DISTINCT permissions.ad_element_id,
    roles_groups.role_id,
    roles_groups.action_group_id
   FROM (public.permissions
     JOIN public.roles_groups ON ((permissions.role_id = roles_groups.role_id)))
  WHERE (roles_groups.action_group_id = 502);


ALTER TABLE public.user_db_users_permissions_view OWNER TO engine;

--
-- Name: vm_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id,
    internal_permissions_view.role_type
   FROM public.internal_permissions_view
  WHERE (internal_permissions_view.object_type_id = 2)
UNION ALL
 SELECT vm_static.vm_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id,
    internal_permissions_view.role_type
   FROM (public.vm_static
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_static.cluster_id) AND (internal_permissions_view.object_type_id = 9) AND internal_permissions_view.allows_viewing_children)))
UNION ALL
 SELECT vm_static.vm_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id,
    internal_permissions_view.role_type
   FROM ((public.vm_static
     JOIN public.cluster ON ((cluster.cluster_id = vm_static.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = cluster.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND internal_permissions_view.allows_viewing_children)))
UNION ALL
 SELECT vm_static.vm_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id,
    internal_permissions_view.role_type
   FROM (public.internal_permissions_view
     CROSS JOIN public.vm_static)
  WHERE ((internal_permissions_view.object_type_id = 1) AND internal_permissions_view.allows_viewing_children);


ALTER TABLE public.vm_permissions_view_base OWNER TO engine;

--
-- Name: user_vm_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vm_permissions_view AS
 SELECT DISTINCT vm_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.vm_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id))
  WHERE (vm_permissions_view_base.role_type = 2);


ALTER TABLE public.user_vm_permissions_view OWNER TO engine;

--
-- Name: user_vm_template_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vm_template_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 4) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vm_static.vmt_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vm_static
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_static.vm_guid) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_static.vm_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_static
     JOIN public.cluster ON ((cluster.cluster_id = vm_static.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = cluster.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2) AND ((vm_static.entity_type)::text = 'TEMPLATE'::text))))
UNION ALL
 SELECT vm_static.vm_guid AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.vm_static)
  WHERE ((internal_permissions_view.object_type_id = 1) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2) AND (((vm_static.entity_type)::text = 'TEMPLATE'::text) OR ((vm_static.entity_type)::text = 'INSTANCE_TYPE'::text) OR ((vm_static.entity_type)::text = 'IMAGE_TYPE'::text)));


ALTER TABLE public.user_vm_template_permissions_view_base OWNER TO engine;

--
-- Name: user_vm_template_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vm_template_permissions_view AS
 SELECT DISTINCT user_vm_template_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_vm_template_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_vm_template_permissions_view OWNER TO engine;

--
-- Name: user_disk_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_disk_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 19) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vm_device.device_id AS entity_id,
    user_vm_permissions_view.user_id AS granted_id
   FROM (public.vm_device
     JOIN public.user_vm_permissions_view ON ((user_vm_permissions_view.entity_id = vm_device.vm_id)))
  WHERE (((vm_device.type)::text = 'disk'::text) AND ((vm_device.device)::text = 'disk'::text))
UNION ALL
 SELECT vm_device.device_id AS entity_id,
    user_vm_template_permissions_view.user_id AS granted_id
   FROM (public.vm_device
     JOIN public.user_vm_template_permissions_view ON ((user_vm_template_permissions_view.entity_id = vm_device.vm_id)))
  WHERE (((vm_device.type)::text = 'disk'::text) AND ((vm_device.device)::text = 'disk'::text))
UNION ALL
 SELECT images.image_group_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.image_storage_domain_map
     JOIN public.images ON ((images.image_guid = image_storage_domain_map.image_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = image_storage_domain_map.storage_domain_id) AND (internal_permissions_view.object_type_id = 11) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT images.image_group_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (((public.image_storage_domain_map
     JOIN public.storage_pool_iso_map ON ((image_storage_domain_map.storage_domain_id = storage_pool_iso_map.storage_id)))
     JOIN public.images ON ((images.image_guid = image_storage_domain_map.image_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = storage_pool_iso_map.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_device.device_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.vm_device)
  WHERE ((internal_permissions_view.object_type_id = 1) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_disk_permissions_view_base OWNER TO engine;

--
-- Name: user_disk_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_disk_permissions_view AS
 SELECT DISTINCT user_disk_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_disk_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_disk_permissions_view OWNER TO engine;

--
-- Name: user_disk_profile_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_disk_profile_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 29) AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_disk_profile_permissions_view_base OWNER TO engine;

--
-- Name: user_disk_profile_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_disk_profile_permissions_view AS
 SELECT DISTINCT user_disk_profile_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_disk_profile_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_disk_profile_permissions_view OWNER TO engine;

--
-- Name: user_vnic_profile_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vnic_profile_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 27) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vnic_profiles.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vnic_profiles
     JOIN public.internal_permissions_view ON ((internal_permissions_view.object_id = vnic_profiles.network_id)))
  WHERE ((internal_permissions_view.object_type_id = 20) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vnic_profiles.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vnic_profiles
     JOIN public.network ON ((network.id = vnic_profiles.network_id)))
     JOIN public.internal_permissions_view ON ((internal_permissions_view.object_id = network.storage_pool_id)))
  WHERE ((internal_permissions_view.object_type_id = 14) AND (internal_permissions_view.role_type = 2) AND internal_permissions_view.allows_viewing_children)
UNION ALL
 SELECT vnic_profiles.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vnic_profiles
     JOIN public.network_cluster ON ((network_cluster.network_id = vnic_profiles.network_id)))
     JOIN public.internal_permissions_view ON ((internal_permissions_view.object_id = network_cluster.cluster_id)))
  WHERE ((internal_permissions_view.object_type_id = 9) AND (internal_permissions_view.role_type = 2) AND internal_permissions_view.allows_viewing_children)
UNION ALL
 SELECT DISTINCT vm_interface.vnic_profile_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_interface
     JOIN public.internal_permissions_view ON ((internal_permissions_view.object_id = vm_interface.vm_guid)))
     JOIN public.vm_static ON ((vm_interface.vm_guid = vm_static.vm_guid)))
  WHERE (((vm_static.entity_type)::text = 'TEMPLATE'::text) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT DISTINCT vm_interface.vnic_profile_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_interface
     JOIN public.internal_permissions_view ON ((internal_permissions_view.object_id = vm_interface.vm_guid)))
     JOIN public.vm_static ON ((vm_interface.vm_guid = vm_static.vm_guid)))
  WHERE (((vm_static.entity_type)::text = 'VM'::text) AND (internal_permissions_view.object_type_id = 4) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vnic_profiles.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.vnic_profiles)
  WHERE ((internal_permissions_view.object_type_id = 1) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_vnic_profile_permissions_view_base OWNER TO engine;

--
-- Name: user_vnic_profile_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vnic_profile_permissions_view AS
 SELECT DISTINCT user_vnic_profile_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_vnic_profile_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_vnic_profile_permissions_view OWNER TO engine;

--
-- Name: user_network_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_network_permissions_view_base AS
 SELECT network.id AS entity_id,
    user_vnic_profile_permissions_view.user_id AS granted_id
   FROM ((public.network
     JOIN public.vnic_profiles ON ((vnic_profiles.network_id = network.id)))
     JOIN public.user_vnic_profile_permissions_view ON ((user_vnic_profile_permissions_view.entity_id = vnic_profiles.id)));


ALTER TABLE public.user_network_permissions_view_base OWNER TO engine;

--
-- Name: user_network_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_network_permissions_view AS
 SELECT DISTINCT user_network_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_network_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_network_permissions_view OWNER TO engine;

--
-- Name: user_object_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_object_permissions_view AS
 SELECT DISTINCT permissions.object_id AS entity_id,
    engine_session_user_flat_groups.user_id
   FROM ((public.permissions
     JOIN public.roles ON ((permissions.role_id = roles.id)))
     JOIN public.engine_session_user_flat_groups ON ((engine_session_user_flat_groups.granted_id = permissions.ad_element_id)))
  WHERE (permissions.ad_element_id <> public.getglobalids('everyone'::character varying));


ALTER TABLE public.user_object_permissions_view OWNER TO engine;

--
-- Name: user_permissions_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_permissions_permissions_view AS
 SELECT DISTINCT internal_permissions_view.id AS entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.internal_permissions_view
     JOIN public.engine_session_user_flat_groups ON ((engine_session_user_flat_groups.granted_id = internal_permissions_view.ad_element_id)));


ALTER TABLE public.user_permissions_permissions_view OWNER TO engine;

--
-- Name: user_storage_domain_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_storage_domain_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 11) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT storage_domains.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (((public.storage_domains
     JOIN public.cluster ON ((cluster.storage_pool_id = storage_domains.storage_pool_id)))
     JOIN public.vm_static ON ((cluster.cluster_id = vm_static.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_static.vm_guid) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_templates_based_storage_domain.storage_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vm_templates_based_storage_domain
     JOIN public.internal_permissions_view ON (((vm_templates_based_storage_domain.vmt_guid = internal_permissions_view.object_id) AND (internal_permissions_view.object_type_id = 4) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_templates_based_storage_domain.storage_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_static
     JOIN public.vm_templates_based_storage_domain ON ((vm_static.vmt_guid = vm_templates_based_storage_domain.vmt_guid)))
     JOIN public.internal_permissions_view ON (((vm_static.vm_guid = internal_permissions_view.object_id) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT storage_domains.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.storage_domains
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = storage_domains.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT storage_domains.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.storage_domains)
  WHERE ((internal_permissions_view.object_type_id = 1) AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_storage_domain_permissions_view_base OWNER TO engine;

--
-- Name: user_storage_domain_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_storage_domain_permissions_view AS
 SELECT DISTINCT user_storage_domain_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_storage_domain_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_storage_domain_permissions_view OWNER TO engine;

--
-- Name: user_storage_pool_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_storage_pool_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 14) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT cluster.storage_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.cluster
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = cluster.cluster_id) AND (internal_permissions_view.object_type_id = 9) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT cluster.storage_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.cluster
     JOIN public.vm_pools ON ((cluster.cluster_id = vm_pools.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_pools.vm_pool_id) AND (internal_permissions_view.object_type_id = 5) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT cluster.storage_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_static
     JOIN public.cluster ON ((cluster.cluster_id = vm_static.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_static.vm_guid) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT storage_pool.id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.storage_pool)
  WHERE ((internal_permissions_view.object_type_id = 1) AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_storage_pool_permissions_view_base OWNER TO engine;

--
-- Name: user_storage_pool_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_storage_pool_permissions_view AS
 SELECT DISTINCT user_storage_pool_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_storage_pool_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_storage_pool_permissions_view OWNER TO engine;

--
-- Name: user_vds_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vds_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 3) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vds.vds_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vds
     JOIN public.internal_permissions_view ON ((((internal_permissions_view.object_id = vds.cluster_id) AND (internal_permissions_view.object_type_id = 9)) OR ((internal_permissions_view.object_id = vds.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND (internal_permissions_view.role_type = 2)))))
UNION ALL
 SELECT vds.vds_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.vds)
  WHERE ((internal_permissions_view.object_type_id = 1) AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_vds_permissions_view_base OWNER TO engine;

--
-- Name: user_vds_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vds_permissions_view AS
 SELECT DISTINCT user_vds_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_vds_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_vds_permissions_view OWNER TO engine;

--
-- Name: user_vm_pool_permissions_view_base; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vm_pool_permissions_view_base AS
 SELECT internal_permissions_view.object_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM public.internal_permissions_view
  WHERE ((internal_permissions_view.object_type_id = 5) AND (internal_permissions_view.role_type = 2))
UNION ALL
 SELECT vm_pool_map.vm_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vm_pool_map
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_pool_map.vm_guid) AND (internal_permissions_view.object_type_id = 2) AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_pools.vm_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.vm_pools
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = vm_pools.cluster_id) AND (internal_permissions_view.object_type_id = 9) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_pools.vm_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM ((public.vm_pools
     JOIN public.cluster ON ((vm_pools.cluster_id = cluster.cluster_id)))
     JOIN public.internal_permissions_view ON (((internal_permissions_view.object_id = cluster.storage_pool_id) AND (internal_permissions_view.object_type_id = 14) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2))))
UNION ALL
 SELECT vm_pools.vm_pool_id AS entity_id,
    internal_permissions_view.ad_element_id AS granted_id
   FROM (public.internal_permissions_view
     CROSS JOIN public.vm_pools)
  WHERE ((internal_permissions_view.object_type_id = 1) AND internal_permissions_view.allows_viewing_children AND (internal_permissions_view.role_type = 2));


ALTER TABLE public.user_vm_pool_permissions_view_base OWNER TO engine;

--
-- Name: user_vm_pool_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.user_vm_pool_permissions_view AS
 SELECT DISTINCT user_vm_pool_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.user_vm_pool_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.user_vm_pool_permissions_view OWNER TO engine;

--
-- Name: users_and_groups_to_vm_pool_map_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.users_and_groups_to_vm_pool_map_view AS
 SELECT p.vm_pool_id,
    p.vm_pool_name,
    per.ad_element_id AS user_id
   FROM (public.vm_pools p
     JOIN public.permissions per ON ((per.object_id = p.vm_pool_id)));


ALTER TABLE public.users_and_groups_to_vm_pool_map_view OWNER TO engine;

--
-- Name: uuid_sequence; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.uuid_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.uuid_sequence OWNER TO engine;

--
-- Name: vdc_db_log_seq; Type: SEQUENCE; Schema: public; Owner: engine
--

CREATE SEQUENCE public.vdc_db_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vdc_db_log_seq OWNER TO engine;

--
-- Name: vdc_db_log; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vdc_db_log (
    error_id bigint DEFAULT nextval('public.vdc_db_log_seq'::regclass) NOT NULL,
    occured_at timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone NOT NULL,
    error_code character varying(16) NOT NULL,
    error_message character varying(2048),
    error_proc character varying(126),
    error_line integer
);


ALTER TABLE public.vdc_db_log OWNER TO engine;

--
-- Name: vdc_users; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vdc_users AS
 SELECT 'user'::text AS user_group,
    users_1.name,
    users_1.user_id,
    users_1.surname,
    users_1.domain,
    users_1.username,
    users_1.user_and_domain,
    users_1.department,
    users_1.email,
    users_1.note,
    0 AS vm_admin,
    users_1.last_admin_check_status,
    users_1.external_id,
    users_1.namespace
   FROM public.users users_1
UNION
 SELECT 'group'::text AS user_group,
    ad_groups.name,
    ad_groups.id AS user_id,
    ''::character varying AS surname,
    ad_groups.domain,
    ''::character varying AS username,
    ''::character varying AS user_and_domain,
    ''::character varying AS department,
    ''::character varying AS email,
    ''::character varying AS note,
    1 AS vm_admin,
    NULL::boolean AS last_admin_check_status,
    ad_groups.external_id,
    ad_groups.namespace
   FROM public.ad_groups;


ALTER TABLE public.vdc_users OWNER TO engine;

--
-- Name: vdc_users_with_tags; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vdc_users_with_tags AS
 SELECT users_1.user_group,
    users_1.name,
    permissions.object_id AS vm_guid,
    users_1.user_id,
    users_1.surname,
    users_1.domain,
    users_1.username,
    users_1.user_and_domain,
    users_1.department,
    roles1.name AS mla_role,
    users_1.email,
    users_1.note,
    users_1.vm_admin,
    tags_user_map_view_1.tag_name,
    tags_user_map_view_1.tag_id,
    users_1.last_admin_check_status,
    users_1.external_id,
    users_1.namespace,
    pools.vm_pool_name
   FROM (((((public.vdc_users users_1
     LEFT JOIN public.users_and_groups_to_vm_pool_map_view pools ON ((users_1.user_id = pools.user_id)))
     LEFT JOIN public.permissions ON ((users_1.user_id = permissions.ad_element_id)))
     LEFT JOIN public.tags ON ((tags.type = 1)))
     LEFT JOIN public.tags_user_map_view tags_user_map_view_1 ON ((users_1.user_id = tags_user_map_view_1.user_id)))
     LEFT JOIN public.roles roles1 ON ((roles1.id = permissions.role_id)))
  WHERE (users_1.user_group = 'user'::text)
UNION
 SELECT users_2.user_group,
    users_2.name,
    permissions_1.object_id AS vm_guid,
    users_2.user_id,
    users_2.surname,
    users_2.domain,
    users_2.username,
    users_2.user_and_domain,
    users_2.department,
    roles2.name AS mla_role,
    users_2.email,
    users_2.note,
    users_2.vm_admin,
    tags_user_group_map_view.tag_name,
    tags_user_group_map_view.tag_id,
    users_2.last_admin_check_status,
    users_2.external_id,
    users_2.namespace,
    pools1.vm_pool_name
   FROM (((((public.vdc_users users_2
     LEFT JOIN public.users_and_groups_to_vm_pool_map_view pools1 ON ((users_2.user_id = pools1.user_id)))
     LEFT JOIN public.permissions permissions_1 ON ((users_2.user_id = permissions_1.ad_element_id)))
     LEFT JOIN public.tags tags_1 ON ((tags_1.type = 1)))
     LEFT JOIN public.tags_user_group_map_view ON ((users_2.user_id = tags_user_group_map_view.group_id)))
     LEFT JOIN public.roles roles2 ON ((roles2.id = permissions_1.role_id)))
  WHERE (users_2.user_group = 'group'::text);


ALTER TABLE public.vdc_users_with_tags OWNER TO engine;

--
-- Name: vds_groups; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vds_groups AS
 SELECT cluster.cluster_id,
    cluster.name,
    cluster.description,
    cluster.cpu_name,
    cluster._create_date,
    cluster._update_date,
    cluster.storage_pool_id,
    cluster.max_vds_memory_over_commit,
    cluster.compatibility_version,
    cluster.transparent_hugepages,
    cluster.migrate_on_error,
    cluster.virt_service,
    cluster.gluster_service,
    cluster.count_threads_as_cores,
    cluster.emulated_machine,
    cluster.trusted_service,
    cluster.tunnel_migration,
    cluster.cluster_policy_id,
    cluster.cluster_policy_custom_properties,
    cluster.enable_balloon,
    cluster.free_text_comment,
    cluster.detect_emulated_machine,
    cluster.architecture,
    cluster.optimization_type,
    cluster.spice_proxy,
    cluster.ha_reservation,
    cluster.enable_ksm,
    cluster.serial_number_policy,
    cluster.custom_serial_number,
    cluster.additional_rng_sources,
    cluster.skip_fencing_if_sd_active,
    cluster.skip_fencing_if_connectivity_broken,
    cluster.hosts_with_broken_connectivity_threshold,
    cluster.fencing_enabled,
    cluster.is_auto_converge,
    cluster.is_migrate_compressed,
    cluster.gluster_tuned_profile,
    cluster.gluster_cli_based_snapshot_scheduled,
    cluster.ksm_merge_across_nodes,
    cluster.migration_bandwidth_limit_type,
    cluster.custom_migration_bandwidth_limit,
    cluster.migration_policy_id,
    cluster.mac_pool_id,
    cluster.switch_type,
    cluster.skip_fencing_if_gluster_bricks_up,
    cluster.skip_fencing_if_gluster_quorum_not_met,
    cluster.firewall_type,
    cluster.default_network_provider_id,
    cluster.log_max_memory_used_threshold,
    cluster.log_max_memory_used_threshold_type,
    cluster.vnc_encryption_enabled
   FROM public.cluster;


ALTER TABLE public.vds_groups OWNER TO engine;

--
-- Name: vds_with_tags; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vds_with_tags AS
 SELECT cluster.cluster_id,
    cluster.name AS cluster_name,
    cluster.description AS cluster_description,
    cluster.architecture,
    cluster.enable_balloon,
    vds_static.vds_id,
    vds_static.vds_name,
    vds_static.vds_unique_id,
    vds_static.host_name,
    vds_static.free_text_comment,
    vds_static.port,
    vds_static.server_ssl_enabled,
    vds_static.vds_type,
    vds_dynamic.hw_product_name,
    vds_dynamic.hw_version,
    vds_dynamic.hw_serial_number,
    vds_dynamic.hw_uuid,
    vds_dynamic.hw_family,
    vds_static.pm_enabled,
    vds_static.pm_proxy_preferences,
    vds_static.pm_detect_kdump,
    vds_static.vds_spm_priority,
    vds_dynamic.hooks,
    vds_dynamic.status,
    vds_dynamic.external_status,
    vds_dynamic.cpu_cores,
    vds_dynamic.cpu_threads,
    vds_dynamic.kernel_args,
    vds_dynamic.pretty_name,
    vds_dynamic.hosted_engine_configured,
    vds_dynamic.cpu_model,
    vds_dynamic.cpu_speed_mh,
    vds_dynamic.if_total_speed,
    vds_dynamic.kvm_enabled,
    vds_dynamic.physical_mem_mb,
    vds_dynamic.pending_vcpus_count,
    vds_dynamic.pending_vmem_size,
    vds_dynamic.mem_commited,
    vds_dynamic.vm_active,
    vds_dynamic.vm_count,
    vds_dynamic.vm_migrating,
    vds_dynamic.incoming_migrations,
    vds_dynamic.outgoing_migrations,
    vds_dynamic.vms_cores_count,
    vds_statistics.cpu_over_commit_time_stamp,
    vds_dynamic.net_config_dirty,
    cluster.max_vds_memory_over_commit,
    cluster.count_threads_as_cores,
    storage_pool.id AS storage_pool_id,
    storage_pool.name AS storage_pool_name,
    tags_vds_map_view.tag_name,
    tags_vds_map_view.tag_id,
    vds_dynamic.reserved_mem,
    vds_dynamic.guest_overhead,
    vds_dynamic.rpm_version,
    vds_dynamic.software_version,
    vds_dynamic.version_name,
    vds_dynamic.build_name,
    vds_dynamic.previous_status,
    vds_statistics.cpu_idle,
    vds_statistics.cpu_load,
    vds_statistics.cpu_sys,
    vds_statistics.cpu_user,
    vds_statistics.usage_mem_percent,
    vds_statistics.usage_cpu_percent,
    vds_statistics.usage_network_percent,
    vds_statistics.mem_free,
    vds_statistics.mem_shared,
    vds_statistics.swap_free,
    vds_statistics.swap_total,
    vds_statistics.ksm_cpu_percent,
    vds_statistics.ksm_pages,
    vds_statistics.ksm_state,
    vds_dynamic.cpu_flags,
    cluster.cpu_name AS cluster_cpu_name,
    cluster.cpu_flags AS cluster_cpu_flags,
    cluster.cpu_verb AS cluster_cpu_verb,
    vds_dynamic.cpu_sockets,
    vds_spm_id_map.vds_spm_id,
    vds_static.otp_validity,
    vds_static.console_address,
        CASE
            WHEN (storage_pool.spm_vds_id = vds_static.vds_id) THEN
            CASE
                WHEN (storage_pool.status = 5) THEN 1
                ELSE 2
            END
            ELSE 0
        END AS spm_status,
    vds_dynamic.supported_cluster_levels,
    vds_dynamic.supported_engines,
    cluster.compatibility_version AS cluster_compatibility_version,
    cluster.virt_service AS cluster_virt_service,
    cluster.gluster_service AS cluster_gluster_service,
    vds_dynamic.host_os,
    vds_dynamic.kvm_version,
    vds_dynamic.libvirt_version,
    vds_dynamic.spice_version,
    vds_dynamic.gluster_version,
    vds_dynamic.librbd1_version,
    vds_dynamic.glusterfs_cli_version,
    vds_dynamic.openvswitch_version,
    vds_dynamic.nmstate_version,
    vds_dynamic.kernel_version,
    vds_dynamic.iscsi_initiator_name,
    vds_dynamic.transparent_hugepages_state,
    vds_statistics.anonymous_hugepages,
    vds_statistics.hugepages,
    vds_dynamic.non_operational_reason,
    vds_static.recoverable,
    vds_static.sshkeyfingerprint,
    vds_static.host_provider_id,
    vds_dynamic.hw_manufacturer,
    storage_pool_iso_map.storage_id,
    vds_static.ssh_port,
    vds_static.ssh_username,
    vds_statistics.ha_score,
    vds_statistics.ha_configured,
    vds_statistics.ha_active,
    vds_statistics.ha_global_maintenance,
    vds_statistics.ha_local_maintenance,
    vds_static.disable_auto_pm,
    vds_dynamic.controlled_by_pm_policy,
    vds_statistics.boot_time,
    vds_dynamic.kdump_status,
    vds_dynamic.selinux_enforce_mode,
    vds_dynamic.auto_numa_balancing,
    vds_dynamic.is_numa_supported,
    vds_dynamic.hbas,
    vds_dynamic.supported_emulated_machines,
    vds_dynamic.supported_rng_sources,
    vds_dynamic.online_cpus,
    vds_dynamic.maintenance_reason,
    vds_dynamic.is_update_available,
    vds_dynamic.is_hostdev_enabled,
    vds_static.kernel_cmdline,
    vds_static.last_stored_kernel_cmdline,
    cluster.fencing_enabled,
    vds_dynamic.in_fence_flow,
    vds_static.reinstall_required,
    vds_dynamic.kernel_features,
    vds_dynamic.vnc_encryption_enabled,
    vds_static.vgpu_placement,
    vds_dynamic.connector_info,
    vds_dynamic.backup_enabled,
    vds_dynamic.cold_backup_enabled,
    vds_dynamic.clear_bitmaps_enabled,
    vds_dynamic.supported_domain_versions,
    vds_dynamic.supported_block_size,
    cluster.smt_disabled AS cluster_smt_disabled,
    vds_dynamic.tsc_frequency,
    vds_dynamic.tsc_scaling,
    vds_dynamic.fips_enabled,
    vds_dynamic.boot_uuid,
    vds_dynamic.cd_change_pdiv,
    vds_dynamic.ovn_configured,
    vds_static.ssh_public_key,
    vds_dynamic.cpu_topology,
    vds_dynamic.vdsm_cpus_affinity
   FROM (((((((public.cluster
     JOIN public.vds_static ON ((cluster.cluster_id = vds_static.cluster_id)))
     JOIN public.vds_dynamic ON ((vds_static.vds_id = vds_dynamic.vds_id)))
     JOIN public.vds_statistics ON ((vds_static.vds_id = vds_statistics.vds_id)))
     LEFT JOIN public.storage_pool ON ((cluster.storage_pool_id = storage_pool.id)))
     LEFT JOIN public.tags_vds_map_view ON ((vds_static.vds_id = tags_vds_map_view.vds_id)))
     LEFT JOIN public.vds_spm_id_map ON ((vds_static.vds_id = vds_spm_id_map.vds_id)))
     LEFT JOIN public.storage_pool_iso_map ON ((storage_pool_iso_map.storage_pool_id = storage_pool.id)));


ALTER TABLE public.vds_with_tags OWNER TO engine;

--
-- Name: vfs_config_labels; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vfs_config_labels (
    vfs_config_id uuid NOT NULL,
    label text NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.vfs_config_labels OWNER TO engine;

--
-- Name: vfs_config_networks; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vfs_config_networks (
    vfs_config_id uuid NOT NULL,
    network_id uuid NOT NULL,
    _create_date timestamp with time zone DEFAULT ('now'::text)::timestamp without time zone,
    _update_date timestamp with time zone
);


ALTER TABLE public.vfs_config_networks OWNER TO engine;

--
-- Name: vm_backup_disk_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_backup_disk_map (
    backup_id uuid NOT NULL,
    disk_id uuid NOT NULL,
    backup_url character varying,
    disk_snapshot_id uuid
);


ALTER TABLE public.vm_backup_disk_map OWNER TO engine;

--
-- Name: vm_checkpoint_disk_map; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_checkpoint_disk_map (
    checkpoint_id uuid NOT NULL,
    disk_id uuid NOT NULL
);


ALTER TABLE public.vm_checkpoint_disk_map OWNER TO engine;

--
-- Name: vm_external_data; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_external_data (
    device_id uuid NOT NULL,
    vm_id uuid NOT NULL,
    tpm_data text,
    tpm_hash text
);


ALTER TABLE public.vm_external_data OWNER TO engine;

--
-- Name: vm_images_storage_domains_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_images_storage_domains_view AS
 SELECT vm_images_view.storage_id,
    vm_images_view.storage_pool_id,
    vm_images_view.image_guid,
    vm_images_view.creation_date,
    vm_images_view.actual_size,
    vm_images_view.read_rate,
    vm_images_view.read_ops,
    vm_images_view.write_rate,
    vm_images_view.write_ops,
    vm_images_view.size,
    vm_images_view.it_guid,
    vm_images_view.description,
    vm_images_view.parentid,
    vm_images_view.imagestatus,
    vm_images_view.lastmodified,
    vm_images_view.app_list,
    vm_images_view.vm_snapshot_id,
    vm_images_view.volume_type,
    vm_images_view.image_group_id,
    vm_images_view.active,
    vm_images_view.volume_format,
    vm_images_view.qcow_compat,
    vm_images_view.wipe_after_delete,
    vm_images_view.propagate_errors,
    vm_images_view.disk_content_type,
    vm_images_view.backup,
    vm_images_view.entity_type,
    vm_images_view.number_of_vms,
    vm_images_view.vm_names,
    vm_images_view.template_version_names,
    vm_images_view.quota_id,
    vm_images_view.quota_name,
    vm_images_view.disk_profile_id,
    vm_images_view.disk_profile_name,
    vm_images_view.disk_alias,
    vm_images_view.disk_description,
    vm_images_view.sgio,
    storage_domains_with_hosts_view.id,
    storage_domains_with_hosts_view.storage,
    storage_domains_with_hosts_view.storage_name,
    storage_domains_with_hosts_view.available_disk_size,
    storage_domains_with_hosts_view.used_disk_size,
    storage_domains_with_hosts_view.commited_disk_size,
    storage_domains_with_hosts_view.actual_images_size,
    storage_domains_with_hosts_view.storage_type,
    storage_domains_with_hosts_view.storage_domain_type,
    storage_domains_with_hosts_view.storage_domain_format_type,
    storage_domains_with_hosts_view.storage_domain_shared_status,
    storage_domains_with_hosts_view.cluster_id,
    storage_domains_with_hosts_view.vds_id,
    storage_domains_with_hosts_view.recoverable,
    storage_domains_with_hosts_view.storage_pool_name,
    storage_domains_with_hosts_view.storage_name AS name
   FROM ((public.vm_images_view
     JOIN public.images_storage_domain_view ON ((vm_images_view.image_guid = images_storage_domain_view.image_guid)))
     JOIN public.storage_domains_with_hosts_view ON ((storage_domains_with_hosts_view.id = images_storage_domain_view.storage_id)));


ALTER TABLE public.vm_images_storage_domains_view OWNER TO engine;

--
-- Name: vm_interfaces_plugged_on_vm_not_down_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_interfaces_plugged_on_vm_not_down_view AS
 SELECT vm_interface.id,
    vm_interface.vm_guid,
    vm_interface.mac_addr,
    vm_interface.name,
    vm_interface.speed,
    vm_interface.type,
    vm_interface._create_date,
    vm_interface._update_date,
    vm_interface.linked,
    vm_interface.vnic_profile_id,
    vm_interface.synced
   FROM ((public.vm_interface
     JOIN public.vm_dynamic ON ((vm_interface.vm_guid = vm_dynamic.vm_guid)))
     JOIN public.vm_device ON ((vm_interface.id = vm_device.device_id)))
  WHERE ((vm_dynamic.status <> 0) AND (vm_device.is_plugged = true));


ALTER TABLE public.vm_interfaces_plugged_on_vm_not_down_view OWNER TO engine;

--
-- Name: vm_nvram_data; Type: TABLE; Schema: public; Owner: engine
--

CREATE TABLE public.vm_nvram_data (
    vm_id uuid NOT NULL,
    nvram_data text,
    nvram_hash text
);


ALTER TABLE public.vm_nvram_data OWNER TO engine;

--
-- Name: vm_permissions_view; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_permissions_view AS
 SELECT DISTINCT vm_permissions_view_base.entity_id,
    engine_session_user_flat_groups.user_id
   FROM (public.vm_permissions_view_base
     JOIN public.engine_session_user_flat_groups USING (granted_id));


ALTER TABLE public.vm_permissions_view OWNER TO engine;

--
-- Name: vm_templates_storage_domain; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vm_templates_storage_domain AS
 SELECT vm_templates_based_storage_domain.vmt_guid,
    vm_templates_based_storage_domain.name,
    vm_templates_based_storage_domain.mem_size_mb,
    vm_templates_based_storage_domain.max_memory_size_mb,
    vm_templates_based_storage_domain.num_of_io_threads,
    vm_templates_based_storage_domain.os,
    vm_templates_based_storage_domain.creation_date,
    vm_templates_based_storage_domain.child_count,
    vm_templates_based_storage_domain.num_of_sockets,
    vm_templates_based_storage_domain.cpu_per_socket,
    vm_templates_based_storage_domain.threads_per_cpu,
    vm_templates_based_storage_domain.num_of_cpus,
    vm_templates_based_storage_domain.description,
    vm_templates_based_storage_domain.free_text_comment,
    vm_templates_based_storage_domain.cluster_id,
    vm_templates_based_storage_domain.num_of_monitors,
    vm_templates_based_storage_domain.allow_console_reconnect,
    vm_templates_based_storage_domain.status,
    vm_templates_based_storage_domain.usb_policy,
    vm_templates_based_storage_domain.time_zone,
    vm_templates_based_storage_domain.cluster_name,
    vm_templates_based_storage_domain.vm_type,
    vm_templates_based_storage_domain.nice_level,
    vm_templates_based_storage_domain.cpu_shares,
    vm_templates_based_storage_domain.storage_pool_id,
    vm_templates_based_storage_domain.storage_pool_name,
    vm_templates_based_storage_domain.default_boot_sequence,
    vm_templates_based_storage_domain.default_display_type,
    vm_templates_based_storage_domain.priority,
    vm_templates_based_storage_domain.auto_startup,
    vm_templates_based_storage_domain.lease_sd_id,
    vm_templates_based_storage_domain.is_stateless,
    vm_templates_based_storage_domain.iso_path,
    vm_templates_based_storage_domain.origin,
    vm_templates_based_storage_domain.initrd_url,
    vm_templates_based_storage_domain.kernel_url,
    vm_templates_based_storage_domain.kernel_params,
    vm_templates_based_storage_domain.storage_id,
    vm_templates_based_storage_domain.quota_name,
    vm_templates_based_storage_domain.is_disabled,
    vm_templates_based_storage_domain.min_allocated_mem,
    vm_templates_based_storage_domain.is_run_and_pause,
    vm_templates_based_storage_domain.created_by_user_id,
    vm_templates_based_storage_domain.migration_downtime,
    vm_templates_based_storage_domain.entity_type,
    vm_templates_based_storage_domain.architecture,
    vm_templates_based_storage_domain.template_version_number,
    vm_templates_based_storage_domain.base_template_id,
    vm_templates_based_storage_domain.template_version_name,
    vm_templates_based_storage_domain.serial_number_policy,
    vm_templates_based_storage_domain.custom_serial_number,
    vm_templates_based_storage_domain.is_boot_menu_enabled,
    vm_templates_based_storage_domain.is_spice_file_transfer_enabled,
    vm_templates_based_storage_domain.is_spice_copy_paste_enabled,
    vm_templates_based_storage_domain.cpu_profile_id,
    vm_templates_based_storage_domain.host_cpu_flags,
    vm_templates_based_storage_domain.is_auto_converge,
    vm_templates_based_storage_domain.is_migrate_compressed,
    vm_templates_based_storage_domain.is_migrate_encrypted,
    vm_templates_based_storage_domain.predefined_properties,
    vm_templates_based_storage_domain.userdefined_properties,
    vm_templates_based_storage_domain.is_template_sealed,
    vm_templates_based_storage_domain.console_disconnect_action_delay,
    vm_templates_based_storage_domain.parallel_migrations
   FROM public.vm_templates_based_storage_domain
  WHERE ((vm_templates_based_storage_domain.entity_type)::text = 'TEMPLATE'::text);


ALTER TABLE public.vm_templates_storage_domain OWNER TO engine;

--
-- Name: vms_with_tags; Type: VIEW; Schema: public; Owner: engine
--

CREATE VIEW public.vms_with_tags AS
 SELECT DISTINCT vms.vm_name,
    vms.lease_sd_id,
    vms.lease_info,
    vms.mem_size_mb,
    vms.max_memory_size_mb,
    vms.num_of_io_threads,
    vms.nice_level,
    vms.cpu_shares,
    vms.vmt_guid,
    vms.os,
    vms.description,
    vms.free_text_comment,
    vms.cluster_id,
    vms.creation_date,
    vms.auto_startup,
    vms.is_stateless,
    vms.is_smartcard_enabled,
    vms.is_delete_protected,
    vms.sso_method,
    public.fn_get_dedicated_hosts_ids_by_vm_id(vms.vm_guid) AS dedicated_vm_for_vds,
    vms.default_boot_sequence,
    vms.vm_type,
    vms.cluster_name,
    vms.storage_pool_id,
    vms.storage_pool_name,
    vms.vmt_name,
    vms.status,
    vms.vm_ip,
    vms.vm_ip_inet_array,
    vms.vm_host,
    vms.last_start_time,
    vms.boot_time,
    vms.downtime,
    vms.last_stop_time,
    vms.guest_cur_user_name,
    vms.console_cur_user_name,
    vms.runtime_name,
    vms.console_user_id,
    vms.guest_agent_nics_hash,
    vms.guest_os,
    vms.run_on_vds,
    vms.migrating_to_vds,
    vms.app_list,
    vms.vm_pool_name,
    vms.vm_pool_id,
    vms.vm_guid,
    vms.num_of_monitors,
    vms.allow_console_reconnect,
    vms.is_initialized,
    vms.num_of_sockets,
    vms.cpu_per_socket,
    vms.threads_per_cpu,
    vms.usb_policy,
    vms.acpi_enable,
    vms.session,
    vms.num_of_cpus,
    vms.boot_sequence,
    vms.utc_diff,
    vms.client_ip,
    vms.guest_requested_memory,
    vms.time_zone,
    vms.cpu_user,
    vms.cpu_sys,
    vms.elapsed_time,
    vms.usage_network_percent,
    vms.disks_usage,
    vms.usage_mem_percent,
    vms.usage_cpu_percent,
    vms.run_on_vds_name,
    vms.cluster_cpu_name,
    vms.cluster_cpu_flags,
    vms.cluster_cpu_verb,
    tags_vm_map_view.tag_name,
    tags_vm_map_view.tag_id,
    vms.default_display_type,
    vms.iso_path,
    vms.origin,
    vms.priority,
    vms.cluster_compatibility_version,
    vms.initrd_url,
    vms.kernel_url,
    vms.kernel_params,
    vms.pause_status,
    vms.exit_status,
    vms.migration_support,
    vms.predefined_properties,
    vms.userdefined_properties,
    vms.exit_message,
    vms.min_allocated_mem,
    vms.hash,
    vms.cpu_pinning,
    vms.db_generation,
    vms.host_cpu_flags,
    image_storage_domain_map.storage_domain_id AS storage_id,
    vms.quota_id,
    vms.quota_name,
    vms.quota_enforcement_type,
    vms.tunnel_migration,
    vms.vnc_keyboard_layout,
    vms.is_run_and_pause,
    vms.created_by_user_id,
    vms.last_watchdog_event,
    vms.last_watchdog_action,
    vms.is_run_once,
    vms.volatile_run,
    vms.vm_fqdn,
    vms.cpu_name,
    vms.emulated_machine,
    vms.custom_emulated_machine,
    vms.bios_type,
    vms.cluster_bios_type,
    vms.custom_cpu_name,
    vms.vm_pool_spice_proxy,
    vms.trusted_service,
    vms.transparent_hugepages,
    vms.cluster_spice_proxy,
    vms.instance_type_id,
    vms.image_type_id,
    vms.architecture,
    vms.original_template_id,
    vms.original_template_name,
    vms.migration_downtime,
    vms.template_version_number,
    vms.current_cd,
    vms.reason,
    vms.serial_number_policy,
    vms.custom_serial_number,
    vms.exit_reason,
    vms.is_boot_menu_enabled,
    vms.guest_cpu_count,
    vms.next_run_config_exists,
    vms.is_previewing_snapshot,
    vms.changed_fields,
    vms.is_spice_file_transfer_enabled,
    vms.is_spice_copy_paste_enabled,
    vms.cpu_profile_id,
    vms.is_auto_converge,
    vms.is_migrate_compressed,
    vms.is_migrate_encrypted,
    vms.spice_port,
    vms.spice_tls_port,
    vms.spice_ip,
    vms.vnc_port,
    vms.vnc_ip,
    vms.ovirt_guest_agent_status,
    vms.qemu_guest_agent_status,
    vms.guest_mem_buffered,
    vms.guest_mem_cached,
    vms.small_icon_id,
    vms.large_icon_id,
    vms.migration_policy_id,
    vms.provider_id,
    vms.console_disconnect_action,
    vms.resume_behavior,
    vms.guest_timezone_offset,
    vms.guest_timezone_name,
    vms.guestos_arch,
    vms.guestos_codename,
    vms.guestos_distribution,
    vms.guestos_kernel_version,
    vms.guestos_type,
    vms.guestos_version,
    vms.custom_compatibility_version,
    vms.guest_containers,
    vms.has_illegal_images,
    vms.multi_queues_enabled,
    vms.virtio_scsi_multi_queues,
    vms.use_tsc_frequency,
    vms.namespace,
    vms.balloon_enabled,
    vms.console_disconnect_action_delay,
    vms.cpu_pinning_policy,
    vms.current_cpu_pinning,
    vms.current_sockets,
    vms.current_cores,
    vms.current_threads,
    vms.current_numa_pinning,
    vms.parallel_migrations
   FROM ((((public.vms
     LEFT JOIN public.tags_vm_map_view ON ((vms.vm_guid = tags_vm_map_view.vm_id)))
     LEFT JOIN public.vm_device ON ((vm_device.vm_id = vms.vm_guid)))
     LEFT JOIN public.images ON ((images.image_group_id = vm_device.device_id)))
     LEFT JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = images.image_guid)))
  WHERE ((((vm_device.device)::text = 'disk'::text) AND ((images.active IS NULL) OR (images.active = true))) OR (NOT (vms.vm_guid IN ( SELECT DISTINCT vm_device_1.vm_id
           FROM public.vm_device vm_device_1
          WHERE ((vm_device_1.device)::text = 'disk'::text)))));


ALTER TABLE public.vms_with_tags OWNER TO engine;

--
-- Name: failed_logins id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.failed_logins ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.failed_logins_id_seq'::regclass);


--
-- Name: group_attributes id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_attributes ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.group_attributes_id_seq'::regclass);


--
-- Name: group_groups id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_groups ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.group_groups_id_seq'::regclass);


--
-- Name: groups id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.groups ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.groups_id_seq'::regclass);


--
-- Name: settings id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.settings ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.settings_id_seq'::regclass);


--
-- Name: user_attributes id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_attributes ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.user_attributes_id_seq'::regclass);


--
-- Name: user_groups id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_groups ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.user_groups_id_seq'::regclass);


--
-- Name: user_password_history id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_password_history ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.user_password_history_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.users ALTER COLUMN id SET DEFAULT nextval('aaa_jdbc.users_id_seq'::regclass);


--
-- Name: failed_logins failed_logins_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.failed_logins
    ADD CONSTRAINT failed_logins_pkey PRIMARY KEY (id);


--
-- Name: failed_logins failed_logins_user_id_minute_start_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.failed_logins
    ADD CONSTRAINT failed_logins_user_id_minute_start_key UNIQUE (user_id, minute_start);


--
-- Name: group_attributes group_attributes_group_id_name_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_attributes
    ADD CONSTRAINT group_attributes_group_id_name_key UNIQUE (group_id, name);


--
-- Name: group_attributes group_attributes_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_attributes
    ADD CONSTRAINT group_attributes_pkey PRIMARY KEY (id);


--
-- Name: group_groups group_groups_group_id_in_group_id_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_groups
    ADD CONSTRAINT group_groups_group_id_in_group_id_key UNIQUE (group_id, in_group_id);


--
-- Name: group_groups group_groups_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_groups
    ADD CONSTRAINT group_groups_pkey PRIMARY KEY (id);


--
-- Name: groups groups_name_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.groups
    ADD CONSTRAINT groups_name_key UNIQUE (name);


--
-- Name: groups groups_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.groups
    ADD CONSTRAINT groups_pkey PRIMARY KEY (id);


--
-- Name: groups groups_uuid_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.groups
    ADD CONSTRAINT groups_uuid_key UNIQUE (uuid);


--
-- Name: schema_version schema_version_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.schema_version
    ADD CONSTRAINT schema_version_pkey PRIMARY KEY (id);


--
-- Name: settings settings_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.settings
    ADD CONSTRAINT settings_pkey PRIMARY KEY (id);


--
-- Name: settings settings_uuid_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.settings
    ADD CONSTRAINT settings_uuid_key UNIQUE (uuid);


--
-- Name: user_attributes user_attributes_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_attributes
    ADD CONSTRAINT user_attributes_pkey PRIMARY KEY (id);


--
-- Name: user_attributes user_attributes_user_id_name_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_attributes
    ADD CONSTRAINT user_attributes_user_id_name_key UNIQUE (user_id, name);


--
-- Name: user_groups user_groups_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_groups
    ADD CONSTRAINT user_groups_pkey PRIMARY KEY (id);


--
-- Name: user_groups user_groups_user_id_in_group_id_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_groups
    ADD CONSTRAINT user_groups_user_id_in_group_id_key UNIQUE (user_id, in_group_id);


--
-- Name: user_password_history user_password_history_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_password_history
    ADD CONSTRAINT user_password_history_pkey PRIMARY KEY (id);


--
-- Name: users users_name_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.users
    ADD CONSTRAINT users_name_key UNIQUE (name);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: users users_uuid_key; Type: CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.users
    ADD CONSTRAINT users_uuid_key UNIQUE (uuid);


--
-- Name: affinity_groups affinity_group_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_groups
    ADD CONSTRAINT affinity_group_pk PRIMARY KEY (id);


--
-- Name: cluster_policies cluster_policy_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster_policies
    ADD CONSTRAINT cluster_policy_pk PRIMARY KEY (id);


--
-- Name: command_assoc_entities command_assoc_entities_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.command_assoc_entities
    ADD CONSTRAINT command_assoc_entities_pkey PRIMARY KEY (command_id, entity_id);


--
-- Name: cpu_profiles cpu_profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cpu_profiles
    ADD CONSTRAINT cpu_profiles_pkey PRIMARY KEY (id);


--
-- Name: disk_lun_map disk_lun_map_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_lun_map
    ADD CONSTRAINT disk_lun_map_pk PRIMARY KEY (disk_id, lun_id);


--
-- Name: disk_profiles disk_profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_profiles
    ADD CONSTRAINT disk_profiles_pkey PRIMARY KEY (id);


--
-- Name: dns_resolver_configuration dns_resolver_configuration_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.dns_resolver_configuration
    ADD CONSTRAINT dns_resolver_configuration_pkey PRIMARY KEY (id);


--
-- Name: engine_backup_log engine_backup_log_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.engine_backup_log
    ADD CONSTRAINT engine_backup_log_pkey PRIMARY KEY (scope, done_at);


--
-- Name: fence_agents fence_agent_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.fence_agents
    ADD CONSTRAINT fence_agent_pk PRIMARY KEY (id);


--
-- Name: gluster_scheduler_job_details gluster_scheduler_job_details_job_id_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_scheduler_job_details
    ADD CONSTRAINT gluster_scheduler_job_details_job_id_key UNIQUE (job_id);


--
-- Name: gluster_volumes gluster_volumes_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volumes
    ADD CONSTRAINT gluster_volumes_name_unique UNIQUE (cluster_id, vol_name);


--
-- Name: ad_groups groups_domain_external_id_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.ad_groups
    ADD CONSTRAINT groups_domain_external_id_unique UNIQUE (domain, external_id);


--
-- Name: host_device host_device_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_device
    ADD CONSTRAINT host_device_pk PRIMARY KEY (host_id, device_name);


--
-- Name: gluster_volume_bricks idx_gluster_volume_bricks_volume_server_brickdir; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_bricks
    ADD CONSTRAINT idx_gluster_volume_bricks_volume_server_brickdir UNIQUE (volume_id, server_id, brick_dir);


--
-- Name: gluster_volume_options idx_gluster_volume_options_volume_id_option_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_options
    ADD CONSTRAINT idx_gluster_volume_options_volume_id_option_key UNIQUE (volume_id, option_key);


--
-- Name: labels label_name; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.labels
    ADD CONSTRAINT label_name UNIQUE (label_name);


--
-- Name: mac_pools mac_pools_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.mac_pools
    ADD CONSTRAINT mac_pools_pkey PRIMARY KEY (id);


--
-- Name: name_server name_server_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.name_server
    ADD CONSTRAINT name_server_pkey PRIMARY KEY (dns_resolver_configuration_id, address);


--
-- Name: network_attachments network_attachments_network_id_nic_id_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_attachments
    ADD CONSTRAINT network_attachments_network_id_nic_id_key UNIQUE (network_id, nic_id);


--
-- Name: network_filter network_filter_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_filter
    ADD CONSTRAINT network_filter_pkey PRIMARY KEY (filter_name);


--
-- Name: network network_unique_external_network; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT network_unique_external_network UNIQUE (storage_pool_id, provider_network_provider_id, provider_network_external_id);


--
-- Name: ad_groups pk_ad_group_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.ad_groups
    ADD CONSTRAINT pk_ad_group_id PRIMARY KEY (id);


--
-- Name: async_tasks pk_async_tasks; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.async_tasks
    ADD CONSTRAINT pk_async_tasks PRIMARY KEY (task_id);


--
-- Name: audit_log pk_audit_log; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT pk_audit_log PRIMARY KEY (audit_log_id);


--
-- Name: bookmarks pk_bookmarks; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.bookmarks
    ADD CONSTRAINT pk_bookmarks PRIMARY KEY (bookmark_id);


--
-- Name: cinder_storage pk_cinder_storage; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cinder_storage
    ADD CONSTRAINT pk_cinder_storage PRIMARY KEY (storage_domain_id);


--
-- Name: cluster pk_cluster; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster
    ADD CONSTRAINT pk_cluster PRIMARY KEY (cluster_id);


--
-- Name: cluster_features pk_cluster_features; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster_features
    ADD CONSTRAINT pk_cluster_features PRIMARY KEY (feature_id);


--
-- Name: command_entities pk_command_entities; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.command_entities
    ADD CONSTRAINT pk_command_entities PRIMARY KEY (command_id);


--
-- Name: gluster_config_master pk_config_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_config_master
    ADD CONSTRAINT pk_config_key PRIMARY KEY (config_key);


--
-- Name: custom_actions pk_custom_actions; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.custom_actions
    ADD CONSTRAINT pk_custom_actions PRIMARY KEY (action_name, tab);


--
-- Name: unregistered_disks pk_disk_id_storage_domain_unregistered; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_disks
    ADD CONSTRAINT pk_disk_id_storage_domain_unregistered PRIMARY KEY (disk_id, storage_domain_id);


--
-- Name: disk_image_dynamic pk_disk_image_dynamic; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_image_dynamic
    ADD CONSTRAINT pk_disk_image_dynamic PRIMARY KEY (image_id);


--
-- Name: disk_vm_element pk_disk_vm_element; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_vm_element
    ADD CONSTRAINT pk_disk_vm_element PRIMARY KEY (vm_id, disk_id);


--
-- Name: base_disks pk_disks; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.base_disks
    ADD CONSTRAINT pk_disks PRIMARY KEY (disk_id);


--
-- Name: engine_sessions pk_engine_session; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.engine_sessions
    ADD CONSTRAINT pk_engine_session PRIMARY KEY (id);


--
-- Name: unregistered_ovf_of_entities pk_entity_guid_storage_domain_unregistered; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_ovf_of_entities
    ADD CONSTRAINT pk_entity_guid_storage_domain_unregistered PRIMARY KEY (entity_guid, storage_domain_id);


--
-- Name: event_map pk_event_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.event_map
    ADD CONSTRAINT pk_event_map PRIMARY KEY (event_up_name);


--
-- Name: external_leases pk_external_lease; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.external_leases
    ADD CONSTRAINT pk_external_lease PRIMARY KEY (lease_id);


--
-- Name: external_variable pk_external_variable; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.external_variable
    ADD CONSTRAINT pk_external_variable PRIMARY KEY (var_name);


--
-- Name: gluster_cluster_services pk_gluster_cluster_services; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_cluster_services
    ADD CONSTRAINT pk_gluster_cluster_services PRIMARY KEY (cluster_id, service_type);


--
-- Name: gluster_georep_config pk_gluster_georep_config; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_config
    ADD CONSTRAINT pk_gluster_georep_config PRIMARY KEY (session_id, config_key);


--
-- Name: gluster_georep_session pk_gluster_georep_session; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_session
    ADD CONSTRAINT pk_gluster_georep_session PRIMARY KEY (session_id);


--
-- Name: gluster_georep_session_details pk_gluster_georep_session_details; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_session_details
    ADD CONSTRAINT pk_gluster_georep_session_details PRIMARY KEY (session_id, master_brick_id);


--
-- Name: gluster_global_volume_options pk_gluster_global_volume_options; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_global_volume_options
    ADD CONSTRAINT pk_gluster_global_volume_options PRIMARY KEY (id);


--
-- Name: gluster_hooks pk_gluster_hooks; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_hooks
    ADD CONSTRAINT pk_gluster_hooks PRIMARY KEY (id);


--
-- Name: gluster_scheduler_job_details pk_gluster_scheduler_job_details; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_scheduler_job_details
    ADD CONSTRAINT pk_gluster_scheduler_job_details PRIMARY KEY (job_id);


--
-- Name: gluster_scheduler_job_params pk_gluster_scheduler_job_params; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_scheduler_job_params
    ADD CONSTRAINT pk_gluster_scheduler_job_params PRIMARY KEY (id);


--
-- Name: gluster_server pk_gluster_server; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server
    ADD CONSTRAINT pk_gluster_server PRIMARY KEY (server_id);


--
-- Name: gluster_server_services pk_gluster_server_services; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_services
    ADD CONSTRAINT pk_gluster_server_services PRIMARY KEY (id);


--
-- Name: gluster_service_types pk_gluster_service_types; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_service_types
    ADD CONSTRAINT pk_gluster_service_types PRIMARY KEY (service_type);


--
-- Name: gluster_services pk_gluster_services; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_services
    ADD CONSTRAINT pk_gluster_services PRIMARY KEY (id);


--
-- Name: gluster_volume_access_protocols pk_gluster_volume_access_protocols; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_access_protocols
    ADD CONSTRAINT pk_gluster_volume_access_protocols PRIMARY KEY (volume_id, access_protocol);


--
-- Name: gluster_volume_brick_details pk_gluster_volume_brick_details; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_brick_details
    ADD CONSTRAINT pk_gluster_volume_brick_details PRIMARY KEY (brick_id);


--
-- Name: gluster_volume_bricks pk_gluster_volume_bricks; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_bricks
    ADD CONSTRAINT pk_gluster_volume_bricks PRIMARY KEY (id);


--
-- Name: gluster_volume_details pk_gluster_volume_details; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_details
    ADD CONSTRAINT pk_gluster_volume_details PRIMARY KEY (volume_id);


--
-- Name: gluster_volume_options pk_gluster_volume_options; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_options
    ADD CONSTRAINT pk_gluster_volume_options PRIMARY KEY (id);


--
-- Name: gluster_volume_transport_types pk_gluster_volume_transport_types; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_transport_types
    ADD CONSTRAINT pk_gluster_volume_transport_types PRIMARY KEY (volume_id, transport_type);


--
-- Name: gluster_volumes pk_gluster_volumes; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volumes
    ADD CONSTRAINT pk_gluster_volumes PRIMARY KEY (id);


--
-- Name: business_entity_snapshot pk_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.business_entity_snapshot
    ADD CONSTRAINT pk_id PRIMARY KEY (id);


--
-- Name: image_storage_domain_map pk_image_storage_domain_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_storage_domain_map
    ADD CONSTRAINT pk_image_storage_domain_map PRIMARY KEY (image_id, storage_domain_id);


--
-- Name: image_transfers pk_image_transfers; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_transfers
    ADD CONSTRAINT pk_image_transfers PRIMARY KEY (command_id);


--
-- Name: images pk_images; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.images
    ADD CONSTRAINT pk_images PRIMARY KEY (image_guid);


--
-- Name: iscsi_bonds pk_iscsi_bonds; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds
    ADD CONSTRAINT pk_iscsi_bonds PRIMARY KEY (id);


--
-- Name: iscsi_bonds_networks_map pk_iscsi_bonds_networks_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_networks_map
    ADD CONSTRAINT pk_iscsi_bonds_networks_map PRIMARY KEY (iscsi_bond_id, network_id);


--
-- Name: iscsi_bonds_storage_connections_map pk_iscsi_bonds_storage_connections_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_storage_connections_map
    ADD CONSTRAINT pk_iscsi_bonds_storage_connections_map PRIMARY KEY (iscsi_bond_id, connection_id);


--
-- Name: job pk_jobs; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.job
    ADD CONSTRAINT pk_jobs PRIMARY KEY (job_id);


--
-- Name: job_subject_entity pk_jobs_subject_entity; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.job_subject_entity
    ADD CONSTRAINT pk_jobs_subject_entity PRIMARY KEY (job_id, entity_id);


--
-- Name: labels pk_labels_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.labels
    ADD CONSTRAINT pk_labels_id PRIMARY KEY (label_id);


--
-- Name: lun_storage_server_connection_map pk_lun_storage_server_connection_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.lun_storage_server_connection_map
    ADD CONSTRAINT pk_lun_storage_server_connection_map PRIMARY KEY (lun_id, storage_server_connection);


--
-- Name: luns pk_luns; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.luns
    ADD CONSTRAINT pk_luns PRIMARY KEY (lun_id);


--
-- Name: network pk_network; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT pk_network PRIMARY KEY (id);


--
-- Name: network_attachments pk_network_attachments_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_attachments
    ADD CONSTRAINT pk_network_attachments_id PRIMARY KEY (id);


--
-- Name: network_cluster pk_network_cluster; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_cluster
    ADD CONSTRAINT pk_network_cluster PRIMARY KEY (network_id, cluster_id);


--
-- Name: numa_node pk_numa_node; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.numa_node
    ADD CONSTRAINT pk_numa_node PRIMARY KEY (numa_node_id);


--
-- Name: numa_node_cpu_map pk_numa_node_cpu_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.numa_node_cpu_map
    ADD CONSTRAINT pk_numa_node_cpu_map PRIMARY KEY (id);


--
-- Name: object_column_white_list pk_object_column_white_list; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.object_column_white_list
    ADD CONSTRAINT pk_object_column_white_list PRIMARY KEY (object_name, column_name);


--
-- Name: object_column_white_list_sql pk_object_column_white_list_sql; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.object_column_white_list_sql
    ADD CONSTRAINT pk_object_column_white_list_sql PRIMARY KEY (object_name);


--
-- Name: dwh_osinfo pk_os_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.dwh_osinfo
    ADD CONSTRAINT pk_os_id PRIMARY KEY (os_id);


--
-- Name: permissions pk_permissions_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT pk_permissions_id PRIMARY KEY (id);


--
-- Name: user_profiles pk_property_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.user_profiles
    ADD CONSTRAINT pk_property_id PRIMARY KEY (property_id);


--
-- Name: provider_binding_host_id pk_provider_binding_host_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.provider_binding_host_id
    ADD CONSTRAINT pk_provider_binding_host_id PRIMARY KEY (vds_id, plugin_type);


--
-- Name: qos pk_qos_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.qos
    ADD CONSTRAINT pk_qos_id PRIMARY KEY (id);


--
-- Name: quota pk_quota; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota
    ADD CONSTRAINT pk_quota PRIMARY KEY (id);


--
-- Name: quota_limitation pk_quota_limitation; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota_limitation
    ADD CONSTRAINT pk_quota_limitation PRIMARY KEY (id);


--
-- Name: repo_file_meta_data pk_repo_file_meta_data; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.repo_file_meta_data
    ADD CONSTRAINT pk_repo_file_meta_data PRIMARY KEY (repo_domain_id, repo_image_id);


--
-- Name: roles_groups pk_roles_groups; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.roles_groups
    ADD CONSTRAINT pk_roles_groups PRIMARY KEY (role_id, action_group_id);


--
-- Name: roles pk_roles_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT pk_roles_id PRIMARY KEY (id);


--
-- Name: libvirt_secrets pk_secret_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.libvirt_secrets
    ADD CONSTRAINT pk_secret_id PRIMARY KEY (secret_id);


--
-- Name: gluster_volume_snapshots pk_snapshot_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshots
    ADD CONSTRAINT pk_snapshot_id PRIMARY KEY (snapshot_id);


--
-- Name: snapshots pk_snapshots; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.snapshots
    ADD CONSTRAINT pk_snapshots PRIMARY KEY (snapshot_id);


--
-- Name: sso_clients pk_sso_clients; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.sso_clients
    ADD CONSTRAINT pk_sso_clients PRIMARY KEY (id);


--
-- Name: sso_scope_dependency pk_sso_scope_dependency; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.sso_scope_dependency
    ADD CONSTRAINT pk_sso_scope_dependency PRIMARY KEY (id);


--
-- Name: step pk_steps; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.step
    ADD CONSTRAINT pk_steps PRIMARY KEY (step_id);


--
-- Name: storage_domain_static pk_storage; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_static
    ADD CONSTRAINT pk_storage PRIMARY KEY (id);


--
-- Name: storage_device pk_storage_device; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_device
    ADD CONSTRAINT pk_storage_device PRIMARY KEY (id);


--
-- Name: storage_domain_dr pk_storage_domain_dr; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_dr
    ADD CONSTRAINT pk_storage_domain_dr PRIMARY KEY (storage_domain_id, georep_session_id);


--
-- Name: storage_domain_dynamic pk_storage_domain_dynamic; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_dynamic
    ADD CONSTRAINT pk_storage_domain_dynamic PRIMARY KEY (id);


--
-- Name: storage_pool_iso_map pk_storage_domain_pool_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_pool_iso_map
    ADD CONSTRAINT pk_storage_domain_pool_map PRIMARY KEY (storage_id, storage_pool_id);


--
-- Name: storage_pool pk_storage_pool; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_pool
    ADD CONSTRAINT pk_storage_pool PRIMARY KEY (id);


--
-- Name: storage_server_connections pk_storage_server; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_server_connections
    ADD CONSTRAINT pk_storage_server PRIMARY KEY (id);


--
-- Name: storage_server_connection_extension pk_storage_server_connection_extension; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_server_connection_extension
    ADD CONSTRAINT pk_storage_server_connection_extension PRIMARY KEY (id);


--
-- Name: supported_cluster_features pk_supported_cluster_features; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.supported_cluster_features
    ADD CONSTRAINT pk_supported_cluster_features PRIMARY KEY (cluster_id, feature_id);


--
-- Name: supported_host_features pk_supported_host_features; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.supported_host_features
    ADD CONSTRAINT pk_supported_host_features PRIMARY KEY (host_id, feature_name);


--
-- Name: tags pk_tags_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT pk_tags_id PRIMARY KEY (tag_id);


--
-- Name: tags_user_group_map pk_tags_user_group_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_group_map
    ADD CONSTRAINT pk_tags_user_group_map PRIMARY KEY (tag_id, group_id);


--
-- Name: tags_user_map pk_tags_user_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_map
    ADD CONSTRAINT pk_tags_user_map PRIMARY KEY (tag_id, user_id);


--
-- Name: tags_vds_map pk_tags_vds_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vds_map
    ADD CONSTRAINT pk_tags_vds_map PRIMARY KEY (tag_id, vds_id);


--
-- Name: tags_vm_map pk_tags_vm_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_map
    ADD CONSTRAINT pk_tags_vm_map PRIMARY KEY (tag_id, vm_id);


--
-- Name: tags_vm_pool_map pk_tags_vm_pool_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_pool_map
    ADD CONSTRAINT pk_tags_vm_pool_map PRIMARY KEY (tag_id, vm_pool_id);


--
-- Name: unregistered_disks_to_vms pk_unregistered_disks_to_vms; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_disks_to_vms
    ADD CONSTRAINT pk_unregistered_disks_to_vms PRIMARY KEY (disk_id, entity_id, storage_domain_id);


--
-- Name: users pk_users; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT pk_users PRIMARY KEY (user_id);


--
-- Name: vdc_db_log pk_vdc_db_log; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vdc_db_log
    ADD CONSTRAINT pk_vdc_db_log PRIMARY KEY (error_id);


--
-- Name: vdc_options pk_vdc_options; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vdc_options
    ADD CONSTRAINT pk_vdc_options PRIMARY KEY (option_id);


--
-- Name: vds_dynamic pk_vds_dynamic; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_dynamic
    ADD CONSTRAINT pk_vds_dynamic PRIMARY KEY (vds_id);


--
-- Name: vds_interface pk_vds_interface; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface
    ADD CONSTRAINT pk_vds_interface PRIMARY KEY (id);


--
-- Name: vds_interface_statistics pk_vds_interface_statistics; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface_statistics
    ADD CONSTRAINT pk_vds_interface_statistics PRIMARY KEY (id);


--
-- Name: vds_kdump_status pk_vds_kdump_status; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_kdump_status
    ADD CONSTRAINT pk_vds_kdump_status PRIMARY KEY (vds_id);


--
-- Name: vds_spm_id_map pk_vds_spm_id_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_spm_id_map
    ADD CONSTRAINT pk_vds_spm_id_map PRIMARY KEY (storage_pool_id, vds_spm_id);


--
-- Name: vds_static pk_vds_static; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_static
    ADD CONSTRAINT pk_vds_static PRIMARY KEY (vds_id);


--
-- Name: vds_statistics pk_vds_statistics; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_statistics
    ADD CONSTRAINT pk_vds_statistics PRIMARY KEY (vds_id);


--
-- Name: vm_device pk_vm_device; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_device
    ADD CONSTRAINT pk_vm_device PRIMARY KEY (device_id, vm_id);


--
-- Name: vm_dynamic pk_vm_dynamic; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_dynamic
    ADD CONSTRAINT pk_vm_dynamic PRIMARY KEY (vm_guid);


--
-- Name: vm_icon_defaults pk_vm_icon_defaults; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_icon_defaults
    ADD CONSTRAINT pk_vm_icon_defaults PRIMARY KEY (id);


--
-- Name: vm_icons pk_vm_icons; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_icons
    ADD CONSTRAINT pk_vm_icons PRIMARY KEY (id);


--
-- Name: vm_init pk_vm_init; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_init
    ADD CONSTRAINT pk_vm_init PRIMARY KEY (vm_id);


--
-- Name: vm_interface pk_vm_interface; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface
    ADD CONSTRAINT pk_vm_interface PRIMARY KEY (id);


--
-- Name: vm_interface_filter_parameters pk_vm_interface_filter_parameters; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface_filter_parameters
    ADD CONSTRAINT pk_vm_interface_filter_parameters PRIMARY KEY (id);


--
-- Name: vm_interface_statistics pk_vm_interface_statistics; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface_statistics
    ADD CONSTRAINT pk_vm_interface_statistics PRIMARY KEY (id);


--
-- Name: vm_jobs pk_vm_jobs; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_jobs
    ADD CONSTRAINT pk_vm_jobs PRIMARY KEY (vm_job_id);


--
-- Name: vm_pool_map pk_vm_pool_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_pool_map
    ADD CONSTRAINT pk_vm_pool_map PRIMARY KEY (vm_guid);


--
-- Name: vm_pools pk_vm_pools; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_pools
    ADD CONSTRAINT pk_vm_pools PRIMARY KEY (vm_pool_id);


--
-- Name: vm_static pk_vm_static; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT pk_vm_static PRIMARY KEY (vm_guid);


--
-- Name: vm_statistics pk_vm_statistics; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_statistics
    ADD CONSTRAINT pk_vm_statistics PRIMARY KEY (vm_guid);


--
-- Name: vm_vds_numa_node_map pk_vm_vds_numa_node_map; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_vds_numa_node_map
    ADD CONSTRAINT pk_vm_vds_numa_node_map PRIMARY KEY (id);


--
-- Name: vnic_profiles pk_vnic_profiles_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vnic_profiles
    ADD CONSTRAINT pk_vnic_profiles_id PRIMARY KEY (id);


--
-- Name: gluster_volume_snapshot_schedules pk_volume_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshot_schedules
    ADD CONSTRAINT pk_volume_id PRIMARY KEY (volume_id);


--
-- Name: policy_units policy_unit_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.policy_units
    ADD CONSTRAINT policy_unit_pk PRIMARY KEY (id);


--
-- Name: providers providers_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.providers
    ADD CONSTRAINT providers_pk PRIMARY KEY (id);


--
-- Name: providers providers_unique_name; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.providers
    ADD CONSTRAINT providers_unique_name UNIQUE (name);


--
-- Name: qos qos_qos_type_name_storage_pool_id_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.qos
    ADD CONSTRAINT qos_qos_type_name_storage_pool_id_key UNIQUE (qos_type, name, storage_pool_id);


--
-- Name: quota quota_quota_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota
    ADD CONSTRAINT quota_quota_name_unique UNIQUE (storage_pool_id, quota_name);


--
-- Name: schema_version schema_version_primary_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.schema_version
    ADD CONSTRAINT schema_version_primary_key PRIMARY KEY (id);


--
-- Name: step_subject_entity step_subject_entity_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.step_subject_entity
    ADD CONSTRAINT step_subject_entity_pkey PRIMARY KEY (step_id, entity_id, entity_type);


--
-- Name: storage_domains_ovf_info storage_domains_ovf_info_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domains_ovf_info
    ADD CONSTRAINT storage_domains_ovf_info_pkey PRIMARY KEY (ovf_disk_id);


--
-- Name: storage_server_connection_extension storage_server_connection_extension_vds_id_iqn; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_server_connection_extension
    ADD CONSTRAINT storage_server_connection_extension_vds_id_iqn UNIQUE (vds_id, iqn);


--
-- Name: gluster_server_services unique_gluster_server_services_server_service; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_services
    ADD CONSTRAINT unique_gluster_server_services_server_service UNIQUE (server_id, service_id);


--
-- Name: gluster_services unique_gluster_services_type_name; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_services
    ADD CONSTRAINT unique_gluster_services_type_name UNIQUE (service_type, service_name);


--
-- Name: network_filter unique_network_filter_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_filter
    ADD CONSTRAINT unique_network_filter_id UNIQUE (filter_id);


--
-- Name: vm_icon_defaults unique_vm_icon_defaults_record; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_icon_defaults
    ADD CONSTRAINT unique_vm_icon_defaults_record UNIQUE (os_id);


--
-- Name: business_entity_snapshot uq_command_id_entity_id; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.business_entity_snapshot
    ADD CONSTRAINT uq_command_id_entity_id UNIQUE (command_id, entity_id, entity_type, snapshot_type);


--
-- Name: users users_domain_external_id_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_domain_external_id_unique UNIQUE (domain, external_id);


--
-- Name: vds_interface vds_interface_vds_id_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface
    ADD CONSTRAINT vds_interface_vds_id_name_unique UNIQUE (vds_id, name);


--
-- Name: vds_interface vds_interface_vds_id_network_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface
    ADD CONSTRAINT vds_interface_vds_id_network_name_unique UNIQUE (vds_id, network_name);


--
-- Name: vds_static vds_static_host_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_static
    ADD CONSTRAINT vds_static_host_name_unique UNIQUE (host_name, cluster_id);


--
-- Name: vds_static vds_static_vds_name_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_static
    ADD CONSTRAINT vds_static_vds_name_unique UNIQUE (vds_name, cluster_id);


--
-- Name: host_nic_vfs_config vfs_config_id_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_nic_vfs_config
    ADD CONSTRAINT vfs_config_id_pk PRIMARY KEY (id);


--
-- Name: vfs_config_labels vfs_config_labels_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vfs_config_labels
    ADD CONSTRAINT vfs_config_labels_pk PRIMARY KEY (vfs_config_id, label);


--
-- Name: vfs_config_networks vfs_config_networks_pk; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vfs_config_networks
    ADD CONSTRAINT vfs_config_networks_pk PRIMARY KEY (vfs_config_id, network_id);


--
-- Name: host_nic_vfs_config vfs_config_nic_id_unique; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_nic_vfs_config
    ADD CONSTRAINT vfs_config_nic_id_unique UNIQUE (nic_id);


--
-- Name: vm_backup_disk_map vm_backup_disk_map_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_backup_disk_map
    ADD CONSTRAINT vm_backup_disk_map_pkey PRIMARY KEY (backup_id, disk_id);


--
-- Name: vm_backups vm_backups_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_backups
    ADD CONSTRAINT vm_backups_pkey PRIMARY KEY (backup_id);


--
-- Name: vm_checkpoint_disk_map vm_checkpoint_disk_map_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_checkpoint_disk_map
    ADD CONSTRAINT vm_checkpoint_disk_map_pkey PRIMARY KEY (checkpoint_id, disk_id);


--
-- Name: vm_checkpoints vm_checkpoints_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_checkpoints
    ADD CONSTRAINT vm_checkpoints_pkey PRIMARY KEY (checkpoint_id);


--
-- Name: vm_external_data vm_external_data_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_external_data
    ADD CONSTRAINT vm_external_data_pkey PRIMARY KEY (device_id, vm_id);


--
-- Name: vm_host_pinning_map vm_host_pinning_map_vm_id_vds_id_key; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_host_pinning_map
    ADD CONSTRAINT vm_host_pinning_map_vm_id_vds_id_key UNIQUE (vm_id, vds_id);


--
-- Name: vm_nvram_data vm_nvram_data_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_nvram_data
    ADD CONSTRAINT vm_nvram_data_pkey PRIMARY KEY (vm_id);


--
-- Name: vm_ovf_generations vm_ovf_generations_pkey; Type: CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_ovf_generations
    ADD CONSTRAINT vm_ovf_generations_pkey PRIMARY KEY (vm_guid);


--
-- Name: failed_logins_index; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX failed_logins_index ON aaa_jdbc.failed_logins USING btree (minute_start);


--
-- Name: idx_failed_logins_user_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_failed_logins_user_id ON aaa_jdbc.failed_logins USING btree (user_id);


--
-- Name: idx_group_attributes_group_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_group_attributes_group_id ON aaa_jdbc.group_attributes USING btree (group_id);


--
-- Name: idx_group_groups_group_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_group_groups_group_id ON aaa_jdbc.group_groups USING btree (group_id);


--
-- Name: idx_group_groups_in_group_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_group_groups_in_group_id ON aaa_jdbc.group_groups USING btree (in_group_id);


--
-- Name: idx_user_attributes_user_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_user_attributes_user_id ON aaa_jdbc.user_attributes USING btree (user_id);


--
-- Name: idx_user_groups_in_group_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_user_groups_in_group_id ON aaa_jdbc.user_groups USING btree (in_group_id);


--
-- Name: idx_user_groups_user_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_user_groups_user_id ON aaa_jdbc.user_groups USING btree (user_id);


--
-- Name: idx_user_password_history_user_id; Type: INDEX; Schema: aaa_jdbc; Owner: engine
--

CREATE INDEX idx_user_password_history_user_id ON aaa_jdbc.user_password_history USING btree (user_id);


--
-- Name: audit_log_origin_custom_event_id_idx; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX audit_log_origin_custom_event_id_idx ON public.audit_log USING btree (origin, custom_event_id) WHERE ((origin)::text !~~* 'ovirt'::text);


--
-- Name: idx_ad_groups_name_domain; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_ad_groups_name_domain ON public.ad_groups USING btree (name, domain);


--
-- Name: idx_affinity_group_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_affinity_group_cluster_id ON public.affinity_groups USING btree (cluster_id);


--
-- Name: idx_affinity_group_members_affinity_group_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_affinity_group_members_affinity_group_id ON public.affinity_group_members USING btree (affinity_group_id);


--
-- Name: idx_affinity_group_members_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_affinity_group_members_vds_id ON public.affinity_group_members USING btree (vds_id);


--
-- Name: idx_affinity_group_members_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_affinity_group_members_vm_id ON public.affinity_group_members USING btree (vm_id);


--
-- Name: idx_async_tasks_entities_async_task_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_async_tasks_entities_async_task_id ON public.async_tasks_entities USING btree (async_task_id);


--
-- Name: idx_audit_correlation_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_correlation_id ON public.audit_log USING btree (correlation_id);


--
-- Name: idx_audit_log_deleted; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_deleted ON public.audit_log USING btree (deleted);


--
-- Name: idx_audit_log_gluster_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_gluster_volume_id ON public.audit_log USING btree (gluster_volume_id) WHERE (gluster_volume_id IS NOT NULL);


--
-- Name: idx_audit_log_job_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_job_id ON public.audit_log USING btree (job_id);


--
-- Name: idx_audit_log_log_time; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_log_time ON public.audit_log USING btree (log_time);


--
-- Name: idx_audit_log_severity; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_severity ON public.audit_log USING btree (severity);


--
-- Name: idx_audit_log_storage_domain_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_storage_domain_name ON public.audit_log USING btree (storage_domain_name);


--
-- Name: idx_audit_log_storage_pool_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_storage_pool_name ON public.audit_log USING btree (storage_pool_name);


--
-- Name: idx_audit_log_type_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_type_name ON public.audit_log USING btree (log_type, log_type_name);


--
-- Name: idx_audit_log_user_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_user_name ON public.audit_log USING btree (user_name);


--
-- Name: idx_audit_log_vds_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_vds_name ON public.audit_log USING btree (vds_name);


--
-- Name: idx_audit_log_vm_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_vm_name ON public.audit_log USING btree (vm_name);


--
-- Name: idx_audit_log_vm_template_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_audit_log_vm_template_name ON public.audit_log USING btree (vm_template_name);


--
-- Name: idx_base_disks_disk_alias; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_base_disks_disk_alias ON public.base_disks USING btree (disk_alias);


--
-- Name: idx_business_entity_snapshot_command_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_business_entity_snapshot_command_id ON public.business_entity_snapshot USING btree (command_id);


--
-- Name: idx_cluster_cluster_policy_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_cluster_policy_id ON public.cluster USING btree (cluster_policy_id);


--
-- Name: idx_cluster_default_network_provider_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_default_network_provider_id ON public.cluster USING btree (default_network_provider_id);


--
-- Name: idx_cluster_features_version_and_category; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_features_version_and_category ON public.cluster_features USING btree (category, version);


--
-- Name: idx_cluster_mac_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_mac_pool_id ON public.cluster USING btree (mac_pool_id);


--
-- Name: idx_cluster_policy_units_cluster_policy_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_policy_units_cluster_policy_id ON public.cluster_policy_units USING btree (cluster_policy_id);


--
-- Name: idx_cluster_policy_units_policy_unit_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_policy_units_policy_unit_id ON public.cluster_policy_units USING btree (policy_unit_id);


--
-- Name: idx_cluster_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cluster_storage_pool_id ON public.cluster USING btree (storage_pool_id);


--
-- Name: idx_combined_ad_role_object; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_combined_ad_role_object ON public.permissions USING btree (ad_element_id, role_id, object_id);


--
-- Name: idx_command_assoc_entities_command_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_command_assoc_entities_command_id ON public.command_assoc_entities USING btree (command_id);


--
-- Name: idx_cpu_profiles_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cpu_profiles_cluster_id ON public.cpu_profiles USING btree (cluster_id);


--
-- Name: idx_cpu_profiles_create_date; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cpu_profiles_create_date ON public.cpu_profiles USING btree (_create_date);


--
-- Name: idx_cpu_profiles_qos_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_cpu_profiles_qos_id ON public.cpu_profiles USING btree (qos_id);


--
-- Name: idx_disk_content_type; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_content_type ON public.base_disks USING btree (disk_content_type);


--
-- Name: idx_disk_lun_map_disk_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_lun_map_disk_id ON public.disk_lun_map USING btree (disk_id);


--
-- Name: idx_disk_lun_map_lun_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_lun_map_lun_id ON public.disk_lun_map USING btree (lun_id);


--
-- Name: idx_disk_profiles_qos_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_profiles_qos_id ON public.disk_profiles USING btree (qos_id);


--
-- Name: idx_disk_profiles_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_profiles_storage_domain_id ON public.disk_profiles USING btree (storage_domain_id);


--
-- Name: idx_disk_vm_element_disk_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_vm_element_disk_id ON public.disk_vm_element USING btree (disk_id);


--
-- Name: idx_disk_vm_element_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_disk_vm_element_vm_id ON public.disk_vm_element USING btree (vm_id);


--
-- Name: idx_engine_session_session_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_engine_session_session_id ON public.engine_sessions USING btree (engine_session_id);


--
-- Name: idx_event_notification_hist; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_event_notification_hist ON public.event_notification_hist USING btree (audit_log_id);


--
-- Name: idx_event_subscriber_subscriber_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_event_subscriber_subscriber_id ON public.event_subscriber USING btree (subscriber_id);


--
-- Name: idx_fence_agents_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_fence_agents_vds_id ON public.fence_agents USING btree (vds_id);


--
-- Name: idx_georep_slave_host_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_georep_slave_host_name ON public.gluster_georep_session USING btree (slave_host_name);


--
-- Name: idx_georep_slave_volume_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_georep_slave_volume_name ON public.gluster_georep_session USING btree (slave_volume_name);


--
-- Name: idx_gluster_bricks_task_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_bricks_task_id ON public.gluster_volume_bricks USING btree (task_id);


--
-- Name: idx_gluster_cluster_services_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_cluster_services_cluster_id ON public.gluster_cluster_services USING btree (cluster_id);


--
-- Name: idx_gluster_cluster_services_service_type; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_cluster_services_service_type ON public.gluster_cluster_services USING btree (service_type);


--
-- Name: idx_gluster_georep_config_session_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_georep_config_session_id ON public.gluster_georep_config USING btree (session_id);


--
-- Name: idx_gluster_georep_session_details_master_brick_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_georep_session_details_master_brick_id ON public.gluster_georep_session_details USING btree (master_brick_id);


--
-- Name: idx_gluster_georep_session_details_session_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_georep_session_details_session_id ON public.gluster_georep_session_details USING btree (session_id);


--
-- Name: idx_gluster_georep_session_master_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_georep_session_master_volume_id ON public.gluster_georep_session USING btree (master_volume_id);


--
-- Name: idx_gluster_georep_session_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_georep_session_unique ON public.gluster_georep_session USING btree (master_volume_id, session_key);


--
-- Name: idx_gluster_hooks_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_hooks_cluster_id ON public.gluster_hooks USING btree (cluster_id);


--
-- Name: idx_gluster_hooks_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_hooks_unique ON public.gluster_hooks USING btree (cluster_id, gluster_command, stage, name);


--
-- Name: idx_gluster_server_hooks_hook_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_server_hooks_hook_id ON public.gluster_server_hooks USING btree (hook_id);


--
-- Name: idx_gluster_server_hooks_server_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_server_hooks_server_id ON public.gluster_server_hooks USING btree (server_id);


--
-- Name: idx_gluster_server_hooks_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_server_hooks_unique ON public.gluster_server_hooks USING btree (hook_id, server_id);


--
-- Name: idx_gluster_server_services_server_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_server_services_server_id ON public.gluster_server_services USING btree (server_id);


--
-- Name: idx_gluster_server_services_service_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_server_services_service_id ON public.gluster_server_services USING btree (service_id);


--
-- Name: idx_gluster_server_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_server_unique ON public.gluster_server USING btree (server_id, gluster_server_uuid);


--
-- Name: idx_gluster_services_service_type; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_services_service_type ON public.gluster_services USING btree (service_type);


--
-- Name: idx_gluster_volume_access_protocols_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_access_protocols_volume_id ON public.gluster_volume_access_protocols USING btree (volume_id);


--
-- Name: idx_gluster_volume_bricks_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_bricks_network_id ON public.gluster_volume_bricks USING btree (network_id);


--
-- Name: idx_gluster_volume_bricks_server_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_bricks_server_id ON public.gluster_volume_bricks USING btree (server_id);


--
-- Name: idx_gluster_volume_bricks_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_bricks_volume_id ON public.gluster_volume_bricks USING btree (volume_id);


--
-- Name: idx_gluster_volume_options_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_options_volume_id ON public.gluster_volume_options USING btree (volume_id);


--
-- Name: idx_gluster_volume_snapshot_config_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_snapshot_config_cluster_id ON public.gluster_volume_snapshot_config USING btree (cluster_id);


--
-- Name: idx_gluster_volume_snapshot_config_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_volume_snapshot_config_unique ON public.gluster_volume_snapshot_config USING btree (cluster_id, volume_id, param_name);


--
-- Name: idx_gluster_volume_snapshot_config_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_snapshot_config_volume_id ON public.gluster_volume_snapshot_config USING btree (volume_id);


--
-- Name: idx_gluster_volume_snapshots_unique; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_gluster_volume_snapshots_unique ON public.gluster_volume_snapshots USING btree (volume_id, snapshot_name);


--
-- Name: idx_gluster_volume_snapshots_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_snapshots_volume_id ON public.gluster_volume_snapshots USING btree (volume_id);


--
-- Name: idx_gluster_volume_transport_types_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volume_transport_types_volume_id ON public.gluster_volume_transport_types USING btree (volume_id);


--
-- Name: idx_gluster_volumes_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_gluster_volumes_cluster_id ON public.gluster_volumes USING btree (cluster_id);


--
-- Name: idx_host_device_host_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_host_device_host_id ON public.host_device USING btree (host_id);


--
-- Name: idx_host_device_host_id_parent_device_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_host_device_host_id_parent_device_name ON public.host_device USING btree (host_id, parent_device_name);


--
-- Name: idx_host_device_host_id_physfn; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_host_device_host_id_physfn ON public.host_device USING btree (host_id, physfn);


--
-- Name: idx_host_device_physfn_host_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_host_device_physfn_host_id ON public.host_device USING btree (physfn, host_id);


--
-- Name: idx_host_device_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_host_device_vm_id ON public.host_device USING btree (vm_id);


--
-- Name: idx_image_storage_domain_map_image_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_image_storage_domain_map_image_id ON public.image_storage_domain_map USING btree (image_id);


--
-- Name: idx_image_storage_domain_map_profile_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_image_storage_domain_map_profile_id ON public.image_storage_domain_map USING btree (disk_profile_id);


--
-- Name: idx_image_storage_domain_map_quota_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_image_storage_domain_map_quota_id ON public.image_storage_domain_map USING btree (quota_id);


--
-- Name: idx_image_storage_domain_map_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_image_storage_domain_map_storage_domain_id ON public.image_storage_domain_map USING btree (storage_domain_id);


--
-- Name: idx_image_transfers_disk_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_image_transfers_disk_id ON public.image_transfers USING btree (disk_id);


--
-- Name: idx_images_images_group_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_images_images_group_id ON public.images USING btree (image_group_id);


--
-- Name: idx_images_it_guid; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_images_it_guid ON public.images USING btree (it_guid);


--
-- Name: idx_iscsi_bonds_networks_map_iscsi_bond_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_iscsi_bonds_networks_map_iscsi_bond_id ON public.iscsi_bonds_networks_map USING btree (iscsi_bond_id);


--
-- Name: idx_iscsi_bonds_networks_map_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_iscsi_bonds_networks_map_network_id ON public.iscsi_bonds_networks_map USING btree (network_id);


--
-- Name: idx_iscsi_bonds_storage_connections_map_connection_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_iscsi_bonds_storage_connections_map_connection_id ON public.iscsi_bonds_storage_connections_map USING btree (connection_id);


--
-- Name: idx_iscsi_bonds_storage_connections_map_iscsi_bond_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_iscsi_bonds_storage_connections_map_iscsi_bond_id ON public.iscsi_bonds_storage_connections_map USING btree (iscsi_bond_id);


--
-- Name: idx_iscsi_bonds_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_iscsi_bonds_storage_pool_id ON public.iscsi_bonds USING btree (storage_pool_id);


--
-- Name: idx_job_engine_session_seq_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_job_engine_session_seq_id ON public.job USING btree (engine_session_seq_id);


--
-- Name: idx_job_start_time; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_job_start_time ON public.job USING btree (start_time);


--
-- Name: idx_job_subject_entity_entity_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_job_subject_entity_entity_id ON public.job_subject_entity USING btree (entity_id);


--
-- Name: idx_job_subject_entity_job_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_job_subject_entity_job_id ON public.job_subject_entity USING btree (job_id);


--
-- Name: idx_labels_map_label_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_labels_map_label_id ON public.labels_map USING btree (label_id);


--
-- Name: idx_labels_map_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_labels_map_vds_id ON public.labels_map USING btree (vds_id);


--
-- Name: idx_labels_map_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_labels_map_vm_id ON public.labels_map USING btree (vm_id);


--
-- Name: idx_libvirt_secrets_provider_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_libvirt_secrets_provider_id ON public.libvirt_secrets USING btree (provider_id);


--
-- Name: idx_lun_storage_server_connection_map_lun_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_lun_storage_server_connection_map_lun_id ON public.lun_storage_server_connection_map USING btree (lun_id);


--
-- Name: idx_lun_storage_server_connection_map_storage_server_connection; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_lun_storage_server_connection_map_storage_server_connection ON public.lun_storage_server_connection_map USING btree (storage_server_connection);


--
-- Name: idx_mac_pool_ranges_mac_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_mac_pool_ranges_mac_pool_id ON public.mac_pool_ranges USING btree (mac_pool_id);


--
-- Name: idx_name_server_dns_resolver_configuration_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_name_server_dns_resolver_configuration_id ON public.name_server USING btree (dns_resolver_configuration_id);


--
-- Name: idx_network_attachments_dns_resolver_configuration_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_attachments_dns_resolver_configuration_id ON public.network_attachments USING btree (dns_resolver_configuration_id);


--
-- Name: idx_network_attachments_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_attachments_network_id ON public.network_attachments USING btree (network_id);


--
-- Name: idx_network_attachments_nic_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_attachments_nic_id ON public.network_attachments USING btree (nic_id);


--
-- Name: idx_network_cluster_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_cluster_cluster_id ON public.network_cluster USING btree (cluster_id);


--
-- Name: idx_network_cluster_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_cluster_network_id ON public.network_cluster USING btree (network_id);


--
-- Name: idx_network_dns_resolver_configuration_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_dns_resolver_configuration_id ON public.network USING btree (dns_resolver_configuration_id);


--
-- Name: idx_network_external_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_external_id ON public.network USING btree (provider_network_external_id) WHERE (provider_network_external_id IS NOT NULL);


--
-- Name: idx_network_provider_network_provider_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_provider_network_provider_id ON public.network USING btree (provider_network_provider_id);


--
-- Name: idx_network_provider_physical_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_provider_physical_network_id ON public.network USING btree (provider_physical_network_id);


--
-- Name: idx_network_qos_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_qos_id ON public.network USING btree (qos_id);


--
-- Name: idx_network_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_storage_pool_id ON public.network USING btree (storage_pool_id);


--
-- Name: idx_network_vdsm_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_network_vdsm_name ON public.network USING btree (vdsm_name);


--
-- Name: idx_numa_node_cpu_map_numa_node_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_numa_node_cpu_map_numa_node_id ON public.numa_node_cpu_map USING btree (numa_node_id);


--
-- Name: idx_numa_node_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_numa_node_vds_id ON public.numa_node USING btree (vds_id);


--
-- Name: idx_numa_node_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_numa_node_vm_id ON public.numa_node USING btree (vm_id);


--
-- Name: idx_permissions_ad_element_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_permissions_ad_element_id ON public.permissions USING btree (ad_element_id);


--
-- Name: idx_permissions_object_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_permissions_object_id ON public.permissions USING btree (object_id);


--
-- Name: idx_permissions_role_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_permissions_role_id ON public.permissions USING btree (role_id);


--
-- Name: idx_provider_binding_host_id_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_provider_binding_host_id_vds_id ON public.provider_binding_host_id USING btree (vds_id);


--
-- Name: idx_qos_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_qos_storage_pool_id ON public.qos USING btree (storage_pool_id);


--
-- Name: idx_quota_limitation_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_quota_limitation_cluster_id ON public.quota_limitation USING btree (cluster_id) WHERE (cluster_id IS NOT NULL);


--
-- Name: idx_quota_limitation_quota_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_quota_limitation_quota_id ON public.quota_limitation USING btree (quota_id);


--
-- Name: idx_quota_limitation_storage_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_quota_limitation_storage_id ON public.quota_limitation USING btree (storage_id) WHERE (storage_id IS NOT NULL);


--
-- Name: idx_quota_storage_pool_id_default; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_quota_storage_pool_id_default ON public.quota USING btree (storage_pool_id) WHERE (is_default = true);


--
-- Name: idx_repo_file_file_type; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_repo_file_file_type ON public.repo_file_meta_data USING btree (file_type);


--
-- Name: idx_repo_file_meta_data_repo_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_repo_file_meta_data_repo_domain_id ON public.repo_file_meta_data USING btree (repo_domain_id);


--
-- Name: idx_roles__app_mode; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_roles__app_mode ON public.roles USING btree (app_mode);


--
-- Name: idx_roles_groups_action_group_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_roles_groups_action_group_id ON public.roles_groups USING btree (action_group_id);


--
-- Name: idx_roles_groups_role_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_roles_groups_role_id ON public.roles_groups USING btree (role_id);


--
-- Name: idx_root_command_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_root_command_id ON public.command_entities USING btree (root_command_id) WHERE (root_command_id IS NOT NULL);


--
-- Name: idx_snapshots_memory_dump_disk_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_snapshots_memory_dump_disk_id ON public.snapshots USING btree (memory_dump_disk_id);


--
-- Name: idx_snapshots_memory_metadata_disk_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_snapshots_memory_metadata_disk_id ON public.snapshots USING btree (memory_metadata_disk_id);


--
-- Name: idx_snapshots_snapshot_type; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_snapshots_snapshot_type ON public.snapshots USING btree (snapshot_type);


--
-- Name: idx_snapshots_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_snapshots_vm_id ON public.snapshots USING btree (vm_id);


--
-- Name: idx_step_external_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_step_external_id ON public.step USING btree (external_id);


--
-- Name: idx_step_job_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_step_job_id ON public.step USING btree (job_id);


--
-- Name: idx_step_parent_step_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_step_parent_step_id ON public.step USING btree (parent_step_id);


--
-- Name: idx_step_subject_entity_step; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_step_subject_entity_step ON public.step_subject_entity USING btree (step_id);


--
-- Name: idx_storage_device_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_device_vds_id ON public.storage_device USING btree (vds_id);


--
-- Name: idx_storage_domain_dr_georep_session_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_domain_dr_georep_session_id ON public.storage_domain_dr USING btree (georep_session_id);


--
-- Name: idx_storage_domain_dr_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_domain_dr_storage_domain_id ON public.storage_domain_dr USING btree (storage_domain_id);


--
-- Name: idx_storage_domains_ovf_info_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_domains_ovf_info_storage_domain_id ON public.storage_domains_ovf_info USING btree (storage_domain_id);


--
-- Name: idx_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_pool_id ON public.quota USING btree (storage_pool_id) WHERE (storage_pool_id IS NOT NULL);


--
-- Name: idx_storage_pool_iso_map_storage_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_pool_iso_map_storage_id ON public.storage_pool_iso_map USING btree (storage_id);


--
-- Name: idx_storage_pool_iso_map_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_pool_iso_map_storage_pool_id ON public.storage_pool_iso_map USING btree (storage_pool_id);


--
-- Name: idx_storage_server_connections_gluster_volume_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_storage_server_connections_gluster_volume_id ON public.storage_server_connections USING btree (gluster_volume_id);


--
-- Name: idx_supported_cluster_features_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_supported_cluster_features_cluster_id ON public.supported_cluster_features USING btree (cluster_id);


--
-- Name: idx_supported_cluster_features_feature_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_supported_cluster_features_feature_id ON public.supported_cluster_features USING btree (feature_id);


--
-- Name: idx_supported_host_features_host_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_supported_host_features_host_id ON public.supported_host_features USING btree (host_id);


--
-- Name: idx_tags_user_group_map_group_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_user_group_map_group_id ON public.tags_user_group_map USING btree (group_id);


--
-- Name: idx_tags_user_group_map_tag_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_user_group_map_tag_id ON public.tags_user_group_map USING btree (tag_id);


--
-- Name: idx_tags_user_map_tag_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_user_map_tag_id ON public.tags_user_map USING btree (tag_id);


--
-- Name: idx_tags_user_map_user_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_user_map_user_id ON public.tags_user_map USING btree (user_id);


--
-- Name: idx_tags_vds_map_tag_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vds_map_tag_id ON public.tags_vds_map USING btree (tag_id);


--
-- Name: idx_tags_vds_map_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vds_map_vds_id ON public.tags_vds_map USING btree (vds_id);


--
-- Name: idx_tags_vm_map_tag_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vm_map_tag_id ON public.tags_vm_map USING btree (tag_id);


--
-- Name: idx_tags_vm_map_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vm_map_vm_id ON public.tags_vm_map USING btree (vm_id);


--
-- Name: idx_tags_vm_pool_map_tag_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vm_pool_map_tag_id ON public.tags_vm_pool_map USING btree (tag_id);


--
-- Name: idx_tags_vm_pool_map_vm_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_tags_vm_pool_map_vm_pool_id ON public.tags_vm_pool_map USING btree (vm_pool_id);


--
-- Name: idx_unregistered_disks_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_unregistered_disks_storage_domain_id ON public.unregistered_disks USING btree (storage_domain_id);


--
-- Name: idx_unregistered_disks_storage_to_vms; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_unregistered_disks_storage_to_vms ON public.unregistered_disks_to_vms USING btree (disk_id, storage_domain_id);


--
-- Name: idx_unregistered_ovf_of_entities_storage_domain_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_unregistered_ovf_of_entities_storage_domain_id ON public.unregistered_ovf_of_entities USING btree (storage_domain_id);


--
-- Name: idx_user_profiles_property_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX idx_user_profiles_property_name ON public.user_profiles USING btree (user_id, property_name);


--
-- Name: idx_user_profiles_user_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_user_profiles_user_id ON public.user_profiles USING btree (user_id);


--
-- Name: idx_vds_dynamic_status; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_dynamic_status ON public.vds_dynamic USING btree (status);


--
-- Name: idx_vds_interface_statistics_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_interface_statistics_vds_id ON public.vds_interface_statistics USING btree (vds_id);


--
-- Name: idx_vds_interface_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_interface_vds_id ON public.vds_interface USING btree (vds_id);


--
-- Name: idx_vds_kdump_status_status; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_kdump_status_status ON public.vds_kdump_status USING btree (status);


--
-- Name: idx_vds_spm_id_map_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_spm_id_map_storage_pool_id ON public.vds_spm_id_map USING btree (storage_pool_id);


--
-- Name: idx_vds_spm_id_map_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_spm_id_map_vds_id ON public.vds_spm_id_map USING btree (vds_id);


--
-- Name: idx_vds_static_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_static_cluster_id ON public.vds_static USING btree (cluster_id);


--
-- Name: idx_vds_static_host_provider_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vds_static_host_provider_id ON public.vds_static USING btree (host_provider_id);


--
-- Name: idx_vdsm_task_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vdsm_task_id ON public.async_tasks USING btree (vdsm_task_id);


--
-- Name: idx_vfs_config_labels_vfs_config_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vfs_config_labels_vfs_config_id ON public.vfs_config_labels USING btree (vfs_config_id);


--
-- Name: idx_vfs_config_networks_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vfs_config_networks_network_id ON public.vfs_config_networks USING btree (network_id);


--
-- Name: idx_vfs_config_networks_vfs_config_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vfs_config_networks_vfs_config_id ON public.vfs_config_networks USING btree (vfs_config_id);


--
-- Name: idx_vm_backups_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_backups_vm_id ON public.vm_backups USING btree (vm_id);


--
-- Name: idx_vm_checkpoints_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_checkpoints_vm_id ON public.vm_checkpoints USING btree (vm_id);


--
-- Name: idx_vm_device_alias_type_device; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_device_alias_type_device ON public.vm_device USING btree (alias, type, device);


--
-- Name: idx_vm_device_is_plugged; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_device_is_plugged ON public.vm_device USING btree (is_plugged);


--
-- Name: idx_vm_device_snapshot_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_device_snapshot_id ON public.vm_device USING btree (snapshot_id);


--
-- Name: idx_vm_device_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_device_vm_id ON public.vm_device USING btree (vm_id);


--
-- Name: idx_vm_dynamic_migrating_to_vds; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_dynamic_migrating_to_vds ON public.vm_dynamic USING btree (migrating_to_vds);


--
-- Name: idx_vm_dynamic_run_on_vds; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_dynamic_run_on_vds ON public.vm_dynamic USING btree (run_on_vds);


--
-- Name: idx_vm_guest_agent_interfaces_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_guest_agent_interfaces_vm_id ON public.vm_guest_agent_interfaces USING btree (vm_id);


--
-- Name: idx_vm_host_pinning_map_vds_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_host_pinning_map_vds_id ON public.vm_host_pinning_map USING btree (vds_id);


--
-- Name: idx_vm_host_pinning_map_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_host_pinning_map_vm_id ON public.vm_host_pinning_map USING btree (vm_id);


--
-- Name: idx_vm_icon_defaults_large_icon_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_icon_defaults_large_icon_id ON public.vm_icon_defaults USING btree (large_icon_id);


--
-- Name: idx_vm_icon_defaults_small_icon_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_icon_defaults_small_icon_id ON public.vm_icon_defaults USING btree (small_icon_id);


--
-- Name: idx_vm_interface_filter_parameters_vm_interface_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_interface_filter_parameters_vm_interface_id ON public.vm_interface_filter_parameters USING btree (vm_interface_id);


--
-- Name: idx_vm_interface_statistics_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_interface_statistics_vm_id ON public.vm_interface_statistics USING btree (vm_id);


--
-- Name: idx_vm_interface_vm_guid; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_interface_vm_guid ON public.vm_interface USING btree (vm_guid);


--
-- Name: idx_vm_interface_vnic_profile_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_interface_vnic_profile_id ON public.vm_interface USING btree (vnic_profile_id);


--
-- Name: idx_vm_jobs_vm_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_jobs_vm_id ON public.vm_jobs USING btree (vm_id);


--
-- Name: idx_vm_ovf_generations_storage_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_ovf_generations_storage_pool_id ON public.vm_ovf_generations USING btree (storage_pool_id);


--
-- Name: idx_vm_pool_map_vm_pool_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_pool_map_vm_pool_id ON public.vm_pool_map USING btree (vm_pool_id);


--
-- Name: idx_vm_pools_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_pools_cluster_id ON public.vm_pools USING btree (cluster_id);


--
-- Name: idx_vm_static_cluster_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_cluster_id ON public.vm_static USING btree (cluster_id);


--
-- Name: idx_vm_static_cpu_profile_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_cpu_profile_id ON public.vm_static USING btree (cpu_profile_id);


--
-- Name: idx_vm_static_large_icon_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_large_icon_id ON public.vm_static USING btree (large_icon_id);


--
-- Name: idx_vm_static_lease_sd_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_lease_sd_id ON public.vm_static USING btree (lease_sd_id);


--
-- Name: idx_vm_static_origin; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_origin ON public.vm_static USING btree (origin);


--
-- Name: idx_vm_static_provider_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_provider_id ON public.vm_static USING btree (provider_id);


--
-- Name: idx_vm_static_quota_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_quota_id ON public.vm_static USING btree (quota_id);


--
-- Name: idx_vm_static_small_icon_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_small_icon_id ON public.vm_static USING btree (small_icon_id);


--
-- Name: idx_vm_static_template_version_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_template_version_name ON public.vm_static USING btree (template_version_number);


--
-- Name: idx_vm_static_vm_name; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_vm_name ON public.vm_static USING btree (vm_name);


--
-- Name: idx_vm_static_vmt_guid; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_static_vmt_guid ON public.vm_static USING btree (vmt_guid);


--
-- Name: idx_vm_vds_numa_node_map_vm_numa_node_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vm_vds_numa_node_map_vm_numa_node_id ON public.vm_vds_numa_node_map USING btree (vm_numa_node_id);


--
-- Name: idx_vnic_profiles_network_filter_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vnic_profiles_network_filter_id ON public.vnic_profiles USING btree (network_filter_id);


--
-- Name: idx_vnic_profiles_network_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vnic_profiles_network_id ON public.vnic_profiles USING btree (network_id);


--
-- Name: idx_vnic_profiles_network_qos_id; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX idx_vnic_profiles_network_qos_id ON public.vnic_profiles USING btree (network_qos_id);


--
-- Name: ix_vdc_options; Type: INDEX; Schema: public; Owner: engine
--

CREATE INDEX ix_vdc_options ON public.vdc_options USING btree (option_name);


--
-- Name: vm_icons_data_url_unique_index; Type: INDEX; Schema: public; Owner: engine
--

CREATE UNIQUE INDEX vm_icons_data_url_unique_index ON public.vm_icons USING btree (md5((data_url)::text));


--
-- Name: affinity_groups_with_members_from_labels_view _RETURN; Type: RULE; Schema: public; Owner: engine
--

CREATE OR REPLACE VIEW public.affinity_groups_with_members_from_labels_view AS
 SELECT affinity_groups.id,
    affinity_groups.name,
    affinity_groups.description,
    affinity_groups.cluster_id,
    affinity_groups.vm_positive,
    affinity_groups.vm_enforcing,
    affinity_groups._create_date,
    affinity_groups._update_date,
    affinity_groups.vds_positive,
    affinity_groups.vds_enforcing,
    affinity_groups.vms_affinity_enabled,
    affinity_groups.vds_affinity_enabled,
    affinity_groups.priority,
    array_agg((members.vm_id)::text) AS vm_ids,
    array_agg((vm_static.vm_name)::text) AS vm_names,
    array_agg((members.vds_id)::text) AS vds_ids,
    array_agg((vds_static.vds_name)::text) AS vds_names,
    '{}'::text[] AS vm_label_ids,
    '{}'::text[] AS vm_label_names,
    '{}'::text[] AS host_label_ids,
    '{}'::text[] AS host_label_names
   FROM (((public.affinity_groups
     LEFT JOIN public.affinity_groups_members_flat_labels_view members ON ((members.affinity_group_id = affinity_groups.id)))
     LEFT JOIN public.vm_static ON ((vm_static.vm_guid = members.vm_id)))
     LEFT JOIN public.vds_static ON ((vds_static.vds_id = members.vds_id)))
  GROUP BY affinity_groups.id, affinity_groups.name, affinity_groups.description, affinity_groups.cluster_id, affinity_groups.vm_positive, affinity_groups.vm_enforcing, affinity_groups.vds_positive, affinity_groups.vds_enforcing, affinity_groups.vms_affinity_enabled, affinity_groups.vds_affinity_enabled, affinity_groups._create_date, affinity_groups._update_date;


--
-- Name: labels_map_view _RETURN; Type: RULE; Schema: public; Owner: engine
--

CREATE OR REPLACE VIEW public.labels_map_view AS
 SELECT labels.label_id,
    labels.label_name,
    labels.read_only,
    labels.has_implicit_affinity_group,
    array_agg((labels_map.vm_id)::text) AS vm_ids,
    array_agg((labels_map.vds_id)::text) AS vds_ids
   FROM (public.labels
     LEFT JOIN public.labels_map ON ((labels_map.label_id = labels.label_id)))
  GROUP BY labels.label_id, labels.label_name, labels.read_only;


--
-- Name: dwh_vm_disk_configuration_history_view _RETURN; Type: RULE; Schema: public; Owner: engine
--

CREATE OR REPLACE VIEW public.dwh_vm_disk_configuration_history_view AS
 SELECT d.disk_id AS vm_disk_id,
    d.disk_alias AS vm_disk_name,
    d.disk_description AS vm_disk_description,
    image_storage_domain_map.storage_domain_id,
    ((i.size / 1048576))::integer AS vm_disk_size_mb,
    (i.volume_type)::smallint AS vm_disk_type,
    (i.volume_format)::smallint AS vm_disk_format,
    d.shareable AS is_shared,
    i._create_date AS create_date,
    i._update_date AS update_date
   FROM ((public.images i
     JOIN public.base_disks d ON ((i.image_group_id = d.disk_id)))
     JOIN public.image_storage_domain_map ON ((image_storage_domain_map.image_id = i.image_guid)))
  WHERE ((i.active = true) AND (i.image_group_id IN ( SELECT vm_device.device_id
           FROM (public.vm_device
             LEFT JOIN public.vm_static ON ((vm_static.vm_guid = vm_device.vm_id)))
          WHERE (((vm_static.entity_type)::text = 'VM'::text) OR (vm_static.entity_type IS NULL)))) AND ((i._create_date > ( SELECT dwh_history_timekeeping.var_datetime
           FROM public.dwh_history_timekeeping
          WHERE ((dwh_history_timekeeping.var_name)::text = 'lastSync'::text))) OR (i._update_date > ( SELECT history_timekeeping_1.var_datetime
           FROM public.dwh_history_timekeeping history_timekeeping_1
          WHERE ((history_timekeeping_1.var_name)::text = 'lastSync'::text)))))
  GROUP BY d.disk_id, image_storage_domain_map.storage_domain_id, (((i.size / 1048576))::integer), ((i.volume_type)::smallint), ((i.volume_format)::smallint), i._create_date, i._update_date;


--
-- Name: images delete_disk_image_dynamic_for_image; Type: TRIGGER; Schema: public; Owner: engine
--

CREATE TRIGGER delete_disk_image_dynamic_for_image BEFORE DELETE ON public.images FOR EACH ROW EXECUTE FUNCTION public.fn_image_deleted();


--
-- Name: vm_static remove_nvram_data_on_update; Type: TRIGGER; Schema: public; Owner: engine
--

CREATE TRIGGER remove_nvram_data_on_update AFTER UPDATE ON public.vm_static FOR EACH ROW EXECUTE FUNCTION public.remove_nvram_data();


--
-- Name: failed_logins failed_logins_user_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.failed_logins
    ADD CONSTRAINT failed_logins_user_id_fkey FOREIGN KEY (user_id) REFERENCES aaa_jdbc.users(id) ON DELETE CASCADE;


--
-- Name: group_attributes group_attributes_group_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_attributes
    ADD CONSTRAINT group_attributes_group_id_fkey FOREIGN KEY (group_id) REFERENCES aaa_jdbc.groups(id) ON DELETE CASCADE;


--
-- Name: group_groups group_groups_group_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_groups
    ADD CONSTRAINT group_groups_group_id_fkey FOREIGN KEY (group_id) REFERENCES aaa_jdbc.groups(id) ON DELETE CASCADE;


--
-- Name: group_groups group_groups_in_group_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.group_groups
    ADD CONSTRAINT group_groups_in_group_id_fkey FOREIGN KEY (in_group_id) REFERENCES aaa_jdbc.groups(id) ON DELETE CASCADE;


--
-- Name: user_attributes user_attributes_user_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_attributes
    ADD CONSTRAINT user_attributes_user_id_fkey FOREIGN KEY (user_id) REFERENCES aaa_jdbc.users(id) ON DELETE CASCADE;


--
-- Name: user_groups user_groups_in_group_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_groups
    ADD CONSTRAINT user_groups_in_group_id_fkey FOREIGN KEY (in_group_id) REFERENCES aaa_jdbc.groups(id) ON DELETE CASCADE;


--
-- Name: user_groups user_groups_user_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_groups
    ADD CONSTRAINT user_groups_user_id_fkey FOREIGN KEY (user_id) REFERENCES aaa_jdbc.users(id) ON DELETE CASCADE;


--
-- Name: user_password_history user_password_history_user_id_fkey; Type: FK CONSTRAINT; Schema: aaa_jdbc; Owner: engine
--

ALTER TABLE ONLY aaa_jdbc.user_password_history
    ADD CONSTRAINT user_password_history_user_id_fkey FOREIGN KEY (user_id) REFERENCES aaa_jdbc.users(id) ON DELETE CASCADE;


--
-- Name: affinity_groups affinity_group_cluster_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_groups
    ADD CONSTRAINT affinity_group_cluster_id_fk FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: affinity_group_members affinity_group_member_affinity_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_group_members
    ADD CONSTRAINT affinity_group_member_affinity_id_fk FOREIGN KEY (affinity_group_id) REFERENCES public.affinity_groups(id) ON DELETE CASCADE;


--
-- Name: affinity_group_members affinity_group_member_vds_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_group_members
    ADD CONSTRAINT affinity_group_member_vds_id_fk FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: affinity_group_members affinity_group_member_vm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_group_members
    ADD CONSTRAINT affinity_group_member_vm_id_fk FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: affinity_group_members affinity_group_members_host_label_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_group_members
    ADD CONSTRAINT affinity_group_members_host_label_id_fkey FOREIGN KEY (host_label_id) REFERENCES public.labels(label_id) ON DELETE CASCADE;


--
-- Name: affinity_group_members affinity_group_members_vm_label_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.affinity_group_members
    ADD CONSTRAINT affinity_group_members_vm_label_id_fkey FOREIGN KEY (vm_label_id) REFERENCES public.labels(label_id) ON DELETE CASCADE;


--
-- Name: cinder_storage cinder_storage_storage_domain_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cinder_storage
    ADD CONSTRAINT cinder_storage_storage_domain_id_fkey FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: cluster cluster_default_network_provider_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster
    ADD CONSTRAINT cluster_default_network_provider_id_fkey FOREIGN KEY (default_network_provider_id) REFERENCES public.providers(id);


--
-- Name: cluster cluster_mac_pool_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster
    ADD CONSTRAINT cluster_mac_pool_id_fkey FOREIGN KEY (mac_pool_id) REFERENCES public.mac_pools(id);


--
-- Name: cpu_profiles cpu_profiles_cluster_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cpu_profiles
    ADD CONSTRAINT cpu_profiles_cluster_id_fkey FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: cpu_profiles cpu_profiles_qos_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cpu_profiles
    ADD CONSTRAINT cpu_profiles_qos_id_fkey FOREIGN KEY (qos_id) REFERENCES public.qos(id) ON DELETE SET NULL;


--
-- Name: disk_lun_map disk_lun_to_disk_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_lun_map
    ADD CONSTRAINT disk_lun_to_disk_fk FOREIGN KEY (disk_id) REFERENCES public.base_disks(disk_id);


--
-- Name: disk_lun_map disk_lun_to_lun_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_lun_map
    ADD CONSTRAINT disk_lun_to_lun_fk FOREIGN KEY (lun_id) REFERENCES public.luns(lun_id);


--
-- Name: disk_profiles disk_profiles_qos_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_profiles
    ADD CONSTRAINT disk_profiles_qos_id_fkey FOREIGN KEY (qos_id) REFERENCES public.qos(id) ON DELETE SET NULL;


--
-- Name: disk_profiles disk_profiles_storage_domain_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_profiles
    ADD CONSTRAINT disk_profiles_storage_domain_id_fkey FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: external_leases external_leases_storage_domain_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.external_leases
    ADD CONSTRAINT external_leases_storage_domain_id_fkey FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: vnic_profiles failover_vnic_profile_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vnic_profiles
    ADD CONSTRAINT failover_vnic_profile_id_fk FOREIGN KEY (failover_vnic_profile_id) REFERENCES public.vnic_profiles(id) ON DELETE SET NULL;


--
-- Name: fence_agents fence_agent_host_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.fence_agents
    ADD CONSTRAINT fence_agent_host_id_fk FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: async_tasks_entities fk_async_task_entity; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.async_tasks_entities
    ADD CONSTRAINT fk_async_task_entity FOREIGN KEY (async_task_id) REFERENCES public.async_tasks(task_id) ON DELETE CASCADE;


--
-- Name: vm_backups fk_backups_snapshots; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_backups
    ADD CONSTRAINT fk_backups_snapshots FOREIGN KEY (snapshot_id) REFERENCES public.snapshots(snapshot_id) ON DELETE SET DEFAULT;


--
-- Name: cluster_policy_units fk_cluster_policy_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster_policy_units
    ADD CONSTRAINT fk_cluster_policy_id FOREIGN KEY (cluster_policy_id) REFERENCES public.cluster_policies(id) ON DELETE CASCADE;


--
-- Name: cluster fk_cluster_storage_pool_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.cluster
    ADD CONSTRAINT fk_cluster_storage_pool_id FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE SET NULL;


--
-- Name: vds_static fk_cluster_vds_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_static
    ADD CONSTRAINT fk_cluster_vds_static FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id);


--
-- Name: vm_pools fk_cluster_vm_pools; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_pools
    ADD CONSTRAINT fk_cluster_vm_pools FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id);


--
-- Name: vm_static fk_cluster_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_cluster_vm_static FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id);


--
-- Name: command_assoc_entities fk_coco_command_assoc_entity; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.command_assoc_entities
    ADD CONSTRAINT fk_coco_command_assoc_entity FOREIGN KEY (command_id) REFERENCES public.command_entities(command_id) ON DELETE CASCADE;


--
-- Name: disk_vm_element fk_disk_vm_element_base_disks; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_vm_element
    ADD CONSTRAINT fk_disk_vm_element_base_disks FOREIGN KEY (disk_id) REFERENCES public.base_disks(disk_id) ON DELETE CASCADE;


--
-- Name: disk_vm_element fk_disk_vm_element_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.disk_vm_element
    ADD CONSTRAINT fk_disk_vm_element_vm_static FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: event_notification_hist fk_event_notification_hist_audit_log; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.event_notification_hist
    ADD CONSTRAINT fk_event_notification_hist_audit_log FOREIGN KEY (audit_log_id) REFERENCES public.audit_log(audit_log_id) ON DELETE CASCADE;


--
-- Name: event_subscriber fk_event_subscriber_users; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.event_subscriber
    ADD CONSTRAINT fk_event_subscriber_users FOREIGN KEY (subscriber_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: gluster_georep_config fk_gluster_georep_config_session_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_config
    ADD CONSTRAINT fk_gluster_georep_config_session_id FOREIGN KEY (session_id) REFERENCES public.gluster_georep_session(session_id) ON DELETE CASCADE;


--
-- Name: gluster_georep_session_details fk_gluster_georep_details_brick_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_session_details
    ADD CONSTRAINT fk_gluster_georep_details_brick_id FOREIGN KEY (master_brick_id) REFERENCES public.gluster_volume_bricks(id) ON DELETE CASCADE;


--
-- Name: gluster_georep_session_details fk_gluster_georep_details_session_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_session_details
    ADD CONSTRAINT fk_gluster_georep_details_session_id FOREIGN KEY (session_id) REFERENCES public.gluster_georep_session(session_id) ON DELETE CASCADE;


--
-- Name: gluster_georep_session fk_gluster_georep_session_vol_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_georep_session
    ADD CONSTRAINT fk_gluster_georep_session_vol_id FOREIGN KEY (master_volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_bricks fk_gluster_volume_bricks_network_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_bricks
    ADD CONSTRAINT fk_gluster_volume_bricks_network_id FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE RESTRICT;


--
-- Name: gluster_volume_snapshot_config fk_gluster_volume_snapshot_config_cluster_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshot_config
    ADD CONSTRAINT fk_gluster_volume_snapshot_config_cluster_id FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: gluster_volume_snapshot_config fk_gluster_volume_snapshot_config_volume_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshot_config
    ADD CONSTRAINT fk_gluster_volume_snapshot_config_volume_id FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_snapshot_schedules fk_gluster_volume_snapshot_schedules_volume_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshot_schedules
    ADD CONSTRAINT fk_gluster_volume_snapshot_schedules_volume_id FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_snapshots fk_gluster_volume_snapshots_volume_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_snapshots
    ADD CONSTRAINT fk_gluster_volume_snapshots_volume_id FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: host_device fk_host_device_host_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_device
    ADD CONSTRAINT fk_host_device_host_id FOREIGN KEY (host_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: host_device fk_host_device_parent_name; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_device
    ADD CONSTRAINT fk_host_device_parent_name FOREIGN KEY (host_id, parent_device_name) REFERENCES public.host_device(host_id, device_name) DEFERRABLE;


--
-- Name: host_device fk_host_device_physfn; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_device
    ADD CONSTRAINT fk_host_device_physfn FOREIGN KEY (host_id, physfn) REFERENCES public.host_device(host_id, device_name) DEFERRABLE;


--
-- Name: host_device fk_host_device_vm_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_device
    ADD CONSTRAINT fk_host_device_vm_id FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE SET NULL;


--
-- Name: image_storage_domain_map fk_image_storage_domain_map_disk_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_storage_domain_map
    ADD CONSTRAINT fk_image_storage_domain_map_disk_profile_id FOREIGN KEY (disk_profile_id) REFERENCES public.disk_profiles(id) ON DELETE SET NULL;


--
-- Name: image_storage_domain_map fk_image_storage_domain_map_images; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_storage_domain_map
    ADD CONSTRAINT fk_image_storage_domain_map_images FOREIGN KEY (image_id) REFERENCES public.images(image_guid) ON DELETE CASCADE;


--
-- Name: image_storage_domain_map fk_image_storage_domain_map_quota; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_storage_domain_map
    ADD CONSTRAINT fk_image_storage_domain_map_quota FOREIGN KEY (quota_id) REFERENCES public.quota(id) ON DELETE SET NULL;


--
-- Name: image_storage_domain_map fk_image_storage_domain_map_storage_domain_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.image_storage_domain_map
    ADD CONSTRAINT fk_image_storage_domain_map_storage_domain_static FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: images fk_image_templates_images; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.images
    ADD CONSTRAINT fk_image_templates_images FOREIGN KEY (it_guid) REFERENCES public.images(image_guid);


--
-- Name: iscsi_bonds_networks_map fk_iscsi_bonds_networks_map_iscsi_bond_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_networks_map
    ADD CONSTRAINT fk_iscsi_bonds_networks_map_iscsi_bond_id FOREIGN KEY (iscsi_bond_id) REFERENCES public.iscsi_bonds(id) ON DELETE CASCADE;


--
-- Name: iscsi_bonds_networks_map fk_iscsi_bonds_networks_map_network_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_networks_map
    ADD CONSTRAINT fk_iscsi_bonds_networks_map_network_id FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE CASCADE;


--
-- Name: iscsi_bonds_storage_connections_map fk_iscsi_bonds_storage_connections_map_connection_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_storage_connections_map
    ADD CONSTRAINT fk_iscsi_bonds_storage_connections_map_connection_id FOREIGN KEY (connection_id) REFERENCES public.storage_server_connections(id) ON DELETE CASCADE;


--
-- Name: iscsi_bonds_storage_connections_map fk_iscsi_bonds_storage_connections_map_iscsi_bond_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds_storage_connections_map
    ADD CONSTRAINT fk_iscsi_bonds_storage_connections_map_iscsi_bond_id FOREIGN KEY (iscsi_bond_id) REFERENCES public.iscsi_bonds(id) ON DELETE CASCADE;


--
-- Name: iscsi_bonds fk_iscsi_bonds_storage_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.iscsi_bonds
    ADD CONSTRAINT fk_iscsi_bonds_storage_pool FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: job_subject_entity fk_job_subject_entity_job; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.job_subject_entity
    ADD CONSTRAINT fk_job_subject_entity_job FOREIGN KEY (job_id) REFERENCES public.job(job_id) ON DELETE CASCADE;


--
-- Name: lun_storage_server_connection_map fk_lun_storage_server_connection_map_luns; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.lun_storage_server_connection_map
    ADD CONSTRAINT fk_lun_storage_server_connection_map_luns FOREIGN KEY (lun_id) REFERENCES public.luns(lun_id) ON DELETE CASCADE;


--
-- Name: lun_storage_server_connection_map fk_lun_storage_server_connection_map_storage_server_connections; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.lun_storage_server_connection_map
    ADD CONSTRAINT fk_lun_storage_server_connection_map_storage_server_connections FOREIGN KEY (storage_server_connection) REFERENCES public.storage_server_connections(id) ON DELETE CASCADE;


--
-- Name: network_cluster fk_network_cluster_cluster; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_cluster
    ADD CONSTRAINT fk_network_cluster_cluster FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: network_cluster fk_network_cluster_network; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_cluster
    ADD CONSTRAINT fk_network_cluster_network FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE CASCADE;


--
-- Name: network fk_network_provided_by; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT fk_network_provided_by FOREIGN KEY (provider_network_provider_id) REFERENCES public.providers(id) ON DELETE CASCADE;


--
-- Name: network fk_network_qos_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT fk_network_qos_id FOREIGN KEY (qos_id) REFERENCES public.qos(id) ON DELETE SET NULL;


--
-- Name: network fk_network_storage_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT fk_network_storage_pool FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE SET NULL;


--
-- Name: numa_node_cpu_map fk_numa_node_cpu_map_numa_node; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.numa_node_cpu_map
    ADD CONSTRAINT fk_numa_node_cpu_map_numa_node FOREIGN KEY (numa_node_id) REFERENCES public.numa_node(numa_node_id) ON DELETE CASCADE;


--
-- Name: numa_node fk_numa_node_vds; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.numa_node
    ADD CONSTRAINT fk_numa_node_vds FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: numa_node fk_numa_node_vm; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.numa_node
    ADD CONSTRAINT fk_numa_node_vm FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: permissions fk_permissions_roles; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT fk_permissions_roles FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE CASCADE;


--
-- Name: qos fk_qos_storage_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.qos
    ADD CONSTRAINT fk_qos_storage_pool FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: quota_limitation fk_quota_limitation_cluster_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota_limitation
    ADD CONSTRAINT fk_quota_limitation_cluster_id FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: repo_file_meta_data fk_repo_file_meta_data_storage_domain_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.repo_file_meta_data
    ADD CONSTRAINT fk_repo_file_meta_data_storage_domain_static FOREIGN KEY (repo_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: roles_groups fk_roles_groups_action_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.roles_groups
    ADD CONSTRAINT fk_roles_groups_action_id FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE CASCADE;


--
-- Name: snapshots fk_snapshot_vm; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.snapshots
    ADD CONSTRAINT fk_snapshot_vm FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid);


--
-- Name: snapshots fk_snapshots_dump_disk_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.snapshots
    ADD CONSTRAINT fk_snapshots_dump_disk_id FOREIGN KEY (memory_dump_disk_id) REFERENCES public.base_disks(disk_id) ON DELETE SET NULL;


--
-- Name: snapshots fk_snapshots_metadata_disk_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.snapshots
    ADD CONSTRAINT fk_snapshots_metadata_disk_id FOREIGN KEY (memory_metadata_disk_id) REFERENCES public.base_disks(disk_id) ON DELETE SET NULL;


--
-- Name: step fk_step_job; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.step
    ADD CONSTRAINT fk_step_job FOREIGN KEY (job_id) REFERENCES public.job(job_id) ON DELETE CASCADE;


--
-- Name: storage_server_connections fk_storage_connection_to_glustervolume; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_server_connections
    ADD CONSTRAINT fk_storage_connection_to_glustervolume FOREIGN KEY (gluster_volume_id) REFERENCES public.gluster_volumes(id);


--
-- Name: storage_domain_dr fk_storage_domain_dr_georep_session_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_dr
    ADD CONSTRAINT fk_storage_domain_dr_georep_session_id FOREIGN KEY (georep_session_id) REFERENCES public.gluster_georep_session(session_id);


--
-- Name: storage_domain_dr fk_storage_domain_dr_storage_domain_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_dr
    ADD CONSTRAINT fk_storage_domain_dr_storage_domain_id FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: storage_domain_dynamic fk_storage_domain_dynamic_storage_domain_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domain_dynamic
    ADD CONSTRAINT fk_storage_domain_dynamic_storage_domain_static FOREIGN KEY (id) REFERENCES public.storage_domain_static(id);


--
-- Name: storage_pool_iso_map fk_storage_domain_pool_map_storage_domain_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_pool_iso_map
    ADD CONSTRAINT fk_storage_domain_pool_map_storage_domain_static FOREIGN KEY (storage_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: storage_pool_iso_map fk_storage_domain_pool_map_storage_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_pool_iso_map
    ADD CONSTRAINT fk_storage_domain_pool_map_storage_pool FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: tags_vm_pool_map fk_tags_vm_pool_map_tag; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_pool_map
    ADD CONSTRAINT fk_tags_vm_pool_map_tag FOREIGN KEY (tag_id) REFERENCES public.tags(tag_id) ON DELETE CASCADE;


--
-- Name: tags_vm_pool_map fk_tags_vm_pool_map_vm_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_pool_map
    ADD CONSTRAINT fk_tags_vm_pool_map_vm_pool FOREIGN KEY (vm_pool_id) REFERENCES public.vm_pools(vm_pool_id) ON DELETE CASCADE;


--
-- Name: unregistered_disks fk_unregistered_disks_storage_domain; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_disks
    ADD CONSTRAINT fk_unregistered_disks_storage_domain FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: unregistered_disks_to_vms fk_unregistered_disks_to_vms; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_disks_to_vms
    ADD CONSTRAINT fk_unregistered_disks_to_vms FOREIGN KEY (disk_id, storage_domain_id) REFERENCES public.unregistered_disks(disk_id, storage_domain_id) ON DELETE CASCADE;


--
-- Name: unregistered_ovf_of_entities fk_unregistered_ovf_of_entities_storage_domain; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.unregistered_ovf_of_entities
    ADD CONSTRAINT fk_unregistered_ovf_of_entities_storage_domain FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: user_profiles fk_user_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.user_profiles
    ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: vds_interface_statistics fk_vds_interface_statistics_vds_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface_statistics
    ADD CONSTRAINT fk_vds_interface_statistics_vds_static FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: vds_interface fk_vds_interface_vds_interface; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_interface
    ADD CONSTRAINT fk_vds_interface_vds_interface FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: vds_kdump_status fk_vds_kdump_status_vds_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_kdump_status
    ADD CONSTRAINT fk_vds_kdump_status_vds_static FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: vds_spm_id_map fk_vds_spm_id_map_storage_pool; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_spm_id_map
    ADD CONSTRAINT fk_vds_spm_id_map_storage_pool FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: vds_spm_id_map fk_vds_spm_id_map_vds_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_spm_id_map
    ADD CONSTRAINT fk_vds_spm_id_map_vds_id FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: vds_static fk_vds_static_host_provider_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_static
    ADD CONSTRAINT fk_vds_static_host_provider_id FOREIGN KEY (host_provider_id) REFERENCES public.providers(id) ON DELETE SET NULL;


--
-- Name: vm_backup_disk_map fk_vm_backup_disk_map_vm_backups; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_backup_disk_map
    ADD CONSTRAINT fk_vm_backup_disk_map_vm_backups FOREIGN KEY (backup_id) REFERENCES public.vm_backups(backup_id) ON DELETE CASCADE;


--
-- Name: vm_checkpoint_disk_map fk_vm_checkpoint_disk_map_vm_checkpoints; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_checkpoint_disk_map
    ADD CONSTRAINT fk_vm_checkpoint_disk_map_vm_checkpoints FOREIGN KEY (checkpoint_id) REFERENCES public.vm_checkpoints(checkpoint_id) ON DELETE CASCADE;


--
-- Name: vm_device fk_vm_device_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_device
    ADD CONSTRAINT fk_vm_device_vm_static FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_guest_agent_interfaces fk_vm_guest_agent_interfaces; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_guest_agent_interfaces
    ADD CONSTRAINT fk_vm_guest_agent_interfaces FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_icon_defaults fk_vm_icon_defaults_large_icon_id_vm_icons_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_icon_defaults
    ADD CONSTRAINT fk_vm_icon_defaults_large_icon_id_vm_icons_id FOREIGN KEY (large_icon_id) REFERENCES public.vm_icons(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: vm_icon_defaults fk_vm_icon_defaults_small_icon_id_vm_icons_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_icon_defaults
    ADD CONSTRAINT fk_vm_icon_defaults_small_icon_id_vm_icons_id FOREIGN KEY (small_icon_id) REFERENCES public.vm_icons(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: vm_interface_statistics fk_vm_interface_statistics_vm_interface; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface_statistics
    ADD CONSTRAINT fk_vm_interface_statistics_vm_interface FOREIGN KEY (id) REFERENCES public.vm_interface(id) ON DELETE CASCADE;


--
-- Name: vm_interface_statistics fk_vm_interface_statistics_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface_statistics
    ADD CONSTRAINT fk_vm_interface_statistics_vm_static FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_interface fk_vm_interface_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface
    ADD CONSTRAINT fk_vm_interface_vm_static FOREIGN KEY (vm_guid) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_interface fk_vm_interface_vnic_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface
    ADD CONSTRAINT fk_vm_interface_vnic_profile_id FOREIGN KEY (vnic_profile_id) REFERENCES public.vnic_profiles(id) ON DELETE SET NULL;


--
-- Name: vm_jobs fk_vm_jobs_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_jobs
    ADD CONSTRAINT fk_vm_jobs_vm_static FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_static fk_vm_static_cpu_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_cpu_profile_id FOREIGN KEY (cpu_profile_id) REFERENCES public.cpu_profiles(id) ON DELETE SET NULL;


--
-- Name: vm_static fk_vm_static_large_icon_id_vm_icons_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_large_icon_id_vm_icons_id FOREIGN KEY (large_icon_id) REFERENCES public.vm_icons(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: vm_static fk_vm_static_lease_sd_id_storage_domain_static_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_lease_sd_id_storage_domain_static_id FOREIGN KEY (lease_sd_id) REFERENCES public.storage_domain_static(id) ON DELETE SET NULL;


--
-- Name: vm_static fk_vm_static_provider_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_provider_id FOREIGN KEY (provider_id) REFERENCES public.providers(id) ON DELETE SET NULL;


--
-- Name: vm_static fk_vm_static_quota; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_quota FOREIGN KEY (quota_id) REFERENCES public.quota(id) ON DELETE SET NULL;


--
-- Name: vm_static fk_vm_static_small_icon_id_vm_icons_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT fk_vm_static_small_icon_id_vm_icons_id FOREIGN KEY (small_icon_id) REFERENCES public.vm_icons(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: vm_vds_numa_node_map fk_vm_vds_numa_node_map_vm_numa_node; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_vds_numa_node_map
    ADD CONSTRAINT fk_vm_vds_numa_node_map_vm_numa_node FOREIGN KEY (vm_numa_node_id) REFERENCES public.numa_node(numa_node_id) ON DELETE CASCADE;


--
-- Name: vnic_profiles fk_vnic_profiles_network_qos_id; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vnic_profiles
    ADD CONSTRAINT fk_vnic_profiles_network_qos_id FOREIGN KEY (network_qos_id) REFERENCES public.qos(id) ON DELETE SET NULL;


--
-- Name: gluster_cluster_services gluster_cluster_services_cluster_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_cluster_services
    ADD CONSTRAINT gluster_cluster_services_cluster_id_fkey FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: gluster_cluster_services gluster_cluster_services_service_type_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_cluster_services
    ADD CONSTRAINT gluster_cluster_services_service_type_fkey FOREIGN KEY (service_type) REFERENCES public.gluster_service_types(service_type) ON DELETE CASCADE;


--
-- Name: gluster_hooks gluster_hooks_cluster_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_hooks
    ADD CONSTRAINT gluster_hooks_cluster_id_fkey FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: gluster_server_hooks gluster_server_hooks_hook_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_hooks
    ADD CONSTRAINT gluster_server_hooks_hook_id_fkey FOREIGN KEY (hook_id) REFERENCES public.gluster_hooks(id) ON DELETE CASCADE;


--
-- Name: gluster_server_hooks gluster_server_hooks_server_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_hooks
    ADD CONSTRAINT gluster_server_hooks_server_id_fkey FOREIGN KEY (server_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: gluster_server gluster_server_server_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server
    ADD CONSTRAINT gluster_server_server_id_fkey FOREIGN KEY (server_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: gluster_server_services gluster_server_services_server_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_services
    ADD CONSTRAINT gluster_server_services_server_id_fkey FOREIGN KEY (server_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: gluster_server_services gluster_server_services_service_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_server_services
    ADD CONSTRAINT gluster_server_services_service_id_fkey FOREIGN KEY (service_id) REFERENCES public.gluster_services(id) ON DELETE CASCADE;


--
-- Name: gluster_services gluster_services_service_type_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_services
    ADD CONSTRAINT gluster_services_service_type_fkey FOREIGN KEY (service_type) REFERENCES public.gluster_service_types(service_type) ON DELETE CASCADE;


--
-- Name: gluster_volume_access_protocols gluster_volume_access_protocols_volume_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_access_protocols
    ADD CONSTRAINT gluster_volume_access_protocols_volume_id_fkey FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_brick_details gluster_volume_brick_details_brick_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_brick_details
    ADD CONSTRAINT gluster_volume_brick_details_brick_id_fkey FOREIGN KEY (brick_id) REFERENCES public.gluster_volume_bricks(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_bricks gluster_volume_bricks_server_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_bricks
    ADD CONSTRAINT gluster_volume_bricks_server_id_fkey FOREIGN KEY (server_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: gluster_volume_bricks gluster_volume_bricks_volume_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_bricks
    ADD CONSTRAINT gluster_volume_bricks_volume_id_fkey FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_details gluster_volume_details_volume_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_details
    ADD CONSTRAINT gluster_volume_details_volume_id_fkey FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_options gluster_volume_options_volume_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_options
    ADD CONSTRAINT gluster_volume_options_volume_id_fkey FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volume_transport_types gluster_volume_transport_types_volume_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volume_transport_types
    ADD CONSTRAINT gluster_volume_transport_types_volume_id_fkey FOREIGN KEY (volume_id) REFERENCES public.gluster_volumes(id) ON DELETE CASCADE;


--
-- Name: gluster_volumes gluster_volumes_cluster_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.gluster_volumes
    ADD CONSTRAINT gluster_volumes_cluster_id_fkey FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: labels_map labels_map_label_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.labels_map
    ADD CONSTRAINT labels_map_label_id_fkey FOREIGN KEY (label_id) REFERENCES public.labels(label_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: labels_map labels_map_vds_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.labels_map
    ADD CONSTRAINT labels_map_vds_id_fkey FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: labels_map labels_map_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.labels_map
    ADD CONSTRAINT labels_map_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: libvirt_secrets libvirt_secrets_provider_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.libvirt_secrets
    ADD CONSTRAINT libvirt_secrets_provider_id_fkey FOREIGN KEY (provider_id) REFERENCES public.providers(id) ON DELETE CASCADE;


--
-- Name: mac_pool_ranges mac_pool_ranges_mac_pool_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.mac_pool_ranges
    ADD CONSTRAINT mac_pool_ranges_mac_pool_id_fkey FOREIGN KEY (mac_pool_id) REFERENCES public.mac_pools(id) ON DELETE CASCADE;


--
-- Name: name_server name_server_dns_resolver_configuration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.name_server
    ADD CONSTRAINT name_server_dns_resolver_configuration_id_fkey FOREIGN KEY (dns_resolver_configuration_id) REFERENCES public.dns_resolver_configuration(id) ON DELETE CASCADE;


--
-- Name: network_attachments network_attachments_dns_resolver_configuration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_attachments
    ADD CONSTRAINT network_attachments_dns_resolver_configuration_id_fkey FOREIGN KEY (dns_resolver_configuration_id) REFERENCES public.dns_resolver_configuration(id) ON DELETE SET NULL;


--
-- Name: network_attachments network_attachments_network_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_attachments
    ADD CONSTRAINT network_attachments_network_id_fkey FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE CASCADE;


--
-- Name: network_attachments network_attachments_nic_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network_attachments
    ADD CONSTRAINT network_attachments_nic_id_fkey FOREIGN KEY (nic_id) REFERENCES public.vds_interface(id) ON DELETE CASCADE;


--
-- Name: network network_dns_resolver_configuration_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT network_dns_resolver_configuration_id_fkey FOREIGN KEY (dns_resolver_configuration_id) REFERENCES public.dns_resolver_configuration(id) ON DELETE SET NULL;


--
-- Name: vnic_profiles network_filter_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vnic_profiles
    ADD CONSTRAINT network_filter_id_fk FOREIGN KEY (network_filter_id) REFERENCES public.network_filter(filter_id) ON DELETE SET NULL;


--
-- Name: network network_provider_physical_network_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.network
    ADD CONSTRAINT network_provider_physical_network_id_fkey FOREIGN KEY (provider_physical_network_id) REFERENCES public.network(id);


--
-- Name: provider_binding_host_id provider_binding_host_id_vds_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.provider_binding_host_id
    ADD CONSTRAINT provider_binding_host_id_vds_id_fkey FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: quota_limitation quota_limitation_quota_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota_limitation
    ADD CONSTRAINT quota_limitation_quota_id_fkey FOREIGN KEY (quota_id) REFERENCES public.quota(id) ON DELETE CASCADE;


--
-- Name: quota_limitation quota_limitation_storage_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota_limitation
    ADD CONSTRAINT quota_limitation_storage_id_fkey FOREIGN KEY (storage_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: quota quota_storage_pool_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.quota
    ADD CONSTRAINT quota_storage_pool_id_fkey FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: step_subject_entity step_subject_entity_step_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.step_subject_entity
    ADD CONSTRAINT step_subject_entity_step_id_fkey FOREIGN KEY (step_id) REFERENCES public.step(step_id) ON DELETE CASCADE;


--
-- Name: storage_device storage_device_vds_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_device
    ADD CONSTRAINT storage_device_vds_id_fkey FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: storage_domains_ovf_info storage_domains_ovf_info_ovf_disk_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domains_ovf_info
    ADD CONSTRAINT storage_domains_ovf_info_ovf_disk_id_fkey FOREIGN KEY (ovf_disk_id) REFERENCES public.base_disks(disk_id) ON DELETE CASCADE;


--
-- Name: storage_domains_ovf_info storage_domains_ovf_info_storage_domain_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.storage_domains_ovf_info
    ADD CONSTRAINT storage_domains_ovf_info_storage_domain_id_fkey FOREIGN KEY (storage_domain_id) REFERENCES public.storage_domain_static(id) ON DELETE CASCADE;


--
-- Name: supported_cluster_features supported_cluster_features_cluster_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.supported_cluster_features
    ADD CONSTRAINT supported_cluster_features_cluster_id_fkey FOREIGN KEY (cluster_id) REFERENCES public.cluster(cluster_id) ON DELETE CASCADE;


--
-- Name: supported_cluster_features supported_cluster_features_feature_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.supported_cluster_features
    ADD CONSTRAINT supported_cluster_features_feature_id_fkey FOREIGN KEY (feature_id) REFERENCES public.cluster_features(feature_id) ON DELETE CASCADE;


--
-- Name: supported_host_features supported_host_features_host_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.supported_host_features
    ADD CONSTRAINT supported_host_features_host_id_fkey FOREIGN KEY (host_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: tags_user_group_map tags_user_group_map_tag; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_group_map
    ADD CONSTRAINT tags_user_group_map_tag FOREIGN KEY (tag_id) REFERENCES public.tags(tag_id);


--
-- Name: tags_user_map tags_user_map_tag; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_map
    ADD CONSTRAINT tags_user_map_tag FOREIGN KEY (tag_id) REFERENCES public.tags(tag_id);


--
-- Name: tags_user_map tags_user_map_user; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_map
    ADD CONSTRAINT tags_user_map_user FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: tags_user_group_map tags_user_map_user_group; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_user_group_map
    ADD CONSTRAINT tags_user_map_user_group FOREIGN KEY (group_id) REFERENCES public.ad_groups(id);


--
-- Name: tags_vds_map tags_vds_map_tag; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vds_map
    ADD CONSTRAINT tags_vds_map_tag FOREIGN KEY (tag_id) REFERENCES public.tags(tag_id);


--
-- Name: tags_vds_map tags_vds_map_vds; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vds_map
    ADD CONSTRAINT tags_vds_map_vds FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id);


--
-- Name: tags_vm_map tags_vm_map_tag; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_map
    ADD CONSTRAINT tags_vm_map_tag FOREIGN KEY (tag_id) REFERENCES public.tags(tag_id);


--
-- Name: tags_vm_map tags_vm_map_vm; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.tags_vm_map
    ADD CONSTRAINT tags_vm_map_vm FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vds_dynamic vds_static_vds_dynamic; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_dynamic
    ADD CONSTRAINT vds_static_vds_dynamic FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id);


--
-- Name: vds_statistics vds_static_vds_statistics; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vds_statistics
    ADD CONSTRAINT vds_static_vds_statistics FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id);


--
-- Name: vm_dynamic vds_static_vm_dynamic_m; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_dynamic
    ADD CONSTRAINT vds_static_vm_dynamic_m FOREIGN KEY (migrating_to_vds) REFERENCES public.vds_static(vds_id);


--
-- Name: vm_dynamic vds_static_vm_dynamic_r; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_dynamic
    ADD CONSTRAINT vds_static_vm_dynamic_r FOREIGN KEY (run_on_vds) REFERENCES public.vds_static(vds_id);


--
-- Name: vfs_config_labels vfs_config_labels_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vfs_config_labels
    ADD CONSTRAINT vfs_config_labels_id_fk FOREIGN KEY (vfs_config_id) REFERENCES public.host_nic_vfs_config(id) ON DELETE CASCADE;


--
-- Name: vfs_config_networks vfs_config_networks_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vfs_config_networks
    ADD CONSTRAINT vfs_config_networks_id_fk FOREIGN KEY (vfs_config_id) REFERENCES public.host_nic_vfs_config(id) ON DELETE CASCADE;


--
-- Name: vfs_config_networks vfs_config_networks_network_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vfs_config_networks
    ADD CONSTRAINT vfs_config_networks_network_fk FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE CASCADE;


--
-- Name: host_nic_vfs_config vfs_config_nic_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.host_nic_vfs_config
    ADD CONSTRAINT vfs_config_nic_id_fk FOREIGN KEY (nic_id) REFERENCES public.vds_interface(id) ON DELETE CASCADE;


--
-- Name: vm_backups vm_backups_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_backups
    ADD CONSTRAINT vm_backups_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_checkpoints vm_checkpoints_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_checkpoints
    ADD CONSTRAINT vm_checkpoints_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_device vm_device_snapshot_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_device
    ADD CONSTRAINT vm_device_snapshot_id_fkey FOREIGN KEY (snapshot_id) REFERENCES public.snapshots(snapshot_id) ON DELETE CASCADE;


--
-- Name: vm_external_data vm_external_data_device_id_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_external_data
    ADD CONSTRAINT vm_external_data_device_id_vm_id_fkey FOREIGN KEY (device_id, vm_id) REFERENCES public.vm_device(device_id, vm_id) ON DELETE CASCADE;


--
-- Name: vm_pool_map vm_guid_pools; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_pool_map
    ADD CONSTRAINT vm_guid_pools FOREIGN KEY (vm_guid) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_host_pinning_map vm_host_pinning_map_vds_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_host_pinning_map
    ADD CONSTRAINT vm_host_pinning_map_vds_id_fkey FOREIGN KEY (vds_id) REFERENCES public.vds_static(vds_id) ON DELETE CASCADE;


--
-- Name: vm_host_pinning_map vm_host_pinning_map_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_host_pinning_map
    ADD CONSTRAINT vm_host_pinning_map_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_interface_filter_parameters vm_interface_filter_parameters_vm_interface_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_interface_filter_parameters
    ADD CONSTRAINT vm_interface_filter_parameters_vm_interface_id_fkey FOREIGN KEY (vm_interface_id) REFERENCES public.vm_interface(id) ON DELETE CASCADE;


--
-- Name: vm_nvram_data vm_nvram_data_vm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_nvram_data
    ADD CONSTRAINT vm_nvram_data_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_ovf_generations vm_ovf_generations_storage_pool_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_ovf_generations
    ADD CONSTRAINT vm_ovf_generations_storage_pool_id_fkey FOREIGN KEY (storage_pool_id) REFERENCES public.storage_pool(id) ON DELETE CASCADE;


--
-- Name: vm_pool_map vm_pools_vm; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_pool_map
    ADD CONSTRAINT vm_pools_vm FOREIGN KEY (vm_pool_id) REFERENCES public.vm_pools(vm_pool_id);


--
-- Name: vm_dynamic vm_static_vm_dynamic; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_dynamic
    ADD CONSTRAINT vm_static_vm_dynamic FOREIGN KEY (vm_guid) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_init vm_static_vm_init; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_init
    ADD CONSTRAINT vm_static_vm_init FOREIGN KEY (vm_id) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_statistics vm_static_vm_statistics; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_statistics
    ADD CONSTRAINT vm_static_vm_statistics FOREIGN KEY (vm_guid) REFERENCES public.vm_static(vm_guid) ON DELETE CASCADE;


--
-- Name: vm_static vm_templates_vm_static; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vm_static
    ADD CONSTRAINT vm_templates_vm_static FOREIGN KEY (vmt_guid) REFERENCES public.vm_static(vm_guid);


--
-- Name: vnic_profiles vnic_profiles_network_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: engine
--

ALTER TABLE ONLY public.vnic_profiles
    ADD CONSTRAINT vnic_profiles_network_id_fkey FOREIGN KEY (network_id) REFERENCES public.network(id) ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

